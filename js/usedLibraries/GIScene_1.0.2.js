/** 
 * Base Object wich gives the namespace for all other classes of the library.
 * Defines global constants used in other classes 
 
	@module GIScene
	@main GIScene
	
	@class GIScene
	@static
	
	@author mcauer https://github.com/mcauer
*/

var GIScene = {
	/**
	 * 
	 * @property VERSION
	 * @type String
	 * @final
	 * @public 
	 * 
	 * 
	 * */
	VERSION:"1.0.2",
	
	/**
	 * The Path to where this file is stored
	 * 
	 * @property LIBRARYPATH
	 * @type String
	 * @final
	 * @public
	 */
	LIBRARYPATH: null,
	
	/**
	 * Constants for setting bitmask flags on working material to indicate that it is still in use by some control
	 *  
	 * @property WORKINGMATERIALFLAGS
	 * @type Object
	 * @final
	 * @public
	 * @example
	 * 		WORKINGMATERIALFLAGS:{
				SELECT:1,	//material is highlighted by GIScene.Control.Select
				WIRE:2,		//wireframe state has been changed
				SHADING:4,	//shading mode ( smooth | flat ) has been changed
				SIDE:8,		//face culling has been changed ( front | back | double )
				MAP:16,		//texture has been turned off
				OPACITY:32, //opacity value has been changed
				VERTEXCOLORS:64, //vertexColors ( noColors | faceColors | vertexColors )
				DIFFUSE:128, //diffuseColor ( THREE.Color )
				AMBIENT:256 //ambientColor ( THREE.Color )
			}
	 */
	WORKINGMATERIALFLAGS:{
		SELECT:1,	//material is highlighted by GIScene.Control.Select
		WIRE:2,		//wireframe state has been changed
		SHADING:4,	//shading mode ( smooth | flat ) has been changed
		SIDE:8,		//face culling has been changed ( front | back | double )
		MAP:16,		//texture has been turned off
		OPACITY:32, //opacity value has been changed
		VERTEXCOLORS:64, //vertexColors ( noColors | faceColors | vertexColors )
		DIFFUSE:128, //diffuseColor ( THREE.Color )
		AMBIENT:256 //ambientColor ( THREE.Color )
	},
	
	
	
	/**
	 * For internal use only.
	 *
	 * @property idCounter
	 * @type Number
	 */
	idCounter:0
};
// auto detect librarypath
var scripts = document.getElementsByTagName('script');
GIScene.LIBRARYPATH = scripts[scripts.length-1].src.replace(/\/GIScene\.js$/, '/');
GIScene.LIBRARYPATH = GIScene.LIBRARYPATH.replace(/\/GIScene_.*\.js$/, '/');


/**
	 * The relative path from the script folder (where GIScene_x.x.x.js is stored) to the "resources" folder
	 * 
	 * @property RESOURCESPATH
	 * @type String
	 * @final
	 * @public
	 */
GIScene.RESOURCESPATH = "";
/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

};

THREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function( url, callback, parameters ) {

	var scope = this;

	var xhr = new XMLHttpRequest();

	var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var jsonObject = JSON.parse( xhr.responseText );

				var materials = [], geometries = [], counter = 0;

				function callbackFinal( geometry ) {

					counter += 1;

					geometries.push( geometry );

					if ( counter === jsonObject.offsets.length ) {

						callback( geometries, materials );

					}

				}


				// init materials

				for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

					materials[ i ] = THREE.Loader.prototype.createMaterial( jsonObject.materials[ i ], basePath );

				}

				// load joined CTM file

				var partUrl = basePath + jsonObject.data;
				var parametersPart = { useWorker: parameters.useWorker, useBuffers: parameters.useBuffers, offsets: jsonObject.offsets };
				scope.load( partUrl, callbackFinal, parametersPart );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

// Load CTMLoader compressed models
//  - parameters
//		- url (required)
//		- callback (required)

THREE.CTMLoader.prototype.load = function( url, callback, parameters ) {

	var scope = this;

	var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];
	var useBuffers = parameters.useBuffers !== undefined ? parameters.useBuffers : true;

	var xhr = new XMLHttpRequest(),
		callbackProgress = null;

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var binaryData = new Uint8Array(xhr.response);

				var s = Date.now();

				if ( parameters.useWorker ) {

					// var worker = new Worker( "js/loaders/ctm/CTMWorker.js" );
					var worker = new Worker( window.URL.createObjectURL(new Blob([THREE.CTMLoader.workerString], {type: "text/javascript"})));

					worker.onmessage = function( event ) {

						var files = event.data;

						for ( var i = 0; i < files.length; i ++ ) {

							var ctmFile = files[ i ];

                            				var e1 = Date.now();
                            				// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

							if ( useBuffers ) {

								scope.createModelBuffers( ctmFile, callback );

							} else {

								scope.createModelClassic( ctmFile, callback );

							}

                            				var e = Date.now();
                            				console.log( "model load time [worker]: " + (e-e1) + " ms, total: " + (e-s));

						}


					};

					worker.postMessage( { "data": binaryData, "offsets": offsets } );

				} else {

					for ( var i = 0; i < offsets.length; i ++ ) {

						var stream = new CTM.Stream( binaryData );
						stream.offset = offsets[ i ];

						var ctmFile = new CTM.File( stream );

						if ( useBuffers ) {

							scope.createModelBuffers( ctmFile, callback );

						} else {

							scope.createModelClassic( ctmFile, callback );

						}

					}

					//var e = Date.now();
					//console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === 3 ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";

	xhr.send( null );

};


THREE.CTMLoader.prototype.createModelBuffers = function ( file, callback ) {

	var Model = function ( ) {

		var scope = this;

		var reorderVertices = true;

		scope.materials = [];

		THREE.BufferGeometry.call( this );

		var s = Date.now();
		// init GL buffers

		var vertexIndexArray = file.body.indices,
		vertexPositionArray = file.body.vertices,
		vertexNormalArray = file.body.normals;

		var vertexUvArray, vertexColorArray;

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 ) {
			vertexUvArray = file.body.uvMaps[ 0 ].uv;
		}

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" ) {
			vertexColorArray = file.body.attrMaps[ 0 ].attr;
		}

		// reorder vertices
		// (needed for buffer splitting, to keep together face vertices)
		if ( reorderVertices ) {

		    	function copyVertexInfo(v, vt) {

				var sx = v * 3,
			    	    sy = v * 3 + 1,
			    	    sz = v * 3 + 2,

			    	dx = vt * 3,
			    	dy = vt * 3 + 1,
			    	dz = vt * 3 + 2;

				newVertices[ dx ] = vertexPositionArray[ sx ];
				newVertices[ dy ] = vertexPositionArray[ sy ];
				newVertices[ dz ] = vertexPositionArray[ sz ];

				if ( vertexNormalArray ) {
				    newNormals[ dx ] = vertexNormalArray[ sx ];
				    newNormals[ dy ] = vertexNormalArray[ sy ];
				    newNormals[ dz ] = vertexNormalArray[ sz ];
				}

				if ( vertexUvArray ) {
				    newUvs[ vt * 2 ] 	 = vertexUvArray[ v * 2 ];
				    newUvs[ vt * 2 + 1 ] = vertexUvArray[ v * 2 + 1 ];
				}

				if ( vertexColorArray ) {
				    newColors[ vt * 4 ] 	= vertexColorArray[ v * 4 ];
				    newColors[ vt * 4 + 1 ] = vertexColorArray[ v * 4 + 1 ];
				    newColors[ vt * 4 + 2 ] = vertexColorArray[ v * 4 + 2 ];
				    newColors[ vt * 4 + 3 ] = vertexColorArray[ v * 4 + 3 ];
				}
		    	}

		    	function handleVertex( v, iMap ) {

				if ( iMap[ v ] === undefined ) {

					iMap[ v ] = vertexCounter;
                    			reverseIndexMap[vertexCounter] = v;
					vertexCounter += 1;
				}
                		return iMap[ v ];
		    	}

			var newFaces = new Uint32Array( vertexIndexArray.length );
			var indexMap = {}, reverseIndexMap = {}, vertexCounter = 0;

            		var spawledFaceCount = 0,
                	    spawledFaceLimit = Math.ceil(vertexIndexArray.length/3000);
            		var sprawledFaces = new Uint32Array( spawledFaceLimit );  // to store sprawled triangle indices

			for ( var i = 0; i < vertexIndexArray.length; i += 3 ) {

				var a = vertexIndexArray[ i ];
				var b = vertexIndexArray[ i + 1 ];
				var c = vertexIndexArray[ i + 2 ];

				handleVertex( a, indexMap );
				handleVertex( b, indexMap );
				handleVertex( c, indexMap );

				// check for sprawled triangles and put them aside to recreate later
				if ( Math.abs( indexMap[a] - indexMap[b] ) > 65535 ||
                     		     Math.abs( indexMap[b] - indexMap[c] ) > 65535 ||
                     		     Math.abs( indexMap[c] - indexMap[a] ) > 65535 ){

			    		// expand storage when neccessary
			    		if (spawledFaceCount >= spawledFaceLimit) {
						console.warn("reached sprawled faces limit: " + spawledFaceCount);
						spawledFaceLimit *= 2;
						var tArr = new Uint32Array( spawledFaceLimit );
						tArr.set(sprawledFaces);
						sprawledFaces = tArr;
			    		}

                    			sprawledFaces[ spawledFaceCount ] = i;  // starting index in newFaces
                    			spawledFaceCount += 1;
                		}
                		else {

				    newFaces[ i ] 	  = indexMap[ a ];
				    newFaces[ i + 1 ] = indexMap[ b ];
				    newFaces[ i + 2 ] = indexMap[ c ];
                		}
			}
            		// console.log("Number of sprawled faces: " + spawledFaceCount + " current limit: " + spawledFaceLimit +
                        //	" total: " + vertexIndexArray.length/3 + " vertices: " + vertexCounter);

			// create dublicate vertices and update sprawled faces
			var indexMap2 = {},
			    noov = vertexCounter;   // # of original vertices

			for (var isf = 0; isf < spawledFaceCount; isf++ ) {
				var i = sprawledFaces[isf];

				for (var j = 0; j < 3; j++) {
				    var v = vertexIndexArray[ i + j ];
				    newFaces[ i + j] = handleVertex(v, indexMap2);   // new vertex
				}
			}

			// console.log("Created duplicated vertices: " + (vertexCounter - noov));

			// copy xyz, uv, normals and colors into new arrays
			var newVertices = new Float32Array( 3*vertexCounter );
			var newNormals, newUvs, newColors;

			if ( vertexNormalArray ) newNormals = new Float32Array( 3*vertexCounter );
			if ( vertexUvArray ) newUvs = new Float32Array( 2*vertexCounter );
			if ( vertexColorArray ) newColors = new Float32Array( 4*vertexCounter );

			for (var iv = 0; iv < vertexCounter; iv++) {
				copyVertexInfo(reverseIndexMap[iv], iv);
			}

			vertexIndexArray = newFaces;
			vertexPositionArray = newVertices;

			if ( vertexNormalArray ) vertexNormalArray = newNormals;
			if ( vertexUvArray ) vertexUvArray = newUvs;
			if ( vertexColorArray ) vertexColorArray = newColors;
		}

		// compute offsets

		scope.offsets = [];

		var indices = vertexIndexArray;

		var start = 0,
			min = vertexPositionArray.length,
			max = 0,
			minPrev = min;

		for ( var i = 0; i < indices.length; ) {

			for ( var j = 0; j < 3; ++ j ) {

				var idx = indices[ i ++ ];

				if ( idx < min ) min = idx;
				if ( idx > max ) max = idx;

			}

			if ( max - min > 65535 ) {

				i -= 3;

                		if ( minPrev > 0 ) {

				    for ( var k = start; k < i; ++ k )
					    indices[ k ] -= minPrev;
				}

				scope.offsets.push( { start: start, count: i - start, index: minPrev } );

				start = i;
				min = vertexPositionArray.length;
				max = 0;

			}

			minPrev = min;

		}

        	if ( minPrev > 0 ) {

		    for ( var k = start; k < i; ++ k )
			    indices[ k ] -= minPrev;
		}
		scope.offsets.push( { start: start, count: i - start, index: minPrev } );

        	// var e = Date.now();
		// console.log( "Vetex reordering time: " + (e-s) + " ms" );

		// recast CTM 32-bit indices as 16-bit WebGL indices
		var vertexIndexArray16 = new Uint16Array( vertexIndexArray );

		// attributes
		var attributes = scope.attributes;

		attributes[ "index" ]    = { itemSize: 1, array: vertexIndexArray16, numItems: vertexIndexArray16.length };
		attributes[ "position" ] = { itemSize: 3, array: vertexPositionArray, numItems: vertexPositionArray.length };

		if ( vertexNormalArray !== undefined ) {

			attributes[ "normal" ] = { itemSize: 3, array: vertexNormalArray, numItems: vertexNormalArray.length };

		}

		if ( vertexUvArray !== undefined ) {

			attributes[ "uv" ] = { itemSize: 2, array: vertexUvArray, numItems: vertexUvArray.length };

		}

		if ( vertexColorArray !== undefined ) {

			attributes[ "color" ]  = { itemSize: 4, array: vertexColorArray, numItems: vertexColorArray.length };

		}

	};

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );

	var geometry = new Model();

	// compute vertex normals if not present in the CTM model

	if ( geometry.attributes[ "normal" ] === undefined ) {

		geometry.computeVertexNormals();

	}

	callback( geometry );

};

THREE.CTMLoader.prototype.createModelClassic = function ( file, callback ) {
console.log(file.body);
	var Model = function ( ) {

		var scope = this;

		scope.materials = [];

		THREE.Geometry.call( this );

		var normals = [],
			uvs = [],
			colors = [];

		init_vertices( file.body.vertices );

		if ( file.body.normals !== undefined )
			init_normals( file.body.normals );

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 )
			init_uvs( file.body.uvMaps[ 0 ].uv );

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" )
			init_colors( file.body.attrMaps[ 0 ].attr );

		var hasNormals = normals.length > 0 ? true : false,
			hasUvs = uvs.length > 0 ? true : false,
			hasColors = colors.length > 0 ? true : false;

		init_faces( file.body.indices );

		this.computeCentroids();
		this.computeFaceNormals();
		//this.computeTangents();

		function init_vertices( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				vertex( scope, x, y, z );

			}

		};

		function init_normals( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				normals.push( x, y, z );

			}

		};

		function init_colors( buffer ) {

			var r, g, b, a, i, il = buffer.length;

			for( i = 0; i < il; i += 4 ) {

				r = buffer[ i ];
				g = buffer[ i + 1 ];
				b = buffer[ i + 2 ];
				a = buffer[ i + 3 ];

				var color = new THREE.Color();
				color.setRGB( r, g, b );

				colors.push( color );

			}

		};


		function init_uvs( buffer ) {

			var u, v, i, il = buffer.length;

			for( i = 0; i < il; i += 2 ) {

				u = buffer[ i ];
				v = buffer[ i + 1 ];

				uvs.push( u, v );

			}

		};

		function init_faces( buffer ) {

			var a, b, c,
				u1, v1, u2, v2, u3, v3,
				m, face,
				i, il = buffer.length;

			m = 0; // all faces defaulting to material 0

			for( i = 0; i < il; i += 3 ) {

				a = buffer[ i ];
				b = buffer[ i + 1 ];
				c = buffer[ i + 2 ];

				if ( hasNormals ){

					face = f3n( scope, normals, a, b, c, m, a, b, c );

				} else {

					face = f3( scope, a, b, c, m );

				}

				if ( hasColors ) {

					face.vertexColors[ 0 ] = colors[ a ];
					face.vertexColors[ 1 ] = colors[ b ];
					face.vertexColors[ 2 ] = colors[ c ];

				}

				if ( hasUvs ) {

					u1 = uvs[ a * 2 ];
					v1 = uvs[ a * 2 + 1 ];

					u2 = uvs[ b * 2 ];
					v2 = uvs[ b * 2 + 1 ];

					u3 = uvs[ c * 2 ];
					v3 = uvs[ c * 2 + 1 ];

					uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

				}

			}

		}

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		var face = new THREE.Face3( a, b, c, null, null, mi );

		scope.faces.push( face );

		return face;

	};

	function f3n ( scope, normals, a, b, c, mi, nai, nbi, nci ) {

		var nax = normals[ nai * 3     ],
			nay = normals[ nai * 3 + 1 ],
			naz = normals[ nai * 3 + 2 ],

			nbx = normals[ nbi * 3     ],
			nby = normals[ nbi * 3 + 1 ],
			nbz = normals[ nbi * 3 + 2 ],

			ncx = normals[ nci * 3     ],
			ncy = normals[ nci * 3 + 1 ],
			ncz = normals[ nci * 3 + 2 ];

		var na = new THREE.Vector3( nax, nay, naz ),
			nb = new THREE.Vector3( nbx, nby, nbz ),
			nc = new THREE.Vector3( ncx, ncy, ncz );

		var face = new THREE.Face3( a, b, c, [ na, nb, nc ], null, mi );

		scope.faces.push( face );

		return face;

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.Vector2( u1, v1 ) );
		uv.push( new THREE.Vector2( u2, v2 ) );
		uv.push( new THREE.Vector2( u3, v3 ) );
		where.push( uv );

	};

	Model.prototype = Object.create( THREE.Geometry.prototype );

	callback( new Model() );

};

THREE.CTMLoader.workerString = 
	//importScripts( "lzma.js", "ctm.js" );
	
	//lzma.js"
	
	"var LZMA = LZMA || {};\n"+
	
	"LZMA.OutWindow = function(){\n"+
	"  this._windowSize = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.create = function(windowSize){\n"+
	"  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n"+
	"    this._buffer = [];\n"+
	"  }\n"+
	"  this._windowSize = windowSize;\n"+
	"  this._pos = 0;\n"+
	"  this._streamPos = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.flush = function(){\n"+
	"  var size = this._pos - this._streamPos;\n"+
	"  if (size !== 0){\n"+
	"    while(size --){\n"+
	"      this._stream.writeByte(this._buffer[this._streamPos ++]);\n"+
	"    }\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this._pos = 0;\n"+
	"    }\n"+
	"    this._streamPos = this._pos;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.releaseStream = function(){\n"+
	"  this.flush();\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.setStream = function(stream){\n"+
	"  this.releaseStream();\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.init = function(solid){\n"+
	"  if (!solid){\n"+
	"    this._streamPos = 0;\n"+
	"    this._pos = 0;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.copyBlock = function(distance, len){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  while(len --){\n"+
	"    if (pos >= this._windowSize){\n"+
	"      pos = 0;\n"+
	"    }\n"+
	"    this._buffer[this._pos ++] = this._buffer[pos ++];\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this.flush();\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.putByte = function(b){\n"+
	"  this._buffer[this._pos ++] = b;\n"+
	"  if (this._pos >= this._windowSize){\n"+
	"    this.flush();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.getByte = function(distance){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  return this._buffer[pos];\n"+
	"};\n"+
	
	"LZMA.RangeDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.setStream = function(stream){\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.releaseStream = function(){\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.init = function(){\n"+
	"  var i = 5;\n"+
	
	"  this._code = 0;\n"+
	"  this._range = -1;\n"+
	"  \n"+
	"  while(i --){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n"+
	"  var result = 0, i = numTotalBits, t;\n"+
	
	"  while(i --){\n"+
	"    this._range >>>= 1;\n"+
	"    t = (this._code - this._range) >>> 31;\n"+
	"    this._code -= this._range & (t - 1);\n"+
	"    result = (result << 1) | (1 - t);\n"+
	
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return result;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n"+
	"  var prob = probs[index],\n"+
	"      newBound = (this._range >>> 11) * prob;\n"+
	
	"  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n"+
	"    this._range = newBound;\n"+
	"    probs[index] += (2048 - prob) >>> 5;\n"+
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"    return 0;\n"+
	"  }\n"+
	
	"  this._range -= newBound;\n"+
	"  this._code -= newBound;\n"+
	"  probs[index] -= prob >>> 5;\n"+
	"  if ( (this._range & 0xff000000) === 0){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"    this._range <<= 8;\n"+
	"  }\n"+
	"  return 1;\n"+
	"};\n"+
	
	"LZMA.initBitModels = function(probs, len){\n"+
	"  while(len --){\n"+
	"    probs[len] = 1024;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder = function(numBitLevels){\n"+
	"  this._models = [];\n"+
	"  this._numBitLevels = numBitLevels;\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n"+
	"  var m = 1, i = this._numBitLevels;\n"+
	
	"  while(i --){\n"+
	"    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n"+
	"  }\n"+
	"  return m - (1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < this._numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(this._models, m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(models, startIndex + m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.LenDecoder = function(){\n"+
	"  this._choice = [];\n"+
	"  this._lowCoder = [];\n"+
	"  this._midCoder = [];\n"+
	"  this._highCoder = new LZMA.BitTreeDecoder(8);\n"+
	"  this._numPosStates = 0;\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.create = function(numPosStates){\n"+
	"  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n"+
	"    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.init = function(){\n"+
	"  var i = this._numPosStates;\n"+
	"  LZMA.initBitModels(this._choice, 2);\n"+
	"  while(i --){\n"+
	"    this._lowCoder[i].init();\n"+
	"    this._midCoder[i].init();\n"+
	"  }\n"+
	"  this._highCoder.init();\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n"+
	"    return this._lowCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n"+
	"    return 8 + this._midCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  return 16 + this._highCoder.decode(rangeDecoder);\n"+
	"};\n"+
	
	"LZMA.Decoder2 = function(){\n"+
	"  this._decoders = [];\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._decoders, 0x300);\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n"+
	"  var symbol = 1;\n"+
	
	"  do{\n"+
	"    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n"+
	"  var symbol = 1, matchBit, bit;\n"+
	
	"  do{\n"+
	"    matchBit = (matchByte >> 7) & 1;\n"+
	"    matchByte <<= 1;\n"+
	"    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n"+
	"    symbol = (symbol << 1) | bit;\n"+
	"    if (matchBit !== bit){\n"+
	"      while(symbol < 0x100){\n"+
	"        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"      }\n"+
	"      break;\n"+
	"    }\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n"+
	"  var i;\n"+
	
	"  if (this._coders\n"+
	"    && (this._numPrevBits === numPrevBits)\n"+
	"    && (this._numPosBits === numPosBits) ){\n"+
	"    return;\n"+
	"  }\n"+
	"  this._numPosBits = numPosBits;\n"+
	"  this._posMask = (1 << numPosBits) - 1;\n"+
	"  this._numPrevBits = numPrevBits;\n"+
	
	"  this._coders = [];\n"+
	
	"  i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i] = new LZMA.Decoder2();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.init = function(){\n"+
	"  var i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i].init();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n"+
	"  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n"+
	"    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n"+
	"};\n"+
	
	"LZMA.Decoder = function(){\n"+
	"  this._outWindow = new LZMA.OutWindow();\n"+
	"  this._rangeDecoder = new LZMA.RangeDecoder();\n"+
	"  this._isMatchDecoders = [];\n"+
	"  this._isRepDecoders = [];\n"+
	"  this._isRepG0Decoders = [];\n"+
	"  this._isRepG1Decoders = [];\n"+
	"  this._isRepG2Decoders = [];\n"+
	"  this._isRep0LongDecoders = [];\n"+
	"  this._posSlotDecoder = [];\n"+
	"  this._posDecoders = [];\n"+
	"  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n"+
	"  this._lenDecoder = new LZMA.LenDecoder();\n"+
	"  this._repLenDecoder = new LZMA.LenDecoder();\n"+
	"  this._literalDecoder = new LZMA.LiteralDecoder();\n"+
	"  this._dictionarySize = -1;\n"+
	"  this._dictionarySizeCheck = -1;\n"+
	
	"  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n"+
	"  if (dictionarySize < 0){\n"+
	"    return false;\n"+
	"  }\n"+
	"  if (this._dictionarySize !== dictionarySize){\n"+
	"    this._dictionarySize = dictionarySize;\n"+
	"    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n"+
	"    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n"+
	"  }\n"+
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n"+
	"  var numPosStates = 1 << pb;\n"+
	
	"  if (lc > 8 || lp > 4 || pb > 4){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  this._literalDecoder.create(lp, lc);\n"+
	
	"  this._lenDecoder.create(numPosStates);\n"+
	"  this._repLenDecoder.create(numPosStates);\n"+
	"  this._posStateMask = numPosStates - 1;\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.init = function(){\n"+
	"  var i = 4;\n"+
	
	"  this._outWindow.init(false);\n"+
	
	"  LZMA.initBitModels(this._isMatchDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRepDecoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG0Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG1Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG2Decoders, 12);\n"+
	"  LZMA.initBitModels(this._posDecoders, 114);\n"+
	
	"  this._literalDecoder.init();\n"+
	
	"  while(i --){\n"+
	"    this._posSlotDecoder[i].init();\n"+
	"  }\n"+
	
	"  this._lenDecoder.init();\n"+
	"  this._repLenDecoder.init();\n"+
	"  this._posAlignDecoder.init();\n"+
	"  this._rangeDecoder.init();\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n"+
	"  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n"+
	"      posState, decoder2, len, distance, posSlot, numDirectBits;\n"+
	
	"  this._rangeDecoder.setStream(inStream);\n"+
	"  this._outWindow.setStream(outStream);\n"+
	
	"  this.init();\n"+
	
	"  while(outSize < 0 || nowPos64 < outSize){\n"+
	"    posState = nowPos64 & this._posStateMask;\n"+
	
	"    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n"+
	"      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n"+
	
	"      if (state >= 7){\n"+
	"        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n"+
	"      }else{\n"+
	"        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n"+
	"      }\n"+
	"      this._outWindow.putByte(prevByte);\n"+
	
	"      state = state < 4? 0: state - (state < 10? 3: 6);\n"+
	
	"    }else{\n"+
	
	"      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n"+
	"        len = 0;\n"+
	"        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n"+
	"            state = state < 7? 9: 11;\n"+
	"            len = 1;\n"+
	"          }\n"+
	"        }else{\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n"+
	"            distance = rep1;\n"+
	"          }else{\n"+
	"            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n"+
	"              distance = rep2;\n"+
	"            }else{\n"+
	"              distance = rep3;\n"+
	"              rep3 = rep2;\n"+
	"            }\n"+
	"            rep2 = rep1;\n"+
	"          }\n"+
	"          rep1 = rep0;\n"+
	"          rep0 = distance;\n"+
	"        }\n"+
	"        if (len === 0){\n"+
	"          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n"+
	"          state = state < 7? 8: 11;\n"+
	"        }\n"+
	"      }else{\n"+
	"        rep3 = rep2;\n"+
	"        rep2 = rep1;\n"+
	"        rep1 = rep0;\n"+
	
	"        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n"+
	"        state = state < 7? 7: 10;\n"+
	
	"        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n"+
	"        if (posSlot >= 4){\n"+
	
	"          numDirectBits = (posSlot >> 1) - 1;\n"+
	"          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n"+
	
	"          if (posSlot < 14){\n"+
	"            rep0 += LZMA.reverseDecode2(this._posDecoders,\n"+
	"                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n"+
	"          }else{\n"+
	"            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n"+
	"            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n"+
	"            if (rep0 < 0){\n"+
	"              if (rep0 === -1){\n"+
	"                break;\n"+
	"              }\n"+
	"              return false;\n"+
	"            }\n"+
	"          }\n"+
	"        }else{\n"+
	"          rep0 = posSlot;\n"+
	"        }\n"+
	"      }\n"+
	
	"      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n"+
	"        return false;\n"+
	"      }\n"+
	
	"      this._outWindow.copyBlock(rep0, len);\n"+
	"      nowPos64 += len;\n"+
	"      prevByte = this._outWindow.getByte(0);\n"+
	"    }\n"+
	"  }\n"+
	
	"  this._outWindow.flush();\n"+
	"  this._outWindow.releaseStream();\n"+
	"  this._rangeDecoder.releaseStream();\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDecoderProperties = function(properties){\n"+
	"  var value, lc, lp, pb, dictionarySize;\n"+
	
	"  if (properties.size < 5){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  value = properties.readByte();\n"+
	"  lc = value % 9;\n"+
	"  value = ~~(value / 9);\n"+
	"  lp = value % 5;\n"+
	"  pb = ~~(value / 5);\n"+
	
	"  if ( !this.setLcLpPb(lc, lp, pb) ){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  dictionarySize = properties.readByte();\n"+
	"  dictionarySize |= properties.readByte() << 8;\n"+
	"  dictionarySize |= properties.readByte() << 16;\n"+
	"  dictionarySize += properties.readByte() * 16777216;\n"+
	
	"  return this.setDictionarySize(dictionarySize);\n"+
	"};\n"+
	
	"LZMA.decompress = function(properties, inStream, outStream, outSize){\n"+
	"  var decoder = new LZMA.Decoder();\n"+
	
	"  if ( !decoder.setDecoderProperties(properties) ){\n"+
	"    throw 'Incorrect stream properties';\n"+
	"  }\n"+
	
	"  if ( !decoder.decode(inStream, outStream, outSize) ){\n"+
	"    throw 'Error in data stream';\n"+
	"  }\n"+
	
	"  return true;\n"+
	"};\n"+
	
	//ctm.js
	
	"var CTM = CTM || {};\n"+
	
	"CTM.CompressionMethod = {\n"+
	"  RAW: 0x00574152,\n"+
	"  MG1: 0x0031474d,\n"+
	"  MG2: 0x0032474d\n"+
	"};\n"+
	
	"CTM.Flags = {\n"+
	"  NORMALS: 0x00000001\n"+
	"};\n"+
	
	"CTM.File = function(stream){\n"+
	"  this.load(stream);\n"+
	"};\n"+
	
	"CTM.File.prototype.load = function(stream){\n"+
	"  this.header = new CTM.FileHeader(stream);\n"+
	
	"  this.body = new CTM.FileBody(this.header);\n"+
	"  \n"+
	"  this.getReader().read(stream, this.body);\n"+
	"};\n"+
	
	"CTM.File.prototype.getReader = function(){\n"+
	"  var reader;\n"+
	
	"  switch(this.header.compressionMethod){\n"+
	"    case CTM.CompressionMethod.RAW:\n"+
	"      reader = new CTM.ReaderRAW();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG1:\n"+
	"      reader = new CTM.ReaderMG1();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG2:\n"+
	"      reader = new CTM.ReaderMG2();\n"+
	"      break;\n"+
	"  }\n"+
	
	"  return reader;\n"+
	"};\n"+
	
	"CTM.FileHeader = function(stream){\n"+
	//magic "OCTM"
	"  stream.readInt32(); \n"+
	"  this.fileFormat = stream.readInt32();\n"+
	"  this.compressionMethod = stream.readInt32();\n"+
	"  this.vertexCount = stream.readInt32();\n"+
	"  this.triangleCount = stream.readInt32();\n"+
	"  this.uvMapCount = stream.readInt32();\n"+
	"  this.attrMapCount = stream.readInt32();\n"+
	"  this.flags = stream.readInt32();\n"+
	"  this.comment = stream.readString();\n"+
	"};\n"+
	
	"CTM.FileHeader.prototype.hasNormals = function(){\n"+
	"  return this.flags & CTM.Flags.NORMALS;\n"+
	"};\n"+
	
	"CTM.FileBody = function(header){\n"+
	"  var i = header.triangleCount * 3,\n"+
	"      v = header.vertexCount * 3,\n"+
	"      n = header.hasNormals()? header.vertexCount * 3: 0,\n"+
	"      u = header.vertexCount * 2,\n"+
	"      a = header.vertexCount * 4,\n"+
	"      j = 0;\n"+
	
	"  var data = new ArrayBuffer(\n"+
	"    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);\n"+
	
	"  this.indices = new Uint32Array(data, 0, i);\n"+
	
	"  this.vertices = new Float32Array(data, i * 4, v);\n"+
	
	"  if ( header.hasNormals() ){\n"+
	"    this.normals = new Float32Array(data, (i + v) * 4, n);\n"+
	"  }\n"+
	"  \n"+
	"  if (header.uvMapCount){\n"+
	"    this.uvMaps = [];\n"+
	"    for (j = 0; j < header.uvMapCount; ++ j){\n"+
	"      this.uvMaps[j] = {uv: new Float32Array(data,\n"+
	"        (i + v + n + (j * u) ) * 4, u) };\n"+
	"    }\n"+
	"  }\n"+
	"  \n"+
	"  if (header.attrMapCount){\n"+
	"    this.attrMaps = [];\n"+
	"    for (j = 0; j < header.attrMapCount; ++ j){\n"+
	"      this.attrMaps[j] = {attr: new Float32Array(data,\n"+
	"        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a),start:(i + v + n + (u * header.uvMapCount) + (j * a) ) * 4 ,end:a };\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.FileMG2Header = function(stream){\n"+
	//magic "MG2H"
	"  stream.readInt32(); \n"+
	"  this.vertexPrecision = stream.readFloat32();\n"+
	"  this.normalPrecision = stream.readFloat32();\n"+
	"  this.lowerBoundx = stream.readFloat32();\n"+
	"  this.lowerBoundy = stream.readFloat32();\n"+
	"  this.lowerBoundz = stream.readFloat32();\n"+
	"  this.higherBoundx = stream.readFloat32();\n"+
	"  this.higherBoundy = stream.readFloat32();\n"+
	"  this.higherBoundz = stream.readFloat32();\n"+
	"  this.divx = stream.readInt32();\n"+
	"  this.divy = stream.readInt32();\n"+
	"  this.divz = stream.readInt32();\n"+
	"  \n"+
	"  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\n"+
	"  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\n"+
	"  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\n"+
	"};\n"+
	
	"CTM.ReaderRAW = function(){\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readArrayInt32(indices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(vertices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(normals);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    stream.readArrayFloat32(uvMaps[i].uv);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    stream.readArrayFloat32(attrMaps[i].attr);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(vertices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	
	"  var interleaved = new CTM.InterleavedStream(normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	//packed size
	"    stream.readInt32(); \n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.read = function(stream, body){\n"+
	"  this.MG2Header = new CTM.FileMG2Header(stream);\n"+
	"  \n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(vertices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  var gridIndices = this.readGridIndices(stream, vertices);\n"+
	"  \n"+
	"  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){\n"+
	//magic "GIDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	"  \n"+
	"  var gridIndices = new Uint32Array(vertices.length / 3);\n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  CTM.restoreGridIndices(gridIndices, gridIndices.length);\n"+
	"  \n"+
	"  return gridIndices;\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readNormals = function(stream, body){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(body.normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\n"+
	
	"  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(uvMaps[i].uv, 2, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(attrMaps[i].attr, 4, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreIndices = function(indices, len){\n"+
	"  var i = 3;\n"+
	"  if (len > 0){\n"+
	"    indices[2] += indices[0];\n"+
	"    indices[1] += indices[0];\n"+
	"  }\n"+
	"  for (; i < len; i += 3){\n"+
	"    indices[i] += indices[i - 3];\n"+
	"    \n"+
	"    if (indices[i] === indices[i - 3]){\n"+
	"      indices[i + 1] += indices[i - 2];\n"+
	"    }else{\n"+
	"      indices[i + 1] += indices[i];\n"+
	"    }\n"+
	
	"    indices[i + 2] += indices[i];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreGridIndices = function(gridIndices, len){\n"+
	"  var i = 1;\n"+
	"  for (; i < len; ++ i){\n"+
	"    gridIndices[i] += gridIndices[i - 1];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreVertices = function(vertices, grid, gridIndices, precision){\n"+
	"  var gridIdx, delta, x, y, z,\n"+
	"      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\n"+
	"      ydiv = grid.divx, zdiv = ydiv * grid.divy,\n"+
	"      prevGridIdx = 0x7fffffff, prevDelta = 0,\n"+
	"      i = 0, j = 0, len = gridIndices.length;\n"+
	
	"  for (; i < len; j += 3){\n"+
	"    x = gridIdx = gridIndices[i ++];\n"+
	"    \n"+
	"    z = ~~(x / zdiv);\n"+
	"    x -= ~~(z * zdiv);\n"+
	"    y = ~~(x / ydiv);\n"+
	"    x -= ~~(y * ydiv);\n"+
	
	"    delta = intVertices[j];\n"+
	"    if (gridIdx === prevGridIdx){\n"+
	"      delta += prevDelta;\n"+
	"    }\n"+
	
	"    vertices[j]     = grid.lowerBoundx +\n"+
	"      x * grid.sizex + precision * delta;\n"+
	"    vertices[j + 1] = grid.lowerBoundy +\n"+
	"      y * grid.sizey + precision * intVertices[j + 1];\n"+
	"    vertices[j + 2] = grid.lowerBoundz +\n"+
	"      z * grid.sizez + precision * intVertices[j + 2];\n"+
	
	"    prevGridIdx = gridIdx;\n"+
	"    prevDelta = delta;\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreNormals = function(normals, smooth, precision){\n"+
	"  var ro, phi, theta, sinPhi,\n"+
	"      nx, ny, nz, by, bz, len,\n"+
	"      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\n"+
	"      i = 0, k = normals.length,\n"+
	"      PI_DIV_2 = 3.141592653589793238462643 * 0.5;\n"+
	
	"  for (; i < k; i += 3){\n"+
	"    ro = intNormals[i] * precision;\n"+
	"    phi = intNormals[i + 1];\n"+
	
	"    if (phi === 0){\n"+
	"      normals[i]     = smooth[i]     * ro;\n"+
	"      normals[i + 1] = smooth[i + 1] * ro;\n"+
	"      normals[i + 2] = smooth[i + 2] * ro;\n"+
	"    }else{\n"+
	"      \n"+
	"      if (phi <= 4){\n"+
	"        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\n"+
	"      }else{\n"+
	"        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;\n"+
	"      }\n"+
	"      \n"+
	"      phi *= precision * PI_DIV_2;\n"+
	"      sinPhi = ro * Math.sin(phi);\n"+
	
	"      nx = sinPhi * Math.cos(theta);\n"+
	"      ny = sinPhi * Math.sin(theta);\n"+
	"      nz = ro * Math.cos(phi);\n"+
	
	"      bz = smooth[i + 1];\n"+
	"      by = smooth[i] - smooth[i + 2];\n"+
	
	"      len = Math.sqrt(2 * bz * bz + by * by);\n"+
	"      if (len > 1e-20){\n"+
	"        by /= len;\n"+
	"        bz /= len;\n"+
	"      }\n"+
	
	"      normals[i]     = smooth[i]     * nz +\n"+
	"        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\n"+
	"      normals[i + 1] = smooth[i + 1] * nz -\n"+
	"        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;\n"+
	"      normals[i + 2] = smooth[i + 2] * nz +\n"+
	"        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreMap = function(map, count, precision){\n"+
	"  var delta, value,\n"+
	"      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\n"+
	"      i = 0, j, len = map.length;\n"+
	
	"  for (; i < count; ++ i){\n"+
	"    delta = 0;\n"+
	
	"    for (j = i; j < len; j += count){\n"+
	"      value = intMap[j];\n"+
	"      \n"+
	"      delta += value & 1? -( (value + 1) >> 1): value >> 1;\n"+
	"      \n"+
	"      map[j] = delta * precision;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.calcSmoothNormals = function(indices, vertices){\n"+
	"  var smooth = new Float32Array(vertices.length),\n"+
	"      indx, indy, indz, nx, ny, nz,\n"+
	"      v1x, v1y, v1z, v2x, v2y, v2z, len,\n"+
	"      i, k;\n"+
	
	"  for (i = 0, k = indices.length; i < k;){\n"+
	"    indx = indices[i ++] * 3;\n"+
	"    indy = indices[i ++] * 3;\n"+
	"    indz = indices[i ++] * 3;\n"+
	
	"    v1x = vertices[indy]     - vertices[indx];\n"+
	"    v2x = vertices[indz]     - vertices[indx];\n"+
	"    v1y = vertices[indy + 1] - vertices[indx + 1];\n"+
	"    v2y = vertices[indz + 1] - vertices[indx + 1];\n"+
	"    v1z = vertices[indy + 2] - vertices[indx + 2];\n"+
	"    v2z = vertices[indz + 2] - vertices[indx + 2];\n"+
	"    \n"+
	"    nx = v1y * v2z - v1z * v2y;\n"+
	"    ny = v1z * v2x - v1x * v2z;\n"+
	"    nz = v1x * v2y - v1y * v2x;\n"+
	"    \n"+
	"    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n"+
	"    if (len > 1e-10){\n"+
	"      nx /= len;\n"+
	"      ny /= len;\n"+
	"      nz /= len;\n"+
	"    }\n"+
	"    \n"+
	"    smooth[indx]     += nx;\n"+
	"    smooth[indx + 1] += ny;\n"+
	"    smooth[indx + 2] += nz;\n"+
	"    smooth[indy]     += nx;\n"+
	"    smooth[indy + 1] += ny;\n"+
	"    smooth[indy + 2] += nz;\n"+
	"    smooth[indz]     += nx;\n"+
	"    smooth[indz + 1] += ny;\n"+
	"    smooth[indz + 2] += nz;\n"+
	"  }\n"+
	
	"  for (i = 0, k = smooth.length; i < k; i += 3){\n"+
	"    len = Math.sqrt(smooth[i] * smooth[i] + \n"+
	"      smooth[i + 1] * smooth[i + 1] +\n"+
	"      smooth[i + 2] * smooth[i + 2]);\n"+
	
	"    if(len > 1e-10){\n"+
	"      smooth[i]     /= len;\n"+
	"      smooth[i + 1] /= len;\n"+
	"      smooth[i + 2] /= len;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return smooth;\n"+
	"};\n"+
	
	"CTM.isLittleEndian = (function(){\n"+
	"  var buffer = new ArrayBuffer(2),\n"+
	"      bytes = new Uint8Array(buffer),\n"+
	"      ints = new Uint16Array(buffer);\n"+
	
	"  bytes[0] = 1;\n"+
	
	"  return ints[0] === 1;\n"+
	"}());\n"+
	
	"CTM.InterleavedStream = function(data, count){\n"+
	"  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n"+
	"  this.offset = CTM.isLittleEndian? 3: 0;\n"+
	"  this.count = count * 4;\n"+
	"  this.len = this.data.length;\n"+
	"};\n"+
	
	"CTM.InterleavedStream.prototype.writeByte = function(value){\n"+
	"  this.data[this.offset] = value;\n"+
	"  \n"+
	"  this.offset += this.count;\n"+
	"  if (this.offset >= this.len){\n"+
	"  \n"+
	"    this.offset -= this.len - 4;\n"+
	"    if (this.offset >= this.count){\n"+
	"    \n"+
	"      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.Stream = function(data){\n"+
	"  this.data = data;\n"+
	"  this.offset = 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\n"+
	
	"CTM.Stream.prototype.readByte = function(){\n"+
	"  return this.data[this.offset ++] & 0xff;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readInt32 = function(){\n"+
	"  var i = this.readByte();\n"+
	"  i |= this.readByte() << 8;\n"+
	"  i |= this.readByte() << 16;\n"+
	"  return i | (this.readByte() << 24);\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readFloat32 = function(){\n"+
	"  var m = this.readByte();\n"+
	"  m += this.readByte() << 8;\n"+
	
	"  var b1 = this.readByte();\n"+
	"  var b2 = this.readByte();\n"+
	
	"  m += (b1 & 0x7f) << 16; \n"+
	"  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);\n"+
	"  var s = b2 & 0x80? -1: 1;\n"+
	
	"  if (e === 255){\n"+
	"    return m !== 0? NaN: s * Infinity;\n"+
	"  }\n"+
	"  if (e > 0){\n"+
	"    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);\n"+
	"  }\n"+
	"  if (m !== 0){\n"+
	"    return s * m * this.TWO_POW_MINUS126;\n"+
	"  }\n"+
	"  return s * 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readString = function(){\n"+
	"  var len = this.readInt32();\n"+
	
	"  this.offset += len;\n"+
	
	"  return String.fromCharCode.apply(null,this.data.subarray(this.offset - len, this.offset));\n"+
	//"  return this.offset - len + ' bis ' + len;\n  //String.fromCharCode.apply(null,this.data.subarray(this.offset - len, len));\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayInt32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	"  \n"+
	"  while(i < len){\n"+
	"    array[i ++] = this.readInt32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayFloat32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	
	"  while(i < len){\n"+
	"    array[i ++] = this.readFloat32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	
	"//original CTMWorker.js\n"+
	"self.onmessage = function( event ) {\n"+
	
	"	var files = [];\n"+
	
	"	for ( var i = 0; i < event.data.offsets.length; i ++ ) {\n"+
	
	"		var stream = new CTM.Stream( event.data.data );\n"+
	"		stream.offset = event.data.offsets[ i ];\n"+
	
	"		files[ i ] = new CTM.File( stream );\n"+
	
	"	}\n"+
	
	"	self.postMessage( files );\n"+
	"	self.close();\n"+
	
	"};";
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlers = {};
	this.hierarchyHandlers = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

	//added by mca
	this.loader = new THREE.XHRLoader( this.manager );
};

THREE.SceneLoader.prototype = {

	constructor: THREE.SceneLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		// mca var loader = new THREE.XHRLoader( scope.manager );
		var loader = this.loader;
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {
			setTimeout(
				function(scope, text, onLoad, url){
					try{
						scope.parse( JSON.parse( text ), onLoad, url );
					}
					catch(e){
						console.log("SceneLoader_r63");
						console.log(e);
						console.log("ResponseText", text);
						onLoad({ //send empty result (fail silent)
								scene: new THREE.Scene(),
								geometries: {},
								face_materials: {},
								materials: {},
								textures: {},
								objects: {},
								cameras: {},
								lights: {},
								fogs: {},
								empties: {},
								groups: {}
								}
						);
					}
					
				}.bind(this), 1, scope, text, onLoad, url);
			
			// try{
				// scope.parse( JSON.parse( text ), onLoad, url );
			// }
			// catch(e){
				// console.log("SceneLoader_r63");
				// console.log(e);
				// console.log("ResponseText", text);
				// onLoad({ //send empty result (fail silent)
						// scene: new THREE.Scene(),
						// geometries: {},
						// face_materials: {},
						// materials: {},
						// textures: {},
						// objects: {},
						// cameras: {},
						// lights: {},
						// fogs: {},
						// empties: {},
						// groups: {}
						// }
				// );
			// }

		}, onProgress, onError );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	addGeometryHandler: function ( typeID, loaderClass ) {

		this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	addHierarchyHandler: function ( typeID, loaderClass ) {

		this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	parse: function ( json, callbackFinished, url ) {

		var scope = this;

		var urlBase = THREE.Loader.prototype.extractUrlBase( url );

		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;

		var target_array = [];

		var data = json;

		// async geometry loaders

		for ( var typeID in this.geometryHandlers ) {

			var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
			this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		// async hierachy loaders

		for ( var typeID in this.hierarchyHandlers ) {

			var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
			this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		counter_models = 0;
		counter_textures = 0;

		result = {

			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}

		};

		if ( data.transform ) {

			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;

			if ( position ) {

				result.scene.position.fromArray( position );

			}

			if ( rotation ) {

				result.scene.rotation.fromArray( rotation );

			}

			if ( scale ) {

				result.scene.scale.fromArray( scale );

			}

			if ( position || rotation || scale ) {

				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();

			}

		}

		function get_url( source_url, url_type ) {

			if ( url_type == "relativeToHTML" ) {

				return source_url;

			} else {

				return urlBase + "/" + source_url;

			}

		};

		// toplevel loader function, delegates to handle_children

		function handle_objects() {

			handle_children( result.scene, data.objects );

		}

		// handle all the children from the loaded json and attach them to given parent

		function handle_children( parent, children ) {

			var mat, dst, pos, rot, scl, quat;

			for ( var objID in children ) {

				// check by id if child has already been handled,
				// if not, create new object

				var object = result.objects[ objID ];
				var objJSON = children[ objID ];

				if ( object === undefined ) {

					// meshes

					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

						if ( objJSON.loading === undefined ) {

							var reservedTypes = {
								"type": 1, "url": 1, "material": 1,
								"position": 1, "rotation": 1, "scale" : 1,
								"visible": 1, "children": 1, "userData": 1,
								"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
							};

							var loaderParameters = {};

							for ( var parType in objJSON ) {

								if ( ! ( parType in reservedTypes ) ) {

									loaderParameters[ parType ] = objJSON[ parType ];

								}

							}

							material = result.materials[ objJSON.material ];

							objJSON.loading = true;

							var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];

							// ColladaLoader

							if ( loader.options ) {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

							// UTF8Loader
							// OBJLoader

							} else {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

							}

						}

					} else if ( objJSON.geometry !== undefined ) {

						geometry = result.geometries[ objJSON.geometry ];

						// geometry already loaded

						if ( geometry ) {

							var needsTangents = false;

							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;

							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;

							// use materials from the model file
							// if there is no material specified in the object

							if ( ! objJSON.material ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)

							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							if ( material instanceof THREE.MeshFaceMaterial ) {

								for ( var i = 0; i < material.materials.length; i ++ ) {

									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

								}

							}

							if ( needsTangents ) {

								geometry.computeTangents();

							}

							if ( objJSON.skin ) {

								object = new THREE.SkinnedMesh( geometry, material );

							} else if ( objJSON.morph ) {

								object = new THREE.MorphAnimMesh( geometry, material );

								if ( objJSON.duration !== undefined ) {

									object.duration = objJSON.duration;

								}

								if ( objJSON.time !== undefined ) {

									object.time = objJSON.time;

								}

								if ( objJSON.mirroredLoop !== undefined ) {

									object.mirroredLoop = objJSON.mirroredLoop;

								}

								if ( material.morphNormals ) {

									geometry.computeMorphNormals();

								}

							} else {

								object = new THREE.Mesh( geometry, material );

							}

							object.name = objID;

							if ( mat ) {

								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);

							} else {

								object.position.fromArray( pos );

								if ( quat ) {

									object.quaternion.fromArray( quat );

								} else {

									object.rotation.fromArray( rot );

								}

								object.scale.fromArray( scl );

							}

							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;

							parent.add( object );

							result.objects[ objID ] = object;

						}

					// lights

					} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
						objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
						objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {

						var color = objJSON.color;
						var intensity = objJSON.intensity;
						var distance = objJSON.distance;
						var position = objJSON.position;
						var rotation = objJSON.rotation;

						switch ( objJSON.type ) {

							case 'AmbientLight':
								light = new THREE.AmbientLight( color );
								break;

							case 'PointLight':
								light = new THREE.PointLight( color, intensity, distance );
								light.position.fromArray( position );
								break;

							case 'DirectionalLight':
								light = new THREE.DirectionalLight( color, intensity );
								light.position.fromArray( objJSON.direction );
								break;

							case 'SpotLight':
								light = new THREE.SpotLight( color, intensity, distance, 1 );
								light.angle = objJSON.angle;
								light.position.fromArray( position );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'HemisphereLight':
								light = new THREE.DirectionalLight( color, intensity, distance );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'AreaLight':
								light = new THREE.AreaLight(color, intensity);
								light.position.fromArray( position );
								light.width = objJSON.size;
								light.height = objJSON.size_y;
								break;

						}

						parent.add( light );

						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;

					// cameras

					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

						pos = objJSON.position;
						rot = objJSON.rotation;
						quat = objJSON.quaternion;

						if ( objJSON.type === "PerspectiveCamera" ) {

							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

						} else if ( objJSON.type === "OrthographicCamera" ) {

							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

						}

						camera.name = objID;
						camera.position.fromArray( pos );

						if ( quat !== undefined ) {

							camera.quaternion.fromArray( quat );

						} else if ( rot !== undefined ) {

							camera.rotation.fromArray( rot );

						}

						parent.add( camera );

						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;

					// pure Object3D

					} else {

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;

						object = new THREE.Object3D();
						object.name = objID;
						object.position.fromArray( pos );

						if ( quat ) {

							object.quaternion.fromArray( quat );

						} else {

							object.rotation.fromArray( rot );

						}

						object.scale.fromArray( scl );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

						parent.add( object );

						result.objects[ objID ] = object;
						result.empties[ objID ] = object;

					}

					if ( object ) {

						if ( objJSON.userData !== undefined ) {

							for ( var key in objJSON.userData ) {

								var value = objJSON.userData[ key ];
								object.userData[ key ] = value;

							}

						}

						if ( objJSON.groups !== undefined ) {

							for ( var i = 0; i < objJSON.groups.length; i ++ ) {

								var groupID = objJSON.groups[ i ];

								if ( result.groups[ groupID ] === undefined ) {

									result.groups[ groupID ] = [];

								}

								result.groups[ groupID ].push( objID );

							}

						}

					}

				}

				if ( object !== undefined && objJSON.children !== undefined ) {

					handle_children( object, objJSON.children );

				}

			}

		};

		function handle_mesh( geo, mat, id ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();

		};

		function handle_hierarchy( node, id, parent, material, obj ) {

			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;

			node.position.fromArray( p );

			if ( q ) {

				node.quaternion.fromArray( q );

			} else {

				node.rotation.fromArray( r );

			}

			node.scale.fromArray( s );

			// override children materials
			// if object material was specified in JSON explicitly

			if ( material ) {

				node.traverse( function ( child ) {

					child.material = material;

				} );

			}

			// override children visibility
			// with root node visibility as specified in JSON

			var visible = ( obj.visible !== undefined ) ? obj.visible : true;

			node.traverse( function ( child ) {

				child.visible = visible;

			} );

			parent.add( node );

			node.name = id;

			result.objects[ id ] = node;
			handle_objects();

		};

		function create_callback_geometry( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				handle_mesh( geo, mat, id );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			};

		};

		function create_callback_hierachy( id, parent, material, obj ) {

			return function ( event ) {

				var result;

				// loaders which use EventDispatcher

				if ( event.content ) {

					result = event.content;

				// ColladaLoader

				} else if ( event.dae ) {

					result = event.scene;


				// UTF8Loader

				} else {

					result = event;

				}

				handle_hierarchy( result, id, parent, material, obj );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			};

		};

		function create_callback_embed( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;

			};

		};

		function async_callback_gate() {

			var progress = {

				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures

			};

			scope.callbackProgress( progress, result );

			scope.onLoadProgress();

			if ( counter_models === 0 && counter_textures === 0 ) {

				finalize();
				callbackFinished( result );

			}

		};

		function finalize() {

			// take care of targets which could be asynchronously loaded objects

			for ( var i = 0; i < target_array.length; i ++ ) {

				var ta = target_array[ i ];

				var target = result.objects[ ta.targetName ];

				if ( target ) {

					ta.object.target = target;

				} else {

					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)

					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );

				}

				ta.object.target.userData.targetInverse = ta.object;

			}

		};

		var callbackTexture = function ( count ) {

			counter_textures -= count;
			async_callback_gate();

			scope.onLoadComplete();

		};

		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop

		var generateTextureCallback = function ( count ) {

			return function () {

				callbackTexture( count );

			};

		};

		function traverse_json_hierarchy( objJSON, callback ) {

			callback( objJSON );

			if ( objJSON.children !== undefined ) {

				for ( var objChildID in objJSON.children ) {

					traverse_json_hierarchy( objJSON.children[ objChildID ], callback );

				}

			}

		};

		// first go synchronous elements

		// fogs

		var fogID, fogJSON;

		for ( fogID in data.fogs ) {

			fogJSON = data.fogs[ fogID ];

			if ( fogJSON.type === "linear" ) {

				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

			} else if ( fogJSON.type === "exp2" ) {

				fog = new THREE.FogExp2( 0x000000, fogJSON.density );

			}

			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );

			result.fogs[ fogID ] = fog;

		}

		// now come potentially asynchronous elements

		// geometries

		// count how many geometries will be loaded asynchronously

		var geoID, geoJSON;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type in this.geometryHandlers ) {

				counter_models += 1;

				scope.onLoadStart();

			}

		}

		// count how many hierarchies will be loaded asynchronously

		for ( var objID in data.objects ) {

			traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

					counter_models += 1;

					scope.onLoadStart();

				}

			});

		}

		total_models = counter_models;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type === "cube" ) {

				geometry = new THREE.CubeGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "plane" ) {

				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "sphere" ) {

				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "cylinder" ) {

				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "torus" ) {

				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "icosahedron" ) {

				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type in this.geometryHandlers ) {

				var loaderParameters = {};

				for ( var parType in geoJSON ) {

					if ( parType !== "type" && parType !== "url" ) {

						loaderParameters[ parType ] = geoJSON[ parType ];

					}

				}

				var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

			} else if ( geoJSON.type === "embedded" ) {

				var modelJson = data.embeds[ geoJSON.id ],
					//mca texture_path = ""; //removed because textures won't be loaded with embedded facematerials
					texture_path = urlBase; //mca added

				// pass metadata along to jsonLoader so it knows the format version

				modelJson.metadata = data.metadata;

				if ( modelJson ) {

					var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
					var model = jsonLoader.parse( modelJson, texture_path );
					create_callback_embed( geoID )( model.geometry, model.materials );

				}

			}

		}

		// textures

		// count how many textures will be loaded asynchronously

		var textureID, textureJSON;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.url instanceof Array ) {

				counter_textures += textureJSON.url.length;

				for( var n = 0; n < textureJSON.url.length; n ++ ) {

					scope.onLoadStart();

				}

			} else {

				counter_textures += 1;

				scope.onLoadStart();

			}

		}

		total_textures = counter_textures;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {

				textureJSON.mapping = new THREE[ textureJSON.mapping ]();

			}

			if ( textureJSON.url instanceof Array ) {

				var count = textureJSON.url.length;
				var url_array = [];

				for( var i = 0; i < count; i ++ ) {

					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

				}

				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				} else {

					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				}

			} else {

				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

				} else {

					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

				}

				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];

				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];

				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

				if ( textureJSON.repeat ) {

					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( textureJSON.offset ) {

					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

				}

				// handle wrap after repeat so that default repeat can be overriden

				if ( textureJSON.wrap ) {

					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					};

					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

				}

			}

			result.textures[ textureID ] = texture;

		}

		// materials

		var matID, matJSON;
		var parID;

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			for ( parID in matJSON.parameters ) {

				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

				} else if ( parID === "shading" ) {

					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

				} else if ( parID === "side" ) {

					if ( matJSON.parameters[ parID ] == "double" ) {

						matJSON.parameters[ parID ] = THREE.DoubleSide;

					} else if ( matJSON.parameters[ parID ] == "back" ) {

						matJSON.parameters[ parID ] = THREE.BackSide;

					} else {

						matJSON.parameters[ parID ] = THREE.FrontSide;

					}

				} else if ( parID === "blending" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

				} else if ( parID === "combine" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

				} else if ( parID === "vertexColors" ) {

					if ( matJSON.parameters[ parID ] == "face" ) {

						matJSON.parameters[ parID ] = THREE.FaceColors;

					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

					} else if ( matJSON.parameters[ parID ] ) {

						matJSON.parameters[ parID ] = THREE.VertexColors;

					}

				} else if ( parID === "wrapRGB" ) {

					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

				}

			}

			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

				matJSON.parameters.transparent = true;

			}

			if ( matJSON.parameters.normalMap ) {

				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;

				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

				if ( matJSON.parameters.normalScale ) {

					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

				}

				if ( matJSON.parameters.map ) {

					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;

				}

				if ( matJSON.parameters.envMap ) {

					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "uReflectivity" ].value = matJSON.parameters.reflectivity;

				}

				if ( matJSON.parameters.lightMap ) {

					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;

				}

				if ( matJSON.parameters.specularMap ) {

					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;

				}

				if ( matJSON.parameters.displacementMap ) {

					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;

					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

				}

				uniforms[ "uDiffuseColor" ].value.setHex( diffuse );
				uniforms[ "uSpecularColor" ].value.setHex( specular );
				uniforms[ "uAmbientColor" ].value.setHex( ambient );

				uniforms[ "uShininess" ].value = shininess;

				if ( matJSON.parameters.opacity ) {

					uniforms[ "uOpacity" ].value = matJSON.parameters.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

				material = new THREE.ShaderMaterial( parameters );

			} else {

				material = new THREE[ matJSON.type ]( matJSON.parameters );

			}

			material.name = matID;

			result.materials[ matID ] = material;

		}

		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			if ( matJSON.parameters.materials ) {

				var materialArray = [];

				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );

				}

				result.materials[ matID ].materials = materialArray;

			}

		}

		// objects ( synchronous init of procedural primitives )

		handle_objects();

		// defaults

		if ( result.cameras && data.defaults.camera ) {

			result.currentCamera = result.cameras[ data.defaults.camera ];

		}

		if ( result.fogs && data.defaults.fog ) {

			result.scene.fog = result.fogs[ data.defaults.fog ];

		}

		// synchronous callback

		scope.callbackSync( result );

		// just in case there are no async elements

		async_callback_gate();

	}

};
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;
	
	//added by mca
	this.request = new XMLHttpRequest();
};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		// mca var request = new XMLHttpRequest();
		var request = this.request;
		
		if ( onLoad !== undefined ) {

			request.addEventListener( 'load', function ( event ) {

				onLoad( event.target.responseText );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress /*!== undefined*/ ) { //also don't go in if onProgress is null

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;

		request.open( 'GET', url, true );
		// request.withCredentials = true; //mca
		request.send( null );

		scope.manager.itemStart( url );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BinaryLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

};

THREE.BinaryLoader.prototype = Object.create( THREE.Loader.prototype );

// Load models generated by slim OBJ converter with BINARY option (converter_obj_three_slim.py -t binary)
//  - binary models consist of two files: JS and BIN
//  - parameters
//		- url (required)
//		- callback (required)
//		- texturePath (optional: if not specified, textures will be assumed to be in the same folder as JS model file)
//		- binaryPath (optional: if not specified, binary file will be assumed to be in the same folder as JS model file)

THREE.BinaryLoader.prototype.load = function ( url, callback, texturePath, binaryPath ) {

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath || this.extractUrlBase( url );
	binaryPath = binaryPath || this.extractUrlBase( url );

	var callbackProgress = this.showProgress ? THREE.Loader.prototype.updateProgress : undefined;

	this.onLoadStart();

	// #1 load JS part via web worker

	this.loadAjaxJSON( this, url, callback, texturePath, binaryPath, callbackProgress );

};

THREE.BinaryLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, binaryPath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );
	binaryPath = binaryPath && ( typeof binaryPath === "string" ) ? binaryPath : this.extractUrlBase( url );

	xhr.onreadystatechange = function () {

		if ( xhr.readyState == 4 ) {

			if ( xhr.status == 200 || xhr.status == 0 ) {

				var json = JSON.parse( xhr.responseText );
				context.loadAjaxBuffers( json, callback, binaryPath, texturePath, callbackProgress );

			} else {

				console.error( "THREE.BinaryLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.send( null );

};

THREE.BinaryLoader.prototype.loadAjaxBuffers = function ( json, callback, binaryPath, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest(),
		url = binaryPath + "/" + json.buffers;

	xhr.addEventListener( 'load', function ( event ) {

		var buffer = xhr.response;

		if ( buffer === undefined ) {

			// IEWEBGL needs this
			buffer = ( new Uint8Array( xhr.responseBody ) ).buffer;

		}

		if ( buffer.byteLength == 0 ) {  // iOS and other XMLHttpRequest level 1

			var buffer = new ArrayBuffer( xhr.responseText.length );

			var bufView = new Uint8Array( buffer );

			for ( var i = 0, l = xhr.responseText.length; i < l; i ++ ) {

				bufView[ i ] = xhr.responseText.charCodeAt( i ) & 0xff;

			}

		}

		THREE.BinaryLoader.prototype.createBinModel( buffer, callback, texturePath, json.materials );

	}, false );

	if ( callbackProgress !== undefined ) {

		xhr.addEventListener( 'progress', function ( event ) {

			if ( event.lengthComputable ) {

				callbackProgress( event );

			}

		}, false );

	}

	xhr.addEventListener( 'error', function ( event ) {

		console.error( "THREE.BinaryLoader: Couldn't load [" + url + "] [" + xhr.status + "]" );

	}, false );


	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";
	if ( xhr.overrideMimeType ) xhr.overrideMimeType( "text/plain; charset=x-user-defined" );
	xhr.send( null );

};

// Binary AJAX parser

THREE.BinaryLoader.prototype.createBinModel = function ( data, callback, texturePath, jsonMaterials ) {

	var Model = function ( texturePath ) {

		var scope = this,
			currentOffset = 0,
			md,
			normals = [],
			uvs = [],
			start_tri_flat, start_tri_smooth, start_tri_flat_uv, start_tri_smooth_uv,
			start_quad_flat, start_quad_smooth, start_quad_flat_uv, start_quad_smooth_uv,
			tri_size, quad_size,
			len_tri_flat, len_tri_smooth, len_tri_flat_uv, len_tri_smooth_uv,
			len_quad_flat, len_quad_smooth, len_quad_flat_uv, len_quad_smooth_uv;


		THREE.Geometry.call( this );

		md = parseMetaData( data, currentOffset );

		currentOffset += md.header_bytes;
/*
		md.vertex_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
		md.material_index_bytes = Uint16Array.BYTES_PER_ELEMENT;
		md.normal_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
		md.uv_index_bytes = Uint32Array.BYTES_PER_ELEMENT;
*/
		// buffers sizes

		tri_size =  md.vertex_index_bytes * 3 + md.material_index_bytes;
		quad_size = md.vertex_index_bytes * 4 + md.material_index_bytes;

		len_tri_flat      = md.ntri_flat      * ( tri_size );
		len_tri_smooth    = md.ntri_smooth    * ( tri_size + md.normal_index_bytes * 3 );
		len_tri_flat_uv   = md.ntri_flat_uv   * ( tri_size + md.uv_index_bytes * 3 );
		len_tri_smooth_uv = md.ntri_smooth_uv * ( tri_size + md.normal_index_bytes * 3 + md.uv_index_bytes * 3 );

		len_quad_flat      = md.nquad_flat      * ( quad_size );
		len_quad_smooth    = md.nquad_smooth    * ( quad_size + md.normal_index_bytes * 4 );
		len_quad_flat_uv   = md.nquad_flat_uv   * ( quad_size + md.uv_index_bytes * 4 );
		len_quad_smooth_uv = md.nquad_smooth_uv * ( quad_size + md.normal_index_bytes * 4 + md.uv_index_bytes * 4 );

		// read buffers

		currentOffset += init_vertices( currentOffset );

		currentOffset += init_normals( currentOffset );
		currentOffset += handlePadding( md.nnormals * 3 );

		currentOffset += init_uvs( currentOffset );

		start_tri_flat 		= currentOffset;
		start_tri_smooth    = start_tri_flat    + len_tri_flat    + handlePadding( md.ntri_flat * 2 );
		start_tri_flat_uv   = start_tri_smooth  + len_tri_smooth  + handlePadding( md.ntri_smooth * 2 );
		start_tri_smooth_uv = start_tri_flat_uv + len_tri_flat_uv + handlePadding( md.ntri_flat_uv * 2 );

		start_quad_flat     = start_tri_smooth_uv + len_tri_smooth_uv  + handlePadding( md.ntri_smooth_uv * 2 );
		start_quad_smooth   = start_quad_flat     + len_quad_flat	   + handlePadding( md.nquad_flat * 2 );
		start_quad_flat_uv  = start_quad_smooth   + len_quad_smooth    + handlePadding( md.nquad_smooth * 2 );
		start_quad_smooth_uv= start_quad_flat_uv  + len_quad_flat_uv   + handlePadding( md.nquad_flat_uv * 2 );

		// have to first process faces with uvs
		// so that face and uv indices match

		init_triangles_flat_uv( start_tri_flat_uv );
		init_triangles_smooth_uv( start_tri_smooth_uv );

		init_quads_flat_uv( start_quad_flat_uv );
		init_quads_smooth_uv( start_quad_smooth_uv );

		// now we can process untextured faces

		init_triangles_flat( start_tri_flat );
		init_triangles_smooth( start_tri_smooth );

		init_quads_flat( start_quad_flat );
		init_quads_smooth( start_quad_smooth );

		this.computeCentroids();
		this.computeFaceNormals();

		function handlePadding( n ) {

			return ( n % 4 ) ? ( 4 - n % 4 ) : 0;

		};

		function parseMetaData( data, offset ) {

			var metaData = {

				'signature'               :parseString( data, offset,  12 ),
				'header_bytes'            :parseUChar8( data, offset + 12 ),

				'vertex_coordinate_bytes' :parseUChar8( data, offset + 13 ),
				'normal_coordinate_bytes' :parseUChar8( data, offset + 14 ),
				'uv_coordinate_bytes'     :parseUChar8( data, offset + 15 ),

				'vertex_index_bytes'      :parseUChar8( data, offset + 16 ),
				'normal_index_bytes'      :parseUChar8( data, offset + 17 ),
				'uv_index_bytes'          :parseUChar8( data, offset + 18 ),
				'material_index_bytes'    :parseUChar8( data, offset + 19 ),

				'nvertices'    :parseUInt32( data, offset + 20 ),
				'nnormals'     :parseUInt32( data, offset + 20 + 4*1 ),
				'nuvs'         :parseUInt32( data, offset + 20 + 4*2 ),

				'ntri_flat'      :parseUInt32( data, offset + 20 + 4*3 ),
				'ntri_smooth'    :parseUInt32( data, offset + 20 + 4*4 ),
				'ntri_flat_uv'   :parseUInt32( data, offset + 20 + 4*5 ),
				'ntri_smooth_uv' :parseUInt32( data, offset + 20 + 4*6 ),

				'nquad_flat'      :parseUInt32( data, offset + 20 + 4*7 ),
				'nquad_smooth'    :parseUInt32( data, offset + 20 + 4*8 ),
				'nquad_flat_uv'   :parseUInt32( data, offset + 20 + 4*9 ),
				'nquad_smooth_uv' :parseUInt32( data, offset + 20 + 4*10 )

			};
/*
			console.log( "signature: " + metaData.signature );

			console.log( "header_bytes: " + metaData.header_bytes );
			console.log( "vertex_coordinate_bytes: " + metaData.vertex_coordinate_bytes );
			console.log( "normal_coordinate_bytes: " + metaData.normal_coordinate_bytes );
			console.log( "uv_coordinate_bytes: " + metaData.uv_coordinate_bytes );

			console.log( "vertex_index_bytes: " + metaData.vertex_index_bytes );
			console.log( "normal_index_bytes: " + metaData.normal_index_bytes );
			console.log( "uv_index_bytes: " + metaData.uv_index_bytes );
			console.log( "material_index_bytes: " + metaData.material_index_bytes );

			console.log( "nvertices: " + metaData.nvertices );
			console.log( "nnormals: " + metaData.nnormals );
			console.log( "nuvs: " + metaData.nuvs );

			console.log( "ntri_flat: " + metaData.ntri_flat );
			console.log( "ntri_smooth: " + metaData.ntri_smooth );
			console.log( "ntri_flat_uv: " + metaData.ntri_flat_uv );
			console.log( "ntri_smooth_uv: " + metaData.ntri_smooth_uv );

			console.log( "nquad_flat: " + metaData.nquad_flat );
			console.log( "nquad_smooth: " + metaData.nquad_smooth );
			console.log( "nquad_flat_uv: " + metaData.nquad_flat_uv );
			console.log( "nquad_smooth_uv: " + metaData.nquad_smooth_uv );

			var total = metaData.header_bytes
					  + metaData.nvertices * metaData.vertex_coordinate_bytes * 3
					  + metaData.nnormals * metaData.normal_coordinate_bytes * 3
					  + metaData.nuvs * metaData.uv_coordinate_bytes * 2
					  + metaData.ntri_flat * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes )
					  + metaData.ntri_smooth * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 )
					  + metaData.ntri_flat_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.uv_index_bytes*3 )
					  + metaData.ntri_smooth_uv * ( metaData.vertex_index_bytes*3 + metaData.material_index_bytes + metaData.normal_index_bytes*3 + metaData.uv_index_bytes*3 )
					  + metaData.nquad_flat * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes )
					  + metaData.nquad_smooth * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 )
					  + metaData.nquad_flat_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.uv_index_bytes*4 )
					  + metaData.nquad_smooth_uv * ( metaData.vertex_index_bytes*4 + metaData.material_index_bytes + metaData.normal_index_bytes*4 + metaData.uv_index_bytes*4 );
			console.log( "total bytes: " + total );
*/

			return metaData;

		};

		function parseString( data, offset, length ) {

			var charArray = new Uint8Array( data, offset, length );

			var text = "";

			for ( var i = 0; i < length; i ++ ) {

				text += String.fromCharCode( charArray[ offset + i ] );

			}

			return text;

		};

		function parseUChar8( data, offset ) {

			var charArray = new Uint8Array( data, offset, 1 );

			return charArray[ 0 ];

		};

		function parseUInt32( data, offset ) {

			var intArray = new Uint32Array( data, offset, 1 );

			return intArray[ 0 ];

		};

		function init_vertices( start ) {

			var nElements = md.nvertices;

			var coordArray = new Float32Array( data, start, nElements * 3 );

			var i, x, y, z;

			for( i = 0; i < nElements; i ++ ) {

				x = coordArray[ i * 3 ];
				y = coordArray[ i * 3 + 1 ];
				z = coordArray[ i * 3 + 2 ];

				vertex( scope, x, y, z );

			}

			return nElements * 3 * Float32Array.BYTES_PER_ELEMENT;

		};

		function init_normals( start ) {

			var nElements = md.nnormals;

			if ( nElements ) {

				var normalArray = new Int8Array( data, start, nElements * 3 );

				var i, x, y, z;

				for( i = 0; i < nElements; i ++ ) {

					x = normalArray[ i * 3 ];
					y = normalArray[ i * 3 + 1 ];
					z = normalArray[ i * 3 + 2 ];

					normals.push( x/127, y/127, z/127 );

				}

			}

			return nElements * 3 * Int8Array.BYTES_PER_ELEMENT;

		};

		function init_uvs( start ) {

			var nElements = md.nuvs;

			if ( nElements ) {

				var uvArray = new Float32Array( data, start, nElements * 2 );

				var i, u, v;

				for( i = 0; i < nElements; i ++ ) {

					u = uvArray[ i * 2 ];
					v = uvArray[ i * 2 + 1 ];

					uvs.push( u, v );

				}

			}

			return nElements * 2 * Float32Array.BYTES_PER_ELEMENT;

		};

		function init_uvs3( nElements, offset ) {

			var i, uva, uvb, uvc, u1, u2, u3, v1, v2, v3;

			var uvIndexBuffer = new Uint32Array( data, offset, 3 * nElements );

			for( i = 0; i < nElements; i ++ ) {

				uva = uvIndexBuffer[ i * 3 ];
				uvb = uvIndexBuffer[ i * 3 + 1 ];
				uvc = uvIndexBuffer[ i * 3 + 2 ];

				u1 = uvs[ uva*2 ];
				v1 = uvs[ uva*2 + 1 ];

				u2 = uvs[ uvb*2 ];
				v2 = uvs[ uvb*2 + 1 ];

				u3 = uvs[ uvc*2 ];
				v3 = uvs[ uvc*2 + 1 ];

				uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

			}

		};

		function init_uvs4( nElements, offset ) {

			var i, uva, uvb, uvc, uvd, u1, u2, u3, u4, v1, v2, v3, v4;

			var uvIndexBuffer = new Uint32Array( data, offset, 4 * nElements );

			for( i = 0; i < nElements; i ++ ) {

				uva = uvIndexBuffer[ i * 4 ];
				uvb = uvIndexBuffer[ i * 4 + 1 ];
				uvc = uvIndexBuffer[ i * 4 + 2 ];
				uvd = uvIndexBuffer[ i * 4 + 3 ];

				u1 = uvs[ uva*2 ];
				v1 = uvs[ uva*2 + 1 ];

				u2 = uvs[ uvb*2 ];
				v2 = uvs[ uvb*2 + 1 ];

				u3 = uvs[ uvc*2 ];
				v3 = uvs[ uvc*2 + 1 ];

				u4 = uvs[ uvd*2 ];
				v4 = uvs[ uvd*2 + 1 ];

				uv4( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3, u4, v4 );

			}

		};

		function init_faces3_flat( nElements, offsetVertices, offsetMaterials ) {

			var i, a, b, c, m;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 3 ];
				b = vertexIndexBuffer[ i * 3 + 1 ];
				c = vertexIndexBuffer[ i * 3 + 2 ];

				m = materialIndexBuffer[ i ];

				f3( scope, a, b, c, m );

			}

		};

		function init_faces4_flat( nElements, offsetVertices, offsetMaterials ) {

			var i, a, b, c, d, m;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 4 ];
				b = vertexIndexBuffer[ i * 4 + 1 ];
				c = vertexIndexBuffer[ i * 4 + 2 ];
				d = vertexIndexBuffer[ i * 4 + 3 ];

				m = materialIndexBuffer[ i ];

				f4( scope, a, b, c, d, m );

			}

		};

		function init_faces3_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {

			var i, a, b, c, m;
			var na, nb, nc;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 3 * nElements );
			var normalIndexBuffer = new Uint32Array( data, offsetNormals, 3 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 3 ];
				b = vertexIndexBuffer[ i * 3 + 1 ];
				c = vertexIndexBuffer[ i * 3 + 2 ];

				na = normalIndexBuffer[ i * 3 ];
				nb = normalIndexBuffer[ i * 3 + 1 ];
				nc = normalIndexBuffer[ i * 3 + 2 ];

				m = materialIndexBuffer[ i ];

				f3n( scope, normals, a, b, c, m, na, nb, nc );

			}

		};

		function init_faces4_smooth( nElements, offsetVertices, offsetNormals, offsetMaterials ) {

			var i, a, b, c, d, m;
			var na, nb, nc, nd;

			var vertexIndexBuffer = new Uint32Array( data, offsetVertices, 4 * nElements );
			var normalIndexBuffer = new Uint32Array( data, offsetNormals, 4 * nElements );
			var materialIndexBuffer = new Uint16Array( data, offsetMaterials, nElements );

			for( i = 0; i < nElements; i ++ ) {

				a = vertexIndexBuffer[ i * 4 ];
				b = vertexIndexBuffer[ i * 4 + 1 ];
				c = vertexIndexBuffer[ i * 4 + 2 ];
				d = vertexIndexBuffer[ i * 4 + 3 ];

				na = normalIndexBuffer[ i * 4 ];
				nb = normalIndexBuffer[ i * 4 + 1 ];
				nc = normalIndexBuffer[ i * 4 + 2 ];
				nd = normalIndexBuffer[ i * 4 + 3 ];

				m = materialIndexBuffer[ i ];

				f4n( scope, normals, a, b, c, d, m, na, nb, nc, nd );

			}

		};

		function init_triangles_flat( start ) {

			var nElements = md.ntri_flat;

			if ( nElements ) {

				var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				init_faces3_flat( nElements, start, offsetMaterials );

			}

		};

		function init_triangles_flat_uv( start ) {

			var nElements = md.ntri_flat_uv;

			if ( nElements ) {

				var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_flat( nElements, start, offsetMaterials );
				init_uvs3( nElements, offsetUvs );

			}

		};

		function init_triangles_smooth( start ) {

			var nElements = md.ntri_smooth;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );

			}

		};

		function init_triangles_smooth_uv( start ) {

			var nElements = md.ntri_smooth_uv;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 3;

				init_faces3_smooth( nElements, start, offsetNormals, offsetMaterials );
				init_uvs3( nElements, offsetUvs );

			}

		};

		function init_quads_flat( start ) {

			var nElements = md.nquad_flat;

			if ( nElements ) {

				var offsetMaterials = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				init_faces4_flat( nElements, start, offsetMaterials );

			}

		};

		function init_quads_flat_uv( start ) {

			var nElements = md.nquad_flat_uv;

			if ( nElements ) {

				var offsetUvs = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_flat( nElements, start, offsetMaterials );
				init_uvs4( nElements, offsetUvs );

			}

		};

		function init_quads_smooth( start ) {

			var nElements = md.nquad_smooth;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );

			}

		};

		function init_quads_smooth_uv( start ) {

			var nElements = md.nquad_smooth_uv;

			if ( nElements ) {

				var offsetNormals = start + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetUvs = offsetNormals + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;
				var offsetMaterials = offsetUvs + nElements * Uint32Array.BYTES_PER_ELEMENT * 4;

				init_faces4_smooth( nElements, start, offsetNormals, offsetMaterials );
				init_uvs4( nElements, offsetUvs );

			}

		};

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		scope.faces.push( new THREE.Face3( a, b, c, null, null, mi ) );

	};

	function f4 ( scope, a, b, c, d, mi ) {

		scope.faces.push( new THREE.Face3( a, b, d, null, null, mi ) );
		scope.faces.push( new THREE.Face3( b, c, d, null, null, mi ) );

	};

	function f3n ( scope, normals, a, b, c, mi, na, nb, nc ) {

		var nax = normals[ na*3     ],
			nay = normals[ na*3 + 1 ],
			naz = normals[ na*3 + 2 ],

			nbx = normals[ nb*3     ],
			nby = normals[ nb*3 + 1 ],
			nbz = normals[ nb*3 + 2 ],

			ncx = normals[ nc*3     ],
			ncy = normals[ nc*3 + 1 ],
			ncz = normals[ nc*3 + 2 ];

		scope.faces.push( new THREE.Face3( a, b, c,
						  [new THREE.Vector3( nax, nay, naz ),
						   new THREE.Vector3( nbx, nby, nbz ),
						   new THREE.Vector3( ncx, ncy, ncz )],
						  null,
						  mi ) );

	};

	function f4n ( scope, normals, a, b, c, d, mi, na, nb, nc, nd ) {

		var nax = normals[ na*3     ],
			nay = normals[ na*3 + 1 ],
			naz = normals[ na*3 + 2 ],

			nbx = normals[ nb*3     ],
			nby = normals[ nb*3 + 1 ],
			nbz = normals[ nb*3 + 2 ],

			ncx = normals[ nc*3     ],
			ncy = normals[ nc*3 + 1 ],
			ncz = normals[ nc*3 + 2 ],

			ndx = normals[ nd*3     ],
			ndy = normals[ nd*3 + 1 ],
			ndz = normals[ nd*3 + 2 ];

		scope.faces.push( new THREE.Face3( a, b, d, [
			new THREE.Vector3( nax, nay, naz ),
			new THREE.Vector3( nbx, nby, nbz ),
			new THREE.Vector3( ndx, ndy, ndz )
		], null, mi ) );

		scope.faces.push( new THREE.Face3( b, c, d, [
			new THREE.Vector3( nbx, nby, nbz ),
			new THREE.Vector3( ncx, ncy, ncz ),
			new THREE.Vector3( ndx, ndy, ndz )
		], null, mi ) );

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		where.push( [
			new THREE.Vector2( u1, v1 ),
			new THREE.Vector2( u2, v2 ),
			new THREE.Vector2( u3, v3 )
		] );

	};

	function uv4 ( where, u1, v1, u2, v2, u3, v3, u4, v4 ) {

		where.push( [
			new THREE.Vector2( u1, v1 ),
			new THREE.Vector2( u2, v2 ),
			new THREE.Vector2( u4, v4 )
		] );

		where.push( [
			new THREE.Vector2( u2, v2 ),
			new THREE.Vector2( u3, v3 ),
			new THREE.Vector2( u4, v4 )
		] );

	};

	Model.prototype = Object.create( THREE.Geometry.prototype );

	var geometry = new Model( texturePath );
	var materials = this.initMaterials( jsonMaterials, texturePath );

	if ( this.needsTangents( materials ) ) geometry.computeTangents();

	callback( geometry, materials );

};
/*
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 * changed "hyperfocus" behaviour, added camera target support -- M.C.Auer 04.10.2013
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2;
	this.top = height / 2;
	this.bottom = -height / 2;
	
	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;
	
	this.changedProjectionEvent = {type:'changedProjection'};

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	//only fire on real change, not when only called for param updates
	if(this.inOrthographicMode){
		this.inPerspectiveMode = true;
		this.inOrthographicMode = false;
		this.dispatchEvent(this.changedProjectionEvent);
	}
	
	
	
};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = this.getDistanceToTarget();//(hyperfocus)? hyperfocus :( near + far ) / 2;

	var halfHeight = Math.tan( THREE.Math.degToRad(fov) / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	//only fire on real change, not when only called for param updates
	if(this.inPerspectiveMode){
		this.inPerspectiveMode = false;
		this.inOrthographicMode = true;
		this.dispatchEvent(this.changedProjectionEvent);
	}
	

	
};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2;
	this.top = height / 2;
	this.bottom = -height / 2;
	
};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}
	
};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} 
	else {
	//if ( this.inOrthographicMode ) {
		
		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.getDistanceToTarget = function() {
	var distance = this.position.clone().sub(this.localToWorld(this.target.position.clone())).length();
	return distance;
};


/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

THREE.CopyShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"void main() {",

			"vec4 texel = texture2D( tDiffuse, vUv );",
			"gl_FragColor = opacity * texel;",

		"}"

	].join("\n")

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Dot screen shader
 * based on glfx.js sepia shader
 * https://github.com/evanw/glfx.js
 */

THREE.DotScreenShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"tSize":    { type: "v2", value: new THREE.Vector2( 256, 256 ) },
		"center":   { type: "v2", value: new THREE.Vector2( 0.5, 0.5 ) },
		"angle":    { type: "f", value: 1.57 },
		"scale":    { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform vec2 center;",
		"uniform float angle;",
		"uniform float scale;",
		"uniform vec2 tSize;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		"float pattern() {",

			"float s = sin( angle ), c = cos( angle );",

			"vec2 tex = vUv * tSize - center;",
			"vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;",

			"return ( sin( point.x ) * sin( point.y ) ) * 4.0;",

		"}",

		"void main() {",

			"vec4 color = texture2D( tDiffuse, vUv );",

			"float average = ( color.r + color.g + color.b ) / 3.0;",

			"gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );",

		"}"

	].join("\n")

};
/**
 * @author felixturner / http://airtight.cc/
 *
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */

THREE.RGBShiftShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"amount":   { type: "f", value: 0.005 },
		"angle":    { type: "f", value: 0.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform float amount;",
		"uniform float angle;",

		"varying vec2 vUv;",

		"void main() {",

			"vec2 offset = amount * vec2( cos(angle), sin(angle));",
			"vec4 cr = texture2D(tDiffuse, vUv + offset);",
			"vec4 cga = texture2D(tDiffuse, vUv);",
			"vec4 cb = texture2D(tDiffuse, vUv - offset);",
			"gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);",

		"}"

	].join("\n")

};
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Frei-Chen filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"aspect":    { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"intensity": { type: "f", value: 1.0}, //added by mcauer
		"invert": { type: "f", value: 1.0}, //added by mcauer
		"threshold": { type: "f", value: 0.0} //added by mcauer
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",

		"uniform vec2 aspect;",
		
		"uniform float intensity;",
		"uniform float invert;",
		"uniform float threshold;",

		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",


		"mat3 G[9];",

		// hard coded matrix values!!!! as suggested in https://github.com/neilmendoza/ofxPostProcessing/blob/master/src/EdgePass.cpp#L45

		"const mat3 g0 = mat3( 0.3535533845424652, 0, -0.3535533845424652, 0.5, 0, -0.5, 0.3535533845424652, 0, -0.3535533845424652 );",
		"const mat3 g1 = mat3( 0.3535533845424652, 0.5, 0.3535533845424652, 0, 0, 0, -0.3535533845424652, -0.5, -0.3535533845424652 );",
		"const mat3 g2 = mat3( 0, 0.3535533845424652, -0.5, -0.3535533845424652, 0, 0.3535533845424652, 0.5, -0.3535533845424652, 0 );",
		"const mat3 g3 = mat3( 0.5, -0.3535533845424652, 0, -0.3535533845424652, 0, 0.3535533845424652, 0, 0.3535533845424652, -0.5 );",
		"const mat3 g4 = mat3( 0, -0.5, 0, 0.5, 0, 0.5, 0, -0.5, 0 );",
		"const mat3 g5 = mat3( -0.5, 0, 0.5, 0, 0, 0, 0.5, 0, -0.5 );",
		"const mat3 g6 = mat3( 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.6666666865348816, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204 );",
		"const mat3 g7 = mat3( -0.3333333432674408, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, 0.6666666865348816, 0.1666666716337204, -0.3333333432674408, 0.1666666716337204, -0.3333333432674408 );",
		"const mat3 g8 = mat3( 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408, 0.3333333432674408 );",

		"void main(void)",
		"{",

			"G[0] = g0,",
			"G[1] = g1,",
			"G[2] = g2,",
			"G[3] = g3,",
			"G[4] = g4,",
			"G[5] = g5,",
			"G[6] = g6,",
			"G[7] = g7,",
			"G[8] = g8;",

			"mat3 I;",
			"float cnv[9];",
			"vec3 sample;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++) {",
				"for (float j=0.0; j<3.0; j++) {",
					"sample = texture2D(tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
					"I[int(i)][int(j)] = length(sample);",
				"}",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<9; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3;",
			"}",

			"float M = (cnv[0] + cnv[1]) + (cnv[2] + cnv[3]);",
			"float S = (cnv[4] + cnv[5]) + (cnv[6] + cnv[7]) + (cnv[8] + M);",
			"float rgb = smoothstep(threshold,1.0,sqrt(M/S) * intensity);",
			"if(invert > 0.5){",
				"gl_FragColor = vec4(vec3(1) - vec3(rgb), 1.0);",
			"} else {",
				"gl_FragColor = vec4(vec3(rgb), 1.0);",
			"}",
		"}",

	].join("\n")
};
/**
 * @author zz85 / https://github.com/zz85 | https://www.lab4games.net/zz85/blog
 *
 * Edge Detection Shader using Sobel filter
 * Based on http://rastergrid.com/blog/2011/01/frei-chen-edge-detector
 *
 * aspect: vec2 of (1/width, 1/height)
 */

THREE.EdgeShader2 = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"aspect":    { type: "v2", value: new THREE.Vector2( 512, 512 ) },
	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"varying vec2 vUv;",
		"uniform vec2 aspect;",


		"vec2 texel = vec2(1.0 / aspect.x, 1.0 / aspect.y);",

		"mat3 G[2];",

		"const mat3 g0 = mat3( 1.0, 2.0, 1.0, 0.0, 0.0, 0.0, -1.0, -2.0, -1.0 );",
		"const mat3 g1 = mat3( 1.0, 0.0, -1.0, 2.0, 0.0, -2.0, 1.0, 0.0, -1.0 );",


		"void main(void)",
		"{",
			"mat3 I;",
			"float cnv[2];",
			"vec3 sample;",

			"G[0] = g0;",
			"G[1] = g1;",

			/* fetch the 3x3 neighbourhood and use the RGB vector's length as intensity value */
			"for (float i=0.0; i<3.0; i++)",
			"for (float j=0.0; j<3.0; j++) {",
				"sample = texture2D( tDiffuse, vUv + texel * vec2(i-1.0,j-1.0) ).rgb;",
				"I[int(i)][int(j)] = length(sample);",
			"}",

			/* calculate the convolution values for all the masks */
			"for (int i=0; i<2; i++) {",
				"float dp3 = dot(G[i][0], I[0]) + dot(G[i][1], I[1]) + dot(G[i][2], I[2]);",
				"cnv[i] = dp3 * dp3; ",
			"}",

			"gl_FragColor = vec4(0.5 * sqrt(cnv[0]*cnv[0]+cnv[1]*cnv[1]));",
		"} ",

	].join("\n")

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Screen-space ambient occlusion shader
 * - ported from
 *   SSAO GLSL shader v1.2
 *   assembled by Martins Upitis (martinsh) (http://devlog-martinsh.blogspot.com)
 *   original technique is made by ArKano22 (http://www.gamedev.net/topic/550699-ssao-no-halo-artifacts/)
 * - modifications
 * - modified to use RGBA packed depth texture (use clear color 1,1,1,1 for depth pass)
 * - made fog more compatible with three.js linear fog
 * - refactoring and optimizations
 */

THREE.SSAOShader = {

	uniforms: {

		"tDiffuse":     { type: "t", value: null },
		"tDepth":       { type: "t", value: null },
		"size":         { type: "v2", value: new THREE.Vector2( 512, 512 ) },
		"cameraNear":   { type: "f", value: 1 },
		"cameraFar":    { type: "f", value: 100 },
		"fogNear":      { type: "f", value: 5 },
		"fogFar":       { type: "f", value: 100 },
		"fogEnabled":   { type: "i", value: 0 },
		"onlyAO":       { type: "i", value: 0 },
		"aoClamp":      { type: "f", value: 0.3 },
		"lumInfluence": { type: "f", value: 0.9 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",

			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float cameraNear;",
		"uniform float cameraFar;",

		"uniform float fogNear;",
		"uniform float fogFar;",

		"uniform bool fogEnabled;",  // attenuate AO with linear fog
		"uniform bool onlyAO;",      // use only ambient occlusion pass?

		"uniform vec2 size;",        // texture width, height
		"uniform float aoClamp;",    // depth clamp - reduces haloing at screen edges

		"uniform float lumInfluence;",  // how much luminance affects occlusion

		"uniform sampler2D tDiffuse;",
		"uniform sampler2D tDepth;",

		"varying vec2 vUv;",

		// "#define PI 3.14159265",
		"#define DL 2.399963229728653",  // PI * ( 3.0 - sqrt( 5.0 ) )
		"#define EULER 2.718281828459045",

		// helpers

		"float width = size.x;",   // texture width
		"float height = size.y;",  // texture height

		"float cameraFarPlusNear = cameraFar + cameraNear;",
		"float cameraFarMinusNear = cameraFar - cameraNear;",
		"float cameraCoef = 2.0 * cameraNear;",

		// user variables

		"const int samples = 8;",     // ao sample count
		"const float radius = 5.0;",  // ao radius

		"const bool useNoise = false;",      // use noise instead of pattern for sample dithering
		"const float noiseAmount = 0.0003;", // dithering amount

		"const float diffArea = 0.4;",   // self-shadowing reduction
		"const float gDisplace = 0.4;",  // gauss bell center

		"const vec3 onlyAOColor = vec3( 1.0, 0.7, 0.5 );",
		// "const vec3 onlyAOColor = vec3( 1.0, 1.0, 1.0 );",


		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		// generating noise / pattern texture for dithering

		"vec2 rand( const vec2 coord ) {",

			"vec2 noise;",

			"if ( useNoise ) {",

				"float nx = dot ( coord, vec2( 12.9898, 78.233 ) );",
				"float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );",

				"noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );",

			"} else {",

				"float ff = fract( 1.0 - coord.s * ( width / 2.0 ) );",
				"float gg = fract( coord.t * ( height / 2.0 ) );",

				"noise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;",

			"}",

			"return ( noise * 2.0  - 1.0 ) * noiseAmount;",

		"}",

		"float doFog() {",

			"float zdepth = unpackDepth( texture2D( tDepth, vUv ) );",
			"float depth = -cameraFar * cameraNear / ( zdepth * cameraFarMinusNear - cameraFar );",

			"return smoothstep( fogNear, fogFar, depth );",

		"}",

		"float readDepth( const in vec2 coord ) {",

			// "return ( 2.0 * cameraNear ) / ( cameraFar + cameraNear - unpackDepth( texture2D( tDepth, coord ) ) * ( cameraFar - cameraNear ) );",
			"return cameraCoef / ( cameraFarPlusNear - unpackDepth( texture2D( tDepth, coord ) ) * cameraFarMinusNear );",


		"}",

		"float compareDepths( const in float depth1, const in float depth2, inout int far ) {",

			"float garea = 2.0;",                         // gauss bell width
			"float diff = ( depth1 - depth2 ) * 100.0;",  // depth difference (0-100)

			// reduce left bell width to avoid self-shadowing

			"if ( diff < gDisplace ) {",

				"garea = diffArea;",

			"} else {",

				"far = 1;",

			"}",

			"float dd = diff - gDisplace;",
			"float gauss = pow( EULER, -2.0 * dd * dd / ( garea * garea ) );",
			"return gauss;",

		"}",

		"float calcAO( float depth, float dw, float dh ) {",

			"float dd = radius - depth * radius;",
			"vec2 vv = vec2( dw, dh );",

			"vec2 coord1 = vUv + dd * vv;",
			"vec2 coord2 = vUv - dd * vv;",

			"float temp1 = 0.0;",
			"float temp2 = 0.0;",

			"int far = 0;",
			"temp1 = compareDepths( depth, readDepth( coord1 ), far );",

			// DEPTH EXTRAPOLATION

			"if ( far > 0 ) {",

				"temp2 = compareDepths( readDepth( coord2 ), depth, far );",
				"temp1 += ( 1.0 - temp1 ) * temp2;",

			"}",

			"return temp1;",

		"}",

		"void main() {",

			"vec2 noise = rand( vUv );",
			"float depth = readDepth( vUv );",

			"float tt = clamp( depth, aoClamp, 1.0 );",

			"float w = ( 1.0 / width )  / tt + ( noise.x * ( 1.0 - noise.x ) );",
			"float h = ( 1.0 / height ) / tt + ( noise.y * ( 1.0 - noise.y ) );",

			"float pw;",
			"float ph;",

			"float ao;",

			"float dz = 1.0 / float( samples );",
			"float z = 1.0 - dz / 2.0;",
			"float l = 0.0;",

			"for ( int i = 0; i <= samples; i ++ ) {",

				"float r = sqrt( 1.0 - z );",

				"pw = cos( l ) * r;",
				"ph = sin( l ) * r;",
				"ao += calcAO( depth, pw * w, ph * h );",
				"z = z - dz;",
				"l = l + DL;",

			"}",

			"ao /= float( samples );",
			"ao = 1.0 - ao;",

			"if ( fogEnabled ) {",

				"ao = mix( ao, 1.0, doFog() );",

			"}",

			"vec3 color = texture2D( tDiffuse, vUv ).rgb;",

			"vec3 lumcoeff = vec3( 0.299, 0.587, 0.114 );",
			"float lum = dot( color.rgb, lumcoeff );",
			"vec3 luminance = vec3( lum );",

			"vec3 final = vec3( color * mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // mix( color * ao, white, luminance )

			"if ( onlyAO ) {",

				"final = onlyAOColor * vec3( mix( vec3( ao ), vec3( 1.0 ), luminance * lumInfluence ) );",  // ambient occlusion only

			"}",

			"gl_FragColor = vec4( final, 1.0 );",

		"}"

	].join("\n")

};
/**
 * @author alteredq / http://alteredqualia.com/
 * @author davidedc / http://www.sketchpatch.net/
 *
 * NVIDIA FXAA by Timothy Lottes
 * http://timothylottes.blogspot.com/2011/06/fxaa3-source-released.html
 * - WebGL port by @supereggbert
 * http://www.glge.org/demos/fxaa/
 */

THREE.FXAAShader = {

	uniforms: {

		"tDiffuse":   { type: "t", value: null },
		"resolution": { type: "v2", value: new THREE.Vector2( 1 / 1024, 1 / 512 )  }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform sampler2D tDiffuse;",
		"uniform vec2 resolution;",

		"varying vec2 vUv;",

		"#define FXAA_REDUCE_MIN   (1.0/128.0)",
		"#define FXAA_REDUCE_MUL   (1.0/8.0)",
		"#define FXAA_SPAN_MAX     8.0",

		"void main() {",

			"vec3 rgbNW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbNE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, -1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSW = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( -1.0, 1.0 ) ) * resolution ).xyz;",
			"vec3 rgbSE = texture2D( tDiffuse, ( gl_FragCoord.xy + vec2( 1.0, 1.0 ) ) * resolution ).xyz;",
			"vec4 rgbaM  = texture2D( tDiffuse,  gl_FragCoord.xy  * resolution );",
			"vec3 rgbM  = rgbaM.xyz;",
			"float opacity  = rgbaM.w;",

			"vec3 luma = vec3( 0.299, 0.587, 0.114 );",

			"float lumaNW = dot( rgbNW, luma );",
			"float lumaNE = dot( rgbNE, luma );",
			"float lumaSW = dot( rgbSW, luma );",
			"float lumaSE = dot( rgbSE, luma );",
			"float lumaM  = dot( rgbM,  luma );",
			"float lumaMin = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );",
			"float lumaMax = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );",

			"vec2 dir;",
			"dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",
			"dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",

			"float dirReduce = max( ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * FXAA_REDUCE_MUL ), FXAA_REDUCE_MIN );",

			"float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );",
			"dir = min( vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),",
				  "max( vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),",
						"dir * rcpDirMin)) * resolution;",

			"vec3 rgbA = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz;",
			"rgbA += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz;",
			"rgbA *= 0.5;",

			"vec3 rgbB = texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * -0.5 ).xyz;",
			"rgbB += texture2D( tDiffuse, gl_FragCoord.xy  * resolution + dir * 0.5 ).xyz;",
			"rgbB *= 0.25;",
			"rgbB += rgbA * 0.5;",

			"float lumaB = dot( rgbB, luma );",

			"if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) ) {",

				"gl_FragColor = vec4( rgbA, opacity );",

			"} else {",

				"gl_FragColor = vec4( rgbB, opacity );",

			"}",

		"}"

	].join("\n")

};
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Unpack RGBA depth shader
 * - show RGBA encoded depth as monochrome color
 */

THREE.UnpackDepthRGBAShader = {

	uniforms: {

		"tDiffuse": { type: "t", value: null },
		"opacity":  { type: "f", value: 1.0 }

	},

	vertexShader: [

		"varying vec2 vUv;",

		"void main() {",

			"vUv = uv;",
			"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"uniform float opacity;",

		"uniform sampler2D tDiffuse;",

		"varying vec2 vUv;",

		// RGBA depth

		"float unpackDepth( const in vec4 rgba_depth ) {",

			"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
			"float depth = dot( rgba_depth, bit_shift );",
			"return depth;",

		"}",

		"void main() {",

			"float depth = 1.0 - unpackDepth( texture2D( tDiffuse, vUv ) );",
			"gl_FragColor = opacity * vec4( vec3( depth ), 1.0 );",

		"}"

	].join("\n")

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.EffectComposer = function ( renderer, renderTarget ) {

	this.renderer = renderer;

	if ( renderTarget === undefined ) {

		var width = window.innerWidth || 1;
		var height = window.innerHeight || 1;
		var parameters = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat, stencilBuffer: false };

		renderTarget = new THREE.WebGLRenderTarget( width, height, parameters );

	}

	this.renderTarget1 = renderTarget;
	this.renderTarget2 = renderTarget.clone();

	this.writeBuffer = this.renderTarget1;
	this.readBuffer = this.renderTarget2;

	this.passes = [];

	if ( THREE.CopyShader === undefined )
		console.error( "THREE.EffectComposer relies on THREE.CopyShader" );

	this.copyPass = new THREE.ShaderPass( THREE.CopyShader );

};

THREE.EffectComposer.prototype = {

	swapBuffers: function() {

		var tmp = this.readBuffer;
		this.readBuffer = this.writeBuffer;
		this.writeBuffer = tmp;

	},

	addPass: function ( pass ) {

		this.passes.push( pass );

	},

	insertPass: function ( pass, index ) {

		this.passes.splice( index, 0, pass );

	},

	render: function ( delta ) {

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		var maskActive = false;

		var pass, i, il = this.passes.length;

		for ( i = 0; i < il; i ++ ) {

			pass = this.passes[ i ];

			if ( !pass.enabled ) continue;

			pass.render( this.renderer, this.writeBuffer, this.readBuffer, delta, maskActive );

			if ( pass.needsSwap ) {

				if ( maskActive ) {

					var context = this.renderer.context;

					context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

					this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, delta );

					context.stencilFunc( context.EQUAL, 1, 0xffffffff );

				}

				this.swapBuffers();

			}

			if ( pass instanceof THREE.MaskPass ) {

				maskActive = true;

			} else if ( pass instanceof THREE.ClearMaskPass ) {

				maskActive = false;

			}

		}

	},

	reset: function ( renderTarget ) {

		if ( renderTarget === undefined ) {

			renderTarget = this.renderTarget1.clone();

			renderTarget.width = window.innerWidth;
			renderTarget.height = window.innerHeight;

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

	},

	setSize: function ( width, height ) {

		var renderTarget = this.renderTarget1.clone();

		renderTarget.width = width;
		renderTarget.height = height;

		this.reset( renderTarget );

	}

};

// shared ortho camera

THREE.EffectComposer.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 1 );

THREE.EffectComposer.quad = new THREE.Mesh( new THREE.PlaneGeometry( 2, 2 ), null );

THREE.EffectComposer.scene = new THREE.Scene();
THREE.EffectComposer.scene.add( THREE.EffectComposer.quad );
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

	this.scene = scene;
	this.camera = camera;

	this.overrideMaterial = overrideMaterial;

	this.clearColor = clearColor;
	this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 1;

	this.oldClearColor = new THREE.Color();
	this.oldClearAlpha = 1;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

};

THREE.RenderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		this.scene.overrideMaterial = this.overrideMaterial;

		if ( this.clearColor ) {

			this.oldClearColor.copy( renderer.getClearColor() );
			this.oldClearAlpha = renderer.getClearAlpha();

			renderer.setClearColor( this.clearColor, this.clearAlpha );

		}

		renderer.render( this.scene, this.camera, readBuffer, this.clear );

		if ( this.clearColor ) {

			renderer.setClearColor( this.oldClearColor, this.oldClearAlpha );

		}

		this.scene.overrideMaterial = null;

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MaskPass = function ( scene, camera ) {

	this.scene = scene;
	this.camera = camera;

	this.enabled = true;
	this.clear = true;
	this.needsSwap = false;

	this.inverse = false;

};

THREE.MaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		// don't update color or depth

		context.colorMask( false, false, false, false );
		context.depthMask( false );

		// set up stencil

		var writeValue, clearValue;

		if ( this.inverse ) {

			writeValue = 0;
			clearValue = 1;

		} else {

			writeValue = 1;
			clearValue = 0;

		}

		context.enable( context.STENCIL_TEST );
		context.stencilOp( context.REPLACE, context.REPLACE, context.REPLACE );
		context.stencilFunc( context.ALWAYS, writeValue, 0xffffffff );
		context.clearStencil( clearValue );

		// draw into the stencil buffer

		renderer.render( this.scene, this.camera, readBuffer, this.clear );
		renderer.render( this.scene, this.camera, writeBuffer, this.clear );

		// re-enable update of color and depth

		context.colorMask( true, true, true, true );
		context.depthMask( true );

		// only render where stencil is set to 1

		context.stencilFunc( context.EQUAL, 1, 0xffffffff );  // draw if == 1
		context.stencilOp( context.KEEP, context.KEEP, context.KEEP );

	}

};


THREE.ClearMaskPass = function () {

	this.enabled = true;

};

THREE.ClearMaskPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		var context = renderer.context;

		context.disable( context.STENCIL_TEST );

	}

};
/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShaderPass = function ( shader, textureID ) {

	this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

	this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );

	this.material = new THREE.ShaderMaterial( {

		uniforms: this.uniforms,
		vertexShader: shader.vertexShader,
		fragmentShader: shader.fragmentShader

	} );

	this.renderToScreen = false;

	this.enabled = true;
	this.needsSwap = true;
	this.clear = false;

};

THREE.ShaderPass.prototype = {

	render: function ( renderer, writeBuffer, readBuffer, delta ) {

		if ( this.uniforms[ this.textureID ] ) {

			this.uniforms[ this.textureID ].value = readBuffer;

		}

		THREE.EffectComposer.quad.material = this.material;

		if ( this.renderToScreen ) {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera );

		} else {

			renderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, writeBuffer, this.clear );

		}

	}

};
// tween.js - http://github.com/sole/tween.js
void 0===Date.now&&(Date.now=function(){return(new Date).valueOf()});
var TWEEN=TWEEN||function(){var a=[];return{REVISION:"12",getAll:function(){return a},removeAll:function(){a=[]},add:function(c){a.push(c)},remove:function(c){c=a.indexOf(c);-1!==c&&a.splice(c,1)},update:function(c){if(0===a.length)return!1;for(var b=0,c=void 0!==c?c:"undefined"!==typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();b<a.length;)a[b].update(c)?b++:a.splice(b,1);return!0}}}();
TWEEN.Tween=function(a){var c={},b={},d={},e=1E3,g=0,h=!1,j=!1,q=0,m=null,v=TWEEN.Easing.Linear.None,w=TWEEN.Interpolation.Linear,n=[],r=null,s=!1,t=null,u=null,k;for(k in a)c[k]=parseFloat(a[k],10);this.to=function(a,c){void 0!==c&&(e=c);b=a;return this};this.start=function(e){TWEEN.add(this);j=!0;s=!1;m=void 0!==e?e:"undefined"!==typeof window&&void 0!==window.performance&&void 0!==window.performance.now?window.performance.now():Date.now();m+=q;for(var f in b){if(b[f]instanceof Array){if(0===b[f].length)continue;
b[f]=[a[f]].concat(b[f])}c[f]=a[f];!1===c[f]instanceof Array&&(c[f]*=1);d[f]=c[f]||0}return this};this.stop=function(){if(!j)return this;TWEEN.remove(this);j=!1;this.stopChainedTweens();return this};this.stopChainedTweens=function(){for(var a=0,b=n.length;a<b;a++)n[a].stop()};this.delay=function(a){q=a;return this};this.repeat=function(a){g=a;return this};this.yoyo=function(a){h=a;return this};this.easing=function(a){v=a;return this};this.interpolation=function(a){w=a;return this};this.chain=function(){n=
arguments;return this};this.onStart=function(a){r=a;return this};this.onUpdate=function(a){t=a;return this};this.onComplete=function(a){u=a;return this};this.update=function(p){var f;if(p<m)return!0;!1===s&&(null!==r&&r.call(a),s=!0);var i=(p-m)/e,i=1<i?1:i,j=v(i);for(f in b){var k=c[f]||0,l=b[f];l instanceof Array?a[f]=w(l,j):("string"===typeof l&&(l=k+parseFloat(l,10)),"number"===typeof l&&(a[f]=k+(l-k)*j))}null!==t&&t.call(a,j);if(1==i)if(0<g){isFinite(g)&&g--;for(f in d)"string"===typeof b[f]&&
(d[f]+=parseFloat(b[f],10)),h&&(i=d[f],d[f]=b[f],b[f]=i),c[f]=d[f];m=p+q}else{null!==u&&u.call(a);f=0;for(i=n.length;f<i;f++)n[f].start(p);return!1}return!0}};
TWEEN.Easing={Linear:{None:function(a){return a}},Quadratic:{In:function(a){return a*a},Out:function(a){return a*(2-a)},InOut:function(a){return 1>(a*=2)?0.5*a*a:-0.5*(--a*(a-2)-1)}},Cubic:{In:function(a){return a*a*a},Out:function(a){return--a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a:0.5*((a-=2)*a*a+2)}},Quartic:{In:function(a){return a*a*a*a},Out:function(a){return 1- --a*a*a*a},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a:-0.5*((a-=2)*a*a*a-2)}},Quintic:{In:function(a){return a*a*a*
a*a},Out:function(a){return--a*a*a*a*a+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*a*a*a:0.5*((a-=2)*a*a*a*a+2)}},Sinusoidal:{In:function(a){return 1-Math.cos(a*Math.PI/2)},Out:function(a){return Math.sin(a*Math.PI/2)},InOut:function(a){return 0.5*(1-Math.cos(Math.PI*a))}},Exponential:{In:function(a){return 0===a?0:Math.pow(1024,a-1)},Out:function(a){return 1===a?1:1-Math.pow(2,-10*a)},InOut:function(a){return 0===a?0:1===a?1:1>(a*=2)?0.5*Math.pow(1024,a-1):0.5*(-Math.pow(2,-10*(a-1))+2)}},Circular:{In:function(a){return 1-
Math.sqrt(1-a*a)},Out:function(a){return Math.sqrt(1- --a*a)},InOut:function(a){return 1>(a*=2)?-0.5*(Math.sqrt(1-a*a)-1):0.5*(Math.sqrt(1-(a-=2)*a)+1)}},Elastic:{In:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return-(b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4))},Out:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return b*Math.pow(2,-10*a)*Math.sin((a-c)*
2*Math.PI/0.4)+1},InOut:function(a){var c,b=0.1;if(0===a)return 0;if(1===a)return 1;!b||1>b?(b=1,c=0.1):c=0.4*Math.asin(1/b)/(2*Math.PI);return 1>(a*=2)?-0.5*b*Math.pow(2,10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4):0.5*b*Math.pow(2,-10*(a-=1))*Math.sin((a-c)*2*Math.PI/0.4)+1}},Back:{In:function(a){return a*a*(2.70158*a-1.70158)},Out:function(a){return--a*a*(2.70158*a+1.70158)+1},InOut:function(a){return 1>(a*=2)?0.5*a*a*(3.5949095*a-2.5949095):0.5*((a-=2)*a*(3.5949095*a+2.5949095)+2)}},Bounce:{In:function(a){return 1-
TWEEN.Easing.Bounce.Out(1-a)},Out:function(a){return a<1/2.75?7.5625*a*a:a<2/2.75?7.5625*(a-=1.5/2.75)*a+0.75:a<2.5/2.75?7.5625*(a-=2.25/2.75)*a+0.9375:7.5625*(a-=2.625/2.75)*a+0.984375},InOut:function(a){return 0.5>a?0.5*TWEEN.Easing.Bounce.In(2*a):0.5*TWEEN.Easing.Bounce.Out(2*a-1)+0.5}}};
TWEEN.Interpolation={Linear:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),g=TWEEN.Interpolation.Utils.Linear;return 0>c?g(a[0],a[1],d):1<c?g(a[b],a[b-1],b-d):g(a[e],a[e+1>b?b:e+1],d-e)},Bezier:function(a,c){var b=0,d=a.length-1,e=Math.pow,g=TWEEN.Interpolation.Utils.Bernstein,h;for(h=0;h<=d;h++)b+=e(1-c,d-h)*e(c,h)*a[h]*g(d,h);return b},CatmullRom:function(a,c){var b=a.length-1,d=b*c,e=Math.floor(d),g=TWEEN.Interpolation.Utils.CatmullRom;return a[0]===a[b]?(0>c&&(e=Math.floor(d=b*(1+c))),g(a[(e-
1+b)%b],a[e],a[(e+1)%b],a[(e+2)%b],d-e)):0>c?a[0]-(g(a[0],a[0],a[1],a[1],-d)-a[0]):1<c?a[b]-(g(a[b],a[b],a[b-1],a[b-1],d-b)-a[b]):g(a[e?e-1:0],a[e],a[b<e+1?b:e+1],a[b<e+2?b:e+2],d-e)},Utils:{Linear:function(a,c,b){return(c-a)*b+a},Bernstein:function(a,c){var b=TWEEN.Interpolation.Utils.Factorial;return b(a)/b(c)/b(a-c)},Factorial:function(){var a=[1];return function(c){var b=1,d;if(a[c])return a[c];for(d=c;1<d;d--)b*=d;return a[c]=b}}(),CatmullRom:function(a,c,b,d,e){var a=0.5*(b-a),d=0.5*(d-c),g=
e*e;return(2*c-2*b+a+d)*e*g+(-3*c+3*b-2*a-d)*g+a*e+c}}};
/**
 * GIScene.Coordinate2 represents a 2 dimensional coordinate like in geographic or geodesic coordinate reference systems.

 * @namespace GIscene
 * @class Coordinate2
 * @constructor
 *
 * @param {Object} x east-west direction
 * @param {Object} y south-north direction
 */
GIScene.Coordinate2 = function (x,y){
 
 	THREE.Vector2.apply(this, [x,y]);
      
};

GIScene.Coordinate2.prototype = Object.create(THREE.Vector2.prototype);

/**
 * @method toVector2
 * @return {THREE.Vector2}
 */
GIScene.Coordinate2.prototype.toVector2 = function() {
		return new THREE.Vector2(this.x, -this.y);
	};

/**
 * @method fromVector2
 * @param {THREE.Vector2} v2
 * @return {GIScene.Coordinate2}
 */
GIScene.Coordinate2.prototype.fromVector2 = function(v2){
        this.x =  v2.x;
        this.y = -v2.y; 
        return this;
    };

/**
 * @method clone
 * @return {GIScene.Coordinate2} 
 */
GIScene.Coordinate2.prototype.clone = function() {
	return new GIScene.Coordinate2( this.x, this.y);
};/**
 * GIScene.Coordinate3 represents a 3 dimensional coordinate in a right-handed system with z(height) upwards, like in geographic or geodesic coordinate reference systems.

 * @namespace GIscene
 * @class Coordinate3
 * @constructor
 *
 * @param {Object} x east-west direction
 * @param {Object} y south-north direction
 * @param {Object} z height
 */
GIScene.Coordinate3 = function (x,y,z){
 
 	THREE.Vector3.apply(this,[x,y,z]);
    
};

GIScene.Coordinate3.prototype = Object.create(THREE.Vector3.prototype);

/**
 * @method toVector3
 * @return {THREE.Vector3}
 */
GIScene.Coordinate3.prototype.toVector3 = function() {
		return new THREE.Vector3(this.x, this.z, -this.y);
	};

/**
 * @method fromVector3
 * @param {THREE.Vector3} v3
 * @return {GIScene.Coordinate3}
 */
GIScene.Coordinate3.prototype.fromVector3 = function(v3){
    this.x =  v3.x;
    this.y = -v3.z; 
    this.z =  v3.y;
    return this;
};

/**
 * @method clone
 * @return {GIScene.Coordinate3} 
 */
GIScene.Coordinate3.prototype.clone = function() {
	return new GIScene.Coordinate3( this.x, this.y, this.z );
};/** 
 * Represents a 2D bounding box in geo coordinates (z = height)
 * 
 * @namespace GIScene
 * @class Extent2
 * @constructor
 * @param {GIScene.Coordiante2} minCoordinate2 the lower left corner coordinate
 * @param {GIScene.Coordiante2} maxCoordinate2 the upper right corner coordinate
 */

GIScene.Extent2 = function(minCoordinate2, maxCoordinate2) {
	//inherit methods from THREE.Box2
	THREE.Box2.apply(this,[minCoordinate2, maxCoordinate2]);	
};

GIScene.Extent2.prototype = Object.create(THREE.Box2.prototype);	
/**
 * will be used in Layer.Grid to reduce tile loading to maxExtent 
 * @method toPolygonV2
 * @return {Array of GIScene.Coordinate2} poly
 */
GIScene.Extent2.prototype.toPolygonV2	= function() {
			var min = this.min;
			var max = this.max;
			//var poly = [new GIScene.Coordinate2(min.x,min.y),new GIScene.Coordinate2(min.x,max.y),new GIScene.Coordinate2(max.x,max.y),new GIScene.Coordinate2(max.x,min.y)];
			var poly = [new GIScene.Coordinate2(min.x,min.y),new GIScene.Coordinate2(max.x,min.y),new GIScene.Coordinate2(max.x,max.y),new GIScene.Coordinate2(min.x,max.y)];
			return poly;
};
	
/**
 * Creates a new GIScene.Extent2 object by passing a THREE.Box3
 * @method fromBox3
 * @param {THREE.Box3} box3
 * @return {GIScene.Extent2}
 */	
GIScene.Extent2.prototype.fromBox3 = function(box3) {
	this.min = new GIScene.Coordinate2(box3.min.x, -box3.max.z);
	this.max = new GIScene.Coordinate2(box3.max.x, -box3.min.z);
	return this;
};

/**
 * @method clone
 * @return {GIScene.Extent2} 
 */
GIScene.Extent2.prototype.clone = function() {
	return new GIScene.Extent2( this.min, this.max );
};/** 
 * Represents a mathematical 2D Line
 * 
 * @namespace GIScene
 * @class Line2
 * @constructor
 * @param {THREE.Vector2} positionVector2
 * @param {THREE.Vector2} directionVector2
 * 
 */

GIScene.Line2 = function(positionVector2, directionVector2) {
	this.positionVector = positionVector2; //THREE.Vector2
	this.directionVector = directionVector2;
};



GIScene.Line2.prototype.getNormalizedNormalRight = function() {
	return new THREE.Vector2(-this.directionVector.y, this.directionVector.x).normalize();
};

GIScene.Line2.prototype.getNormalizedNormalLeft = function() {
	return new THREE.Vector2(this.directionVector.y, -this.directionVector.x).normalize();
};

/**
 * Creates a Line2 by specifying two points somewhere on that line 
 * @method fromPoints
 * @param {THREE.Vector2} pointA2
 * @param {THREE.Vector2} pointB2
 * @return {GIScene.Line2}
 */
GIScene.Line2.prototype.fromPoints = function(pointA2, pointB2) {
	
	this.positionVector = pointA2.clone();
	this.directionVector = pointB2.clone().sub(pointA2);
	
	return this;
};

/**
 * Computes the intersection point between this line and a second one 
 * @method intersect
 * @param {Object} line2
 * @return {THREE.Vector2} instersectionPoint
 */
GIScene.Line2.prototype.intersect = function(line2) {
	//@TODO check for parallel
	
	var rv1 = this.directionVector;
	var rv2 = line2.directionVector;
	var ov1 = this.positionVector;
	var ov2 = line2.positionVector;
	
	//first line
	//	r		s		constants
	// rv1.x  -rv2.x  = ov2.x - ov1.x
	//second line
	// rv1.y  -rv2.y  = ov2.y - ov1.y
	
	var r1 = rv1.x;
	var s1 = -rv2.x;
	var c1 = ov2.x - ov1.x;
	var r2 = rv1.y;
	var s2 = -rv2.y;
	var c2 = ov2.y - ov1.y;
	// if first line r=0 exchange lines
	if(r1 == 0 ){
	var r1Temp = r1;
	var s1Temp = s1;
	var c1Temp = c1;
	r1=r2;
	s1=s2;
	c1=c2;
	r2=r1Temp;
	s2=s1Temp;
	c2=c1Temp;
	}
	
	//first line r to 1
	c1 /= r1;
	s1 /= r1;
	r1 = 1;  // r1 /=r1;
	
	// second line r to 0
	var factor = -r2;
	r2 += r1*factor;
	s2 += s1*factor;
	c2 += c1*factor;
	
	//second line s to 1
	factor = 1/s2;
	//r2 += r1*factor;  yet is zero
	//s2 = 1 // *= factor; 
	c2 *= factor;
	
	//first line s to 0
	factor = -s1;
	//r1
	//s1 = 0 // += s2*factor;
	c1 += c2*factor;
	
	var r = c1;
	// var s = c2;
	
	var instersectionPoint = ov1.add(rv1.multiplyScalar(r));
	
	return instersectionPoint;
	
};

GIScene.Line2.prototype.moveLeft = function(distance) {
	 var normal = this.getNormalizedNormalLeft();
	 this.positionVector = this.positionVector.add(normal.multiplyScalar(distance));
	 return this;
};

GIScene.Line2.prototype.moveRight = function(distance) {
	 var normal = this.getNormalizedNormalRight();
	 this.positionVector = this.positionVector.add(normal.multiplyScalar(distance));
	 return this;
};/**
 * Utility Class with convenience functions stored in a central place. 
 *
 * @namespace GIScene
 * @class Utils
 * @static 
 */
GIScene.Utils = {
	
	WorkingMaterial : {
		//set internal working material flag in a bitmask containing info about changed material propeties
		setFlag: function(object, materialPropertyName, propertyValue, FLAGCONSTANT) {
			
			//set or clear the flag
							 
			//if default clear flag: object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
			 if (propertyValue == 'default'){ object.userData.workingMaterialFlags &= ~FLAGCONSTANT; }
			 //else
			 else{
				 //if multi
				 if ("materials" in object.material){
				 	//check isHomogenous
				 	var isHomogenous = null;
				 	for (var i=1; i < object.userData.originalMaterial.materials.length; i++){
				 		if(propertyValue instanceof THREE.Color){
				 			isHomogenous = (object.userData.originalMaterial.materials[0][materialPropertyName].equals(object.userData.originalMaterial.materials[i][materialPropertyName]));
				 		}
				 		else{
				 			isHomogenous = (object.userData.originalMaterial.materials[0][materialPropertyName] == object.userData.originalMaterial.materials[i][materialPropertyName]);
				 		}
				 		
				 		
				 		if(!isHomogenous){break;}
				 	}
				 	//if isHomogenous
				 	if(isHomogenous){
				 		//if newVC != object.userData.originalMaterial.materials[0].vertexColors : set flag |=
				 		if(propertyValue instanceof THREE.Color){
				 			if(!propertyValue.equals(object.userData.originalMaterial.materials[0][materialPropertyName])){ object.userData.workingMaterialFlags |= FLAGCONSTANT; }
					 		//else clear flag &= ~
					 		else{object.userData.workingMaterialFlags &= ~FLAGCONSTANT;}
				 		}
				 		else{
				 			if(propertyValue != object.userData.originalMaterial.materials[0][materialPropertyName]){ object.userData.workingMaterialFlags |= FLAGCONSTANT; }
					 		//else clear flag &= ~
					 		else{object.userData.workingMaterialFlags &= ~FLAGCONSTANT;}
				 		}
				 		
				 		
				 	}
				 	//else (not homogenous)
				 	else{	
				 		//set flag: set flag |=
				 		object.userData.workingMaterialFlags |= FLAGCONSTANT;
				 	}
				 }
				 //else (single)
				 else{
				 	//if newVC != object.userData.originalMaterial.vertexColors : set flag |=
				 	if(propertyValue instanceof THREE.Color){
				 		if(!propertyValue.equals(object.userData.originalMaterial[materialPropertyName])){ object.userData.workingMaterialFlags |= FLAGCONSTANT; }
				 		//else clear flag &= ~
			 			else{object.userData.workingMaterialFlags &= ~FLAGCONSTANT;}
				 	}
				 	else{
				 		if(propertyValue != object.userData.originalMaterial[materialPropertyName]){ object.userData.workingMaterialFlags |= FLAGCONSTANT; }
				 		//else clear flag &= ~
			 			else{object.userData.workingMaterialFlags &= ~FLAGCONSTANT;}
				 	}
				 	
			 		
			 		
				 }
			 }
			
		},
		
		/* find out if original material was changed in a specific way*/
		isSetFlag : function(object, workingMaterialFlagConstant) {
			
			if("workingMaterialFlags" in object.userData){
				return !!(object.userData.workingMaterialFlags & workingMaterialFlagConstant); //Bit operation
			}
			else{
				return false;
			}
			
		},
		
		
		getValues : function(object) {
			
			//collect values
			var values = {};
			
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.SELECT		) ) { values["setSelectColor"]  = object.material.emissive.clone(); };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.WIRE   		) ) { values["setWireframe"]    = object.material.wireframe; };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.SHADING		) ) { values["setShading"]      = object.material.shading; };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.SIDE   		) ) { values["setFaceCulling"]  = object.material.side; };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.MAP    		) ) { values["setTexturing"]    = false; }; //if there is a bit flag it can only be false. Otherwise everything stays as default
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.OPACITY		) ) { values["setOpacity"] 	    = object.material.opacity; };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS	) ) { values["setVertexColors"] = object.material.vertexColors; };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.DIFFUSE		) ) { values["setDiffuseColor"]	= object.material.color.clone(); };
			if( GIScene.Utils.WorkingMaterial.isSetFlag( object, GIScene.WORKINGMATERIALFLAGS.AMBIENT		) ) { values["setAmbientColor"]	= object.material.ambient.clone(); };
						
			
			return values;
			
		},
		
		setValues : function(object, values) { //values object created by getValues
			
			//setValues
			for (value in values){
				GIScene.Utils.WorkingMaterial[value](object, values[value]); 
			}
			
		},
		
		setWireframe : function (object, wireframeMode){ // 'default'|true|false
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;//GIScene.WORKINGMATERIALFLAGS.WIRE;
				}
				
				//no wm --> create and set flag and mode
					
				//else wm exists --> check if new mode == original
				// /*else*/ if (isTrue != object.userData.originalMaterial.wireframe){
				// /*else*/ if (isTrue != object.material.wireframe){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.WIRE;	
				// }
				
				GIScene.Utils.WorkingMaterial.setFlag(object,'wireframe',wireframeMode,GIScene.WORKINGMATERIALFLAGS.WIRE);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(wireframeMode == "default"){
										a[i].wireframe = object.userData.originalMaterial.materials[i].wireframe;
									}
									else {
										a[i].wireframe = wireframeMode;
									}
									
								}
							);
						}
						
						// for single material objects
						else {
							if(wireframeMode == "default"){
										object.material.wireframe = object.userData.originalMaterial.wireframe;
									}
									else {
										object.material.wireframe = wireframeMode;
									}
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
			}
			
		},
		setTexturing : function (object, texturingMode){ // 'default', true, false
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0; //GIScene.WORKINGMATERIALFLAGS.MAP;
				}
				
				//no wm --> create and set flag and mode
					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (isTrue == (!!object.userData.originalMaterial.map) ){ //!! converts object to true and null to false
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.MAP;	
				// }
				
				var propertyValue;
				switch (texturingMode){
					case 'default'	: propertyValue = 'default';
										break;
					case true		: texturingMode = propertyValue = 'default'; //propertyValue = ('materials' in object.material)? object.userData.originalMaterial.materials[0].map : object.userData.originalMaterial.map; 
										break;
					case false		: propertyValue = null;
										break;
					default			: console.log("'setTexturing':  No such texturingMode: "+ texturingMode);
				}
				
				GIScene.Utils.WorkingMaterial.setFlag(object, 'map', propertyValue, GIScene.WORKINGMATERIALFLAGS.MAP);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(texturingMode == 'default'){
										var isTrue = (!!object.userData.originalMaterial.materials[i].map);
									}
									else{
										var isTrue = texturingMode;
									}
									
									var mapValue = (isTrue)? ((!!object.userData.originalMaterial.materials[i].map)? object.userData.originalMaterial.materials[i].map.clone() : null) : null;
									a[i].map = mapValue;
									if(a[i].map != null)a[i].map.needsUpdate = true;
									a[i].needsUpdate = true;
									
								}
							);
						}
						
						// for single material objects
						else {
							if(texturingMode == 'default'){
								var isTrue = (!!object.userData.originalMaterial.map);
							}
							else{
								var isTrue = texturingMode;
							}
							var mapValue = (isTrue)? ((!!object.userData.originalMaterial.map)? object.userData.originalMaterial.map.clone() : null) : null;
							object.material.map = mapValue;
							if(object.material.map != null)object.material.map.needsUpdate = true;
							object.material.needsUpdate = true;
							
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
			}
			
		},
		
		/**
		 * Sets the face culling mode for an object
		 * 
		 * @method setFaceCulling
		 * @param {THREE.FrontSide || THREE.BackSide || THREE.DoubleSide || 'default'} faceCullingMode
		 */
		setFaceCulling : function (object, faceCullingMode){
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;//GIScene.WORKINGMATERIALFLAGS.SIDE;
				}
				
				// //no wm --> create and set flag and mode
// 					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (faceCullingMode == object.userData.originalMaterial.side || faceCullingMode == 'default'){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.SIDE;	
				// }
				
				//set flag
				GIScene.Utils.WorkingMaterial.setFlag(object, 'side', faceCullingMode, GIScene.WORKINGMATERIALFLAGS.SIDE);
				
				//set property
				
				function setFC(material, faceCullingMode){
					material.side = faceCullingMode;
					material.needsUpdate = true;
				}
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(faceCullingMode == 'default'){
										var FCValue = object.userData.originalMaterial.materials[i].side;
										// a[i].side = object.userData.originalMaterial.materials[i].side;
										// a[i].needsUpdate = true;
									}
									else{
										var FCValue = faceCullingMode;
										// a[i].side = faceCullingMode;
										// a[i].needsUpdate = true;
									}
									setFC(a[i],FCValue);
								}
							);
						}
						
						// for single material objects
						else {
							if(faceCullingMode == 'default'){
								var FCValue = object.userData.originalMaterial.side;
								// object.material.side = object.userData.originalMaterial.side;
								// object.material.needsUpdate = true;
							}
							else{
								var FCValue = faceCullingMode;
								// object.material.side = faceCullingMode;
								// object.material.needsUpdate = true;
							}
							setFC(object.material, FCValue);
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}
			
		},
		/**
		 * Sets the vertex color mode for an object
		 * 
		 * @method setVertexColors
		 * @param {THREE.NoColors || THREE.FaceColors || THREE.VertexColors || 'default'} vertexColorMode
		 */
		setVertexColors : function (object, vertexColorMode){
			
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;//GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
				}
				
				//no wm --> create and set flag and mode
					
				//else wm exists --> check if new mode == original
				// /*else*/ if (vertexColorMode == object.userData.originalMaterial.vertexColors || vertexColorMode == 'default'){
					
							 //set or clear the flag
							 GIScene.Utils.WorkingMaterial.setFlag(object,'vertexColors',vertexColorMode,GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS);
							 
							 // //if default clear flag: object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
							 // if (vertexColorMode == 'default'){ object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
							 // //else
							 // else{
								 // //if multi
								 // if ("materials" in object.material){
								 	// //check isHomogenous
								 	// var isHomogenous = null;
								 	// for (var i=1; i < object.userData.originalMaterial.materials.length; i++){
								 		// isHomogenous = (object.userData.originalMaterial.materials[0].vertexColors == object.userData.originalMaterial.materials[i].vertexColors);
								 		// if(!isHomogenous){break;}
								 	// }
								 	// //if isHomogenous
								 	// if(isHomogenous){
								 		// //if newVC != object.userData.originalMaterial.materials[0].vertexColors : set flag |=
								 		// if(vertexColorMode != object.userData.originalMaterial.materials[0].vertexColors){ object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
								 		// //else clear flag &= ~
								 		// else{object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;}
								 	// }
								 	// //else (not homogenous)
								 	// else{	
								 		// //set flag: set flag |=
								 		// object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
								 	// }
								 // }
								 // //else (single)
								 // else{
								 	// //if newVC != object.userData.originalMaterial.vertexColors : set flag |=
								 	// if(vertexColorMode != object.userData.originalMaterial.vertexColors){ object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
							 		// //else clear flag &= ~
							 		// else{object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;}
								 // }
							 // }
							 
							 
							 //check multiIsHomogenous
							 //if multiIsHomogenous == false: setMask : object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
							 //else 
							 //if newVCMode != 
							 
							 // var newVCMode = (vertexColorMode == 'default')? object.userData.originalMaterial.vertexColors : vertexColorMode;
					// /*else*/ if (newVCMode != object.userData.originalMaterial.vertexColors || vertexColorMode == 'default'){
					//remove (toggle) flag
					// console.log("remove workingmaterial vertexColors");
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;	
					// console.log(object.userData.workingMaterialFlags);
				// }
				//set property
				
				//for multimaterial objects
				if("materials" in object.material){
					object.material.materials.forEach(
								function (e,i,a){
									if(vertexColorMode == 'default'){
										a[i].vertexColors = object.userData.originalMaterial.materials[i].vertexColors;
										a[i].color = object.userData.originalMaterial.materials[i].color;
										a[i].ambient = object.userData.originalMaterial.materials[i].ambient;
										a[i].needsUpdate = true;
									}
									else{
										if (object.geometry.faces[0].vertexColors.length > 0) {
											
											a[i].vertexColors = vertexColorMode;
											
											if(vertexColorMode == THREE.NoColors){
												a[i].color = new THREE.Color(0xFFFFFF);
												a[i].ambient = new THREE.Color(0x999999);
											}else
											{
												a[i].color = new THREE.Color(0xFFFFFF);
												a[i].ambient = new THREE.Color(0xFFFFFF);
											}
											
											a[i].needsUpdate = true;
											
										}
									}
								}
					);
				}
				else {
					//for single material models
					if(vertexColorMode == 'default'){
						object.material.vertexColors = object.userData.originalMaterial.vertexColors;
						object.material.color = object.userData.originalMaterial.color;
						object.material.ambient = object.userData.originalMaterial.ambient;
						object.material.needsUpdate = true;
					}
					else{
						if (object.geometry.faces[0].vertexColors.length > 0) {
							
							object.material.vertexColors = vertexColorMode;
							
							if(vertexColorMode == THREE.NoColors){
								object.material.color = new THREE.Color(0xFFFFFF);
								object.material.ambient = new THREE.Color(0x999999);
							}else
							{
								object.material.color = new THREE.Color(0xFFFFFF);
								object.material.ambient = new THREE.Color(0xFFFFFF);
							}
							
							object.material.needsUpdate = true;
							
						}
					}
				}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
			}
			
		},
		setShading : function (object, shadingMode){
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0; //GIScene.WORKINGMATERIALFLAGS.SHADING;
				}
				
				//no wm --> create and set flag and mode
					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (shadingMode == object.userData.originalMaterial.shading || shadingMode == 'default'){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.SHADING;	
				// }
				
				GIScene.Utils.WorkingMaterial.setFlag(object,'shading',shadingMode,GIScene.WORKINGMATERIALFLAGS.SHADING);
				
				//store originalVertexNormals the first time we are changing this property
				if(!("originalVertexNormals" in object.userData) ) {
					// console.log('store originalVertexNormals');
					object.userData.originalVertexNormals = [];
					for (var i=0,l=object.geometry.faces.length; i<l ;i++){
						// object.userData.originalVertexNormals.push(object.geometry.faces[i].vertexNormals);
						if(object.geometry.faces[i].vertexNormals.length != 0){
							object.userData.originalVertexNormals[object.geometry.faces[i].a] = object.geometry.faces[i].vertexNormals[0].clone();
							object.userData.originalVertexNormals[object.geometry.faces[i].b] = object.geometry.faces[i].vertexNormals[1].clone();
							object.userData.originalVertexNormals[object.geometry.faces[i].c] = object.geometry.faces[i].vertexNormals[2].clone();	
						}
					}
				}
				
				//set property
				if(shadingMode == 'default'){
					//restore originalVertexNormals
					for (var i=0,l=object.geometry.faces.length; i<l ;i++){
						if(object.userData.originalVertexNormals[object.geometry.faces[i].a] == undefined){
							object.geometry.faces[i].vertexNormals = [];
						}
						else{
							object.geometry.faces[i].vertexNormals[0] = object.userData.originalVertexNormals[object.geometry.faces[i].a];
							object.geometry.faces[i].vertexNormals[1] = object.userData.originalVertexNormals[object.geometry.faces[i].b];
							object.geometry.faces[i].vertexNormals[2] = object.userData.originalVertexNormals[object.geometry.faces[i].c];	
						}	
					}
					// console.log('deleting originalVertexNormals');
					object.geometry.__tmpVertices = undefined; //has been set by Geometry.computeVertexNormals()
					delete object.userData.originalVertexNormals;
					
						//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									a[i].shading = object.userData.originalMaterial.materials[i].shading;
									object.geometry.normalsNeedUpdate = true;
									a[i].needsUpdate = true;
								}
							);
						}
						
						//for single materials
						else{
							object.material.shading = object.userData.originalMaterial.shading;
							object.geometry.normalsNeedUpdate = true;
							object.material.needsUpdate = true;
						}
				}
				
				// other than 'default'
				else{
					if( object.geometry.faces[0].vertexNormals.length == 0 ){
						object.geometry.computeVertexNormals();
					}
					
					//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									a[i].shading = shadingMode;
									object.geometry.normalsNeedUpdate = true;
									a[i].needsUpdate = true;
								}
							);
						}
						
						//for single materials
						else{
							object.material.shading = shadingMode;
							object.geometry.normalsNeedUpdate = true;
							object.material.needsUpdate = true;
						}
				}
					
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}
			
		},
		
		setDiffuseColor : function(object, diffuseColor) { //{String} 'default' | {THREE.Color}
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;
				}
				
				
				//set flag
				GIScene.Utils.WorkingMaterial.setFlag(object, 'color', diffuseColor, GIScene.WORKINGMATERIALFLAGS.DIFFUSE);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(diffuseColor == 'default'){
										
										a[i].color = object.userData.originalMaterial.materials[i].color;
										
									}
									else{
										
										a[i].color = diffuseColor;
										
									}
									
								}
							);
						}
						
						// for single material objects
						else {
							if(diffuseColor == 'default'){
								
								object.material.color = object.userData.originalMaterial.color;
								
							}
							else{
								
								object.material.color = diffuseColor;
								
							}
							
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}			
			
		},
		
		setAmbientColor : function(object, ambientColor) { //{String} 'default' | {THREE.Color}
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;
				}
				
				
				//set flag
				GIScene.Utils.WorkingMaterial.setFlag(object, 'ambient', ambientColor, GIScene.WORKINGMATERIALFLAGS.AMBIENT);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(ambientColor == 'default'){
										
										a[i].ambient = object.userData.originalMaterial.materials[i].ambient;
										
									}
									else{
										
										a[i].ambient = ambientColor;
										
									}
									
								}
							);
						}
						
						// for single material objects
						else {
							if(ambientColor == 'default'){
								
								object.material.ambient = object.userData.originalMaterial.ambient;
								
							}
							else{
								
								object.material.ambient = ambientColor;
								
							}
							
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}			
			
		},
		
		setSelectColor : function(object, selectColor) { //{String} 'default' | {THREE.Color}
			
			
			if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;
				}
				
				
				//set flag
				GIScene.Utils.WorkingMaterial.setFlag(object, 'emissive', selectColor, GIScene.WORKINGMATERIALFLAGS.SELECT);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									
									//fails silently when emissive is not a property of material
									if("emissive" in a[i]){
									
										if(selectColor == 'default'){
											
											a[i].emissive = object.userData.originalMaterial.materials[i].emissive;
											
										}
										else{
											
											a[i].emissive = selectColor;
											
										}
									}
									
								}
							);
						}
						
						// for single material objects
						else {
							
							//fails silently when emissive is not a property of material
							if("emissive" in object.material){
							
								if(selectColor == 'default'){
									
									object.material.emissive = object.userData.originalMaterial.emissive;
									
								}
								else{
									
									object.material.emissive = selectColor;
									
								}
							}
							
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}			
			
		},		
		
		setOpacity : function(object, opacity) { //{String} 'default' | {Number} 0..1
			
			if (object.material) {
				if(!object.userData.originalMaterial){
					// if no working material exists create one 
					object.userData.originalMaterial = object.material;
					object.material = object.userData.originalMaterial.clone();
					//set flag
					object.userData.workingMaterialFlags = 0;
				}
				
				
				//set flag
				GIScene.Utils.WorkingMaterial.setFlag(object, 'opacity', opacity, GIScene.WORKINGMATERIALFLAGS.OPACITY);
				
				//set property
				
				//for multimaterial objects
						if("materials" in object.material){
							object.material.materials.forEach(
								function (e,i,a){
									if(opacity == 'default'){
										
										a[i].opacity = object.userData.originalMaterial.materials[i].opacity;
										// a[i].transparent = (a[i].opacity < 1 ) ? true : false;
										// a[i].depthTest = (a[i].opacity < 1 ) ? false : true;
										a[i].transparent = object.userData.originalMaterial.materials[i].transparent;
										a[i].depthTest = object.userData.originalMaterial.materials[i].depthTest;
									}
									else{
										
										a[i].opacity = opacity * object.userData.originalMaterial.materials[i].opacity;
										a[i].transparent = (a[i].opacity < 1 ) ? true : false;
										a[i].depthTest = (a[i].opacity < 1 ) ? false : true;
									}
									
								}
							);
						}
						
						// for single material objects
						else {
							//set property
							if(opacity == 'default'){
								object.material.opacity = object.userData.originalMaterial.opacity;
								// object.material.transparent = (object.material.opacity < 1 ) ? true : false;
								// object.material.depthTest = (object.material.opacity < 1 ) ? false : true;
								object.material.transparent = object.userData.originalMaterial.transparent;
								object.material.depthTest = object.userData.originalMaterial.depthTest;
							}
							else{
								object.material.opacity = opacity * object.userData.originalMaterial.opacity;
								object.material.transparent = (object.material.opacity < 1 ) ? true : false;
								object.material.depthTest = (object.material.opacity < 1 ) ? false : true;
							}
						}
				
				//check if wm still in use --> false remove wm and switch to orignal
				if(object.userData.workingMaterialFlags == 0){
						//change back to original material
						object.material = object.userData.originalMaterial;
						object.userData.originalMaterial = null;
						delete object.userData.originalMaterial;
				}
				
			}			
			
		}
		//setColor, setDiffuseColor, setAmbientColor, setEmissiveColor ???
	},
	
	/** 
	 * Merges object properties from a abse object with properties of an extending object.
	 *
	 * @method mergeObjects
	 * @param {Object} base  
	 * @param {Object} extending
	 * @return {Object} merged object with base properties extended/overwritten by extending object.
	 **/	
	mergeObjects : function (base, extending){
		var mergedObject = {};
		
		for (var i in base){
			mergedObject[i] = base[i];
		};
		for (var i in extending){
			mergedObject[i] = extending[i];
		};
		return mergedObject;
	}
	,
	/**
	 * Transforms absolute screencoordinates from DOMEvents to relative screencoordinates inside a DOMElement
	 * 
	 * @method getRelativeScreenCoordsFromDOMEvent
	 * @param {DOMElement} domElement Usually the canvas Element
	 * @param {DOMEvent} event e.g. a mouse event
	 * @return {THREE.Vector2} A Vector which contains the event coordinates transformed into coordinates relative to the upper left corner of the DOMElement
	 */
	getRelativeScreenCoordsFromDOMEvent: function (domElement, event){
		var relativeScreenCoords = new THREE.Vector2();
		var currtopLeft = domElement.getBoundingClientRect();
		relativeScreenCoords.x = event.clientX - currtopLeft.left;
		relativeScreenCoords.y = event.clientY - currtopLeft.top;
		
		return relativeScreenCoords;
	}
	,
	/**
	 * Transforms screencoordinates from DOMEvents
	 * 
	 * @method getViewportCoordsFromDOMEvent
	 * @param {DOMElement} domElement Usually the canvas Element
	 * @param {DOMEvent} event e.g. a mouse event
	 * @return {THREE.Vector2} A Vector which contains the event coordinates transformed into viewport coordinates (x and y are between -1 and 1)
	 */
	getViewportCoordsFromDOMEvent: function (domElement, event){
		//calculate normalized viewport coords x[-1,1] y[-1,1]
		
		var relativeScreenCoords = GIScene.Utils.getRelativeScreenCoordsFromDOMEvent(domElement, event);
		var viewPortCoords = GIScene.Utils.transformRelativeScreenCoordsToViewportCoords(relativeScreenCoords, domElement.offsetWidth, domElement.offsetHeight);
		return viewPortCoords;
	},
	
	/**
	 * Transforms relative screen coordinates (e.g.from a canvas element) to normalized viewport coordinates
	 * 
	 * @method transformRelativeScreenCoordsToViewportCoords
	 * @param {THREE.Vector2} relativeScreenCoords
	 * @param {Number} width
	 * @param {Number} height
	 * @return {THREE.Vector2} A Vector which contains the relative screen coordinates transformed into viewport coordinates (x and y are between -1 and 1)
	 */
	transformRelativeScreenCoordsToViewportCoords: function (relativeScreenCoords, width, height){
		var viewPortCoords = new THREE.Vector2();
		viewPortCoords.x = (relativeScreenCoords.x / width ) * 2 - 1;
		viewPortCoords.y = -(relativeScreenCoords.y / height ) * 2 + 1;
		
		return viewPortCoords;
	},
	
	/**
	 * Transforms viewport coordinates to relative screen coordinates (e.g.from a canvas element) 
	 * 
	 * @method transformViewportCoordsToRelativeScreenCoords
	 * @param {THREE.Vector2} viewPortCoords
	 * @param {Number} width
	 * @param {Number} height
	 * @return {THREE.Vector2} A Vector which contains the viewport coordinates transformed into relative screen coordinates (x and y are between width and height)
	 */
	transformViewportCoordsToRelativeScreenCoords: function (viewPortCoords, width, height){
		var relativeScreenCoords = new THREE.Vector2();
		relativeScreenCoords.x = ((viewPortCoords.x + 1)/2)*width;
		relativeScreenCoords.y = ((viewPortCoords.y - 1)/-2)*height;
		
		return relativeScreenCoords;
	},
	
	/**
	 * Recursively computes the bounding box of a scenegraph
	 * 
	 * @method computeBoundingBoxRecursive
	 * @param {THREE.Object3D} node
	 * @return {THREE.Box3} The united bounding box of the node and all its descendants
	 */
	computeBoundingBoxRecursive: function (node){
		
		console.log("Deprecated: GIScene.Utils.computeBoundingBoxRecursive(). Use THREE.Box3().setFromObject(obj)");
		return new THREE.Box3().setFromObject(node);
		
		// var nodeBBOX;
		// if(node.geometry){
			// node.geometry.computeBoundingBox();
			// nodeBBOX = node.geometry.boundingBox.clone().translate(node.position);
		// } 
		// else{
			// nodeBBOX = new THREE.Box3();
		// }		
		// var descendants = node.getDescendants();
// 		
		// for (var i=0;i<descendants.length;i++){
			// if(descendants[i].geometry){
				// descendants[i].geometry.computeBoundingBox();
				// nodeBBOX.union(descendants[i].geometry.boundingBox.clone().translate(descendants[i].position));
			// }
		// }
// 		
		// return nodeBBOX;
		
	},
	
	/**
	 * @method computeVertexMeanRecursive 
	 * @param {THREE.Object3D} node node from which mean will be computed recursively including itself
	 * @return {THREE.Vector3} the point which represents the computed mean
	 * @TODO does NOT take care of MatrixRotations, e.g. if verticalAxis=Z
 	 */
	computeVertexMeanRecursive: function(node) {
			
		var allVertices = [];
		
		node.traverse(function(el) {
			if ("geometry" in el){ 
			allVertices.push.apply( allVertices, el.geometry.vertices);
			}
		});
		
		//alert(allVertices.length);
		
		var sum = new THREE.Vector3();
		for(var i = 0; i < allVertices.length; i++){
		    sum = sum.add(allVertices[0]);
		}

		var mean = sum.divideScalar(allVertices.length);
		
		
		return mean;
	},
	
	/**
	 * Performs a rotation of a point around a center
	 * 
	 * @method polarTransformationAddAngle
	 * @param {THREE.Vector3} center center of rotation
	 * @param {THREE.Vector3} point point to rotate around center
	 * @param {Number} deltaTheta horizontal angle in degrees to be rotated
	 * @param {Number} deltaPhi vertical angle in degrees to be rotated
	 * @return {THREE.Vector3} rotatedPoint
	 */
	polarTransformationAddAngle : function (center, point, deltaTheta, deltaPhi){
		var deltaTheta = THREE.Math.degToRad(deltaTheta);
		var deltaPhi = THREE.Math.degToRad(deltaPhi);
		var offset = point.clone().sub(center);
		// angle from z-axis around y-axis
		var theta = Math.atan2( offset.x, offset.z );
		// angle from y-axis
		var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
		//add deltas
		theta += deltaTheta;
		phi += deltaPhi;
		//transformation
		var radius = offset.length();
		offset.x = radius * Math.sin( phi ) * Math.sin( theta );
		offset.y = radius * Math.cos( phi );
		offset.z = radius * Math.sin( phi ) * Math.cos( theta );
		
		point.copy( center ).add( offset );
		return point;
	},
	
	/**
	 * sets the position property of an object to its boundingBoxCenter
	 * and changes vertex coordinates accordingly
	 * 
	 * @method translatePositionToBBoxCenter
	 * @param {THREE.Object3D} object
	 */
	translatePositionToBBoxCenter : function(object) {
		if(object.geometry && object.geometry.boundingBox){
			
			var translationVector = object.geometry.boundingBox.center().sub(object.position);
			object.position.add(translationVector);
			object.geometry.vertices.forEach(function(vertex) {vertex.sub(translationVector);});
			object.geometry.verticesNeedUpdate = true;
		}
	},
	
	/**
 	 * function to sort objects by object.renderDepth property.
 	 * Calculates distance from camera to object.position and subtracts the boundingSphere.radius.
 	 * Helps to obtain a better sorting of small objects inside bigger ones.
 	 * 
 	 * @method calcRenderDepthMinusBSphereRadius
 	 * @param {THREE.Object3D} object
 	 * @param {THREE.Camera} camera
 	 * @return {Number} distance
 	 */
 	calcRenderDepthMinusBSphereRadius : function(object, camera) {
 		var _vector3 = new THREE.Vector3();
 		var _projScreenMatrix = new THREE.Matrix4();
 		
 		_vector3.getPositionFromMatrix( object.matrixWorld );
 		
 		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
 		
		_vector3.applyProjection( _projScreenMatrix );

		return _vector3.z - object.geometry.boundingSphere.radius;
 	},

	/**
	 * function to calculate parameter for orthographic cameras based on params from a perspective camera and a distance at which the visible size of an object should be maintained
	 * 
	 * @method getOrthoParamsFromPerspectiveCam
	 * @param {HTMLCanvasElement} canvas
	 * @param {THREE.PerspectiveCamera} perspectiveCam 
	 * @param {Number} focusDistance
	 * @return {Object} parameters for THREE.OrthographicCamera
	 */
	getOrthoParamsFromPerspectiveCam : function(canvas, perspectiveCam, focusDistance) {
		

		var fov = perspectiveCam.fov;
		var focusDistance = (focusDistance)? focusDistance :( perspectiveCam.near + perspectiveCam.far ) / 2;
		var aspect = perspectiveCam.aspect; //canvas.width / canvas.height;
		
		var orthoparams = this.getOrthoSizeFromFovDistanceAspect(fov, focusDistance, aspect);
		
		orthoparams.near 	= perspectiveCam.near;
		orthoparams.far		= perspectiveCam.far;
		
		return orthoparams;
	},
	
	/**
	 * function to calculate the size parameters for an orthographic camera
	 * 
	 * @method getOrthoSizeFromFovDistanceAspect
	 * @param {Number} fov in degrees
	 * @param {Number} distance at which size is to be computed according to fov
	 * @param {Number} aspect ratio of canvas with / height
	 * @return {Object} orthosize Object which contains (top, bottom, left, right)-values for orthographic Cameras
	 */
	getOrthoSizeFromFovDistanceAspect : function (fov, distance, aspect){
		var orthosize = {};
		
		var halfHeight = Math.tan( THREE.Math.degToRad(fov) / 2 ) * distance;
		var planeHeight = 2 * halfHeight;
		var planeWidth = planeHeight * aspect;
		var halfWidth = planeWidth / 2;
		
		orthosize.left	= -halfWidth;
		orthosize.right	=  halfWidth;
		orthosize.top		=  halfHeight;
		orthosize.bottom	= -halfHeight;
		
		return orthosize;
	},
	
	/**
	 * function to calculate the distance a perspective camera needs from a target to maintain the visual size of objects
	 * 
	 * @method getPerspectiveDistanceFromFovHalfHeight
	 * @param {Number} fov field of view in degrees
	 * @param {Number} halfHeight half of the orthographic camera height or height at distance to be visible in camera in scene units
	 * @return {Number} distance a perspective camera with the given field of view (fov) should be placed from a target to completly see the given (half-)height
	 */
	getPerspectiveDistanceFromFovHalfHeight : function(fov, halfHeight) {
		
		var distance = halfHeight / Math.tan(THREE.Math.degToRad(fov) / 2);
		
		return distance;
	},
	
	/**
	 * check for item in array 
	 * 
	 * @method arrayContains
	 * @param {Array} array
	 * @param {item} item item to check for in array
	 */
	
	arrayContains : function(array, item) {
		for (var i = 0, j = array.length; i < j; i++) {
			if (array[i] === item)
				return true;
		}
	},
	
	/**
	 * Removes duplicates from an array, even different objects with equal properties
	 * 
	 * @method removeDuplicatesFromArray
	 * @param {Array} array
	 * @return {Array} filteredArray new filtered array
	 */
	removeDuplicatesFromArray : function(array) {
	    var seen = {};
	    return array.filter(function(elem) {
	        var k = JSON.stringify(elem);
	        return (seen[k] === 1) ? 0 : seen[k] = 1;
	    });
	},
	
	/**
	 * Flatten 3D Vectors horizontally to 2D
	 * Removes y from vector3 and puts z as y of vector2.
	 *
	 * @method vector3ToVector2
	 * @param {THREE.Vector3} v3  
	 * @return {THREE.Vector2}
	 */
	vector3ToVector2 : function(v3) {
		var v2 = new THREE.Vector2(v3.x, v3.z);
		return v2;
	},
	
	
	/**
	 * Transform a Vector2 to Vector3 by adding a y component
	 * @method vector2ToVector3
	 * @param {THREE.Vector2} v2 represents horizontal points
	 * @param {Number} y height to add to horizontal point
	 * @return {THREE.Vector3}
	 */
	vector2ToVector3 : function(v2, y) {
		var v3 = new THREE.Vector3(v2.x, y , v2.y);
		return v3;
	},
	
	/**
	 * Delete an object properly 
	 * @method disposeObject
	 * @param {THREE.Object3D} object the object to be disposed
	 * @param {Boolean} deleteGeometry should the geometry of the object be disposed 
	 * @param {Boolean} deleteMaterial should the material of the object be disposed also? Set to false if material is shared by other objects
	 * @param {Boolean} deleteTextures should the textures of the object be disposed also? Set to false if textures are shared by other objects
	 * @param {Boolean} recursive should all descendants of the object be disposed by the same criteria aswell?
	 */
	disposeObject : function(object, deleteGeometry, deleteMaterial, deleteTextures, recursive) {
		var materials = [], textures = [];
		
		if(recursive){
			var objects = object.getDescendants();
			objects.push(object);
			objects.forEach(function(object,i,a){
				GIScene.Utils.disposeObject(object, deleteGeometry, deleteMaterial, deleteTextures, false);
			}.bind(this));
		}
		
		if(deleteGeometry){
			if(object.geometry){
				object.geometry.dispose();
				delete object.geometry;
			}
		}
		
		
		if(deleteMaterial){	
			//get materials
			if (object.material) {
				if (object.material instanceof THREE.MeshFaceMaterial) {
					object.material.materials.forEach(function(material) {
						if (! GIScene.Utils.arrayContains(materials, material)) {
							materials.push(material);
						};
					});
				} else {
	
					if (! GIScene.Utils.arrayContains(materials, object.material)) {
						materials.push(object.material);
					};
				}
			}
			delete object.material;
			
			
			if(deleteTextures){
				// get textures
				materials.forEach(function(material) {
					var maps = ["map", "lightMap", "bumpMap", "normalMap", "specularMap", "envMap"];
					for (var i = 0, j = maps.length; i < j; i++) {
						if ( material[maps[i]] && material[maps[i]] != null && ! GIScene.Utils.arrayContains(textures, material[maps[i]])) {
							textures.push(material[maps[i]]);
							material[maps[i]] = null;
						};
					};
				}); 
			}
		}
		
		//dispose objects
		if(deleteGeometry){
			if(object.dispose)object.dispose();
			object = null;
		}
		
		//dispose textures, materials
		textures.forEach(function (texture) {
		  texture.dispose();
		});
		textures = null;
		
		materials.forEach(function (material) {
		  material.dispose();
		});
		materials = null;
	},
	
	/**
	 *isTypeOrClass 
	 * @method isTypeOrClass
	 * @param {String} typeOrClassName
	 */
	equalsTypeOrClass : function(valueOrObject, typeOrClassName) {
		
		var check;
		
		if ( typeof valueOrObject == "object") {
			console.log("object");
			try {
				check = valueOrObject instanceof  eval(typeOrClassName);
			} catch(e) {
				//primitive strings will fail
				check = (typeOrClassName.toLowerCase() == "object")? true : false;
			}
		} else {
			console.log("primitive");
			var check = typeof valueOrObject === typeOrClassName.toLowerCase();
		}

		return check;

		},
		
	/**
	 *get Objects by recursively calling a callback function which should return true or false to all children
	 * 
	 * @method getObjectsBy
	 * @param {THREE.Object3D} rootObject
	 * @param {Function} callback
	 */
	getObjectsBy: function(rootObject,callback) {
		var matches=[];
		var evalfunction = function(object) {
			if(callback(object)){
				matches.push(object);
			}
		};
		rootObject.traverse(evalfunction);
		
		return matches;
	}

}
;


	/**
 * Visualizes a specified direction by color coding faces which are perpendicular to that direction within a specified deviation.
 * 
 * @namespace GIScene
 * @class DirectionMaterial
 * @constructor
 * @param {THREE.Vector3} direction
 * @param {Number} maxDeviationDeg A Number specifying the maximum deviation from direction to which the colorramp is streched 
 */

GIScene.DirectionMaterial = function(direction, maxDeviationDeg) {
	
	var direction = direction || new THREE.Vector3(0,0,-1); //default to North
	var maxDeviationDeg = maxDeviationDeg || 15.0;
	
	var parameters = {
		shading : THREE.SmoothShading,
		uniforms : {

			"opacity" : 		{type : "f",  value : 1.0},
			"direction": 		{type : "v3", value : direction},
			"maxDeviationDeg" : {type : "f",  value : maxDeviationDeg},
			//compassDirectionDeg degrees
			//maxDeviationDeg degrees

		},

		vertexShader : [
			"varying vec3 vNormal;", 
			
			THREE.ShaderChunk["morphtarget_pars_vertex"], 
			
			"void main() {", 
				"vNormal = normalize(  normal );", 
				
				THREE.ShaderChunk["morphtarget_vertex"], 
				THREE.ShaderChunk["default_vertex"], 
			"}"
			].join("\n"),

		fragmentShader : [
			"uniform float opacity;", 
			"uniform vec3 direction;", 
			"uniform float maxDeviationDeg;", 
			
			"varying vec3 vNormal;", 
			"float red;", 
			"float maxDeviation;", 
			"const float M_PI = 3.14159265358979323846;", 
			// "vec3 hDir;", 
			"uniform mat4 modelMatrix;", 
			
			"void main() {", 
				"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * vNormal;", 
				"worldNormal = normalize( worldNormal );", 
				"maxDeviation = maxDeviationDeg * (M_PI / 180.0);",
	
				// 3D Direction
				"red = (maxDeviation - acos(dot(worldNormal, direction))) / maxDeviation;",
	
				//2D Direction (Aspect)
				//project face normal on horizontal plane
				// "hDir = worldNormal -  ( dot(worldNormal, vec3(0.0,1.0,0.0)) * vec3(0.0,1.0,0.0));",
				// "red = (maxDeviation - acos(dot(normalize(hDir), vec3(0.0,0.0,-1.0)))) / maxDeviation;",
		
				"gl_FragColor = vec4( 1.0,1.0-red,1.0-red, opacity );",
			
			"}"
			].join("\n")
	}; 	
	
	THREE.ShaderMaterial.call(this, parameters);

};

GIScene.DirectionMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );/**
 * Visualizes a specified compass direction (aspect) by color coding faces which are perpendicular to that direction within a specified deviation.
 * This is similar to the DirectionMaterial but only considers the horizontal angle of the face normals and not the vertical angle.
 * 
 * @namespace GIScene
 * @class AspectMaterial
 * @constructor
 * @param {THREE.Vector3} compassDirection
 * @param {Number} maxDeviationDeg A Number specifying the maximum deviation from compassDirection to which the colorramp is streched 
 */

GIScene.AspectMaterial = function(compassDirection, maxDeviationDeg) {
	
	var _compassDirection, 
		_maxDeviationDeg,
		_emissive = new THREE.Color( 0x000000 );
	
	Object.defineProperty(this, 'compassDirection', {
	    get: function() {
	      return _compassDirection;
	    },
	    set: function(value) {
	      _compassDirection = value;
	      this.uniforms.compassDirection.value = value;
	    }
	  });
	  
	  Object.defineProperty(this, 'maxDeviationDeg', {
	    get: function() {
	      return _maxDeviationDeg;
	    },
	    set: function(value) {
	      _maxDeviationDeg = value;
	      this.uniforms.maxDeviationDeg.value = value;
	    }
	  });
	  
	  Object.defineProperty(this, 'emissive', {
	    get: function() {
	      return _emissive;
	    },
	    set: function(value) {
	      _emissive = value;
	      this.uniforms.uemissive.value = value;
	    }
	  });
	
	
	var parameters = {
		shading : THREE.SmoothShading,
		uniforms : {

			"opacity" : 		{type : "f",  value : 1.0},
			"compassDirection": {type : "v3", value : compassDirection},
			"maxDeviationDeg" : {type : "f",  value : maxDeviationDeg},
			"uemissive" : 		{type : "c",  value : this.emissive}
			//compassDirectionDeg degrees
			//maxDeviationDeg degrees

		},

		vertexShader : [
			"varying vec3 vNormal;", 
			"uniform vec3 uemissive;",
			
			THREE.ShaderChunk["morphtarget_pars_vertex"], 
			
			"void main() {", 
				"vNormal = normalize(  normal );", 
				
				THREE.ShaderChunk["morphtarget_vertex"], 
				THREE.ShaderChunk["default_vertex"], 
			"}"
			].join("\n"),

		fragmentShader : [
			"uniform float opacity;", 
			"uniform vec3 compassDirection;", 
			"uniform float maxDeviationDeg;", 
			"uniform vec3 uemissive;",
			
			"varying vec3 vNormal;", 
			"float red;", 
			"float maxDeviation;", 
			"const float M_PI = 3.14159265358979323846;", 
			"vec3 hDir;", 
			"uniform mat4 modelMatrix;", 
			
			"void main() {", 
				"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * vNormal;", 
				"worldNormal = normalize( worldNormal );", 
				"maxDeviation = maxDeviationDeg * (M_PI / 180.0);",
	
				// 3D Direction
				//"red = (maxDeviation - acos(dot(worldNormal, compassDirection))) / maxDeviation;",
	
				//2D Direction (Aspect)
				
				//grey for flat regions
				
				

					//project face normal on horizontal plane
					"hDir = worldNormal -  ( dot(worldNormal, vec3(0.0,1.0,0.0)) * vec3(0.0,1.0,0.0));",
					
					"hDir = normalize(hDir);",
					
					//exclude flat and almost flat areas from beeing colorized
					"float upDeviation = acos(dot(normalize(worldNormal), vec3(0.0,1.0,0.0)));", //deviation from up vector
					
					"if (upDeviation < 0.017453292519943295 || upDeviation > M_PI - 0.017453292519943295)", //0.017453292519943295 is 1 deg is maxUpDeviation 
					"{",
						"gl_FragColor = vec4( vec3(0.5) + uemissive, opacity );",
					"}",
				
					
					"else {",
					
						"red = (maxDeviation - acos(dot(hDir, compassDirection))) / maxDeviation;",
			
						"gl_FragColor = vec4( vec3(1.0,1.0-red,1.0-red) + uemissive, opacity );",
				
					"}",
				
			"}"
			].join("\n")
	}; 	
	
	THREE.ShaderMaterial.call(this, parameters);
	
    //standards
	this.compassDirection = compassDirection || new THREE.Vector3(0,0,-1); //default to North
	this.maxDeviationDeg = maxDeviationDeg || 15.0;
	this.emissive = new THREE.Color( 0x000000 );
};

GIScene.AspectMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

GIScene.AspectMaterial.prototype.clone = function() {
	
	var material = new GIScene.AspectMaterial();
	
	THREE.ShaderMaterial.prototype.clone.call( this, material );
	
	material.compassDirection = this.compassDirection;
	
	material.emissive = this.emissive;
	
	return material;
};
/**
 * A Material which sets opacity according to the distance to the camera. 
 * Close parts will be transparent, so you could watch inside a building, while the walls in the back are still opaque.
 * 
 * @namespace GIScene
 * @class DistanceOpacityMaterial
 * @constructor
 * @param {Number} near distance from where opacity begins
 * @param {Number} far  distance from where opacity will be 1.0
 *  
 */

GIScene.DistanceOpacityMaterial = function(near,far) {
	var near = near || 15.0;
	var far  = far  || 30.0;
	
	var parameters = {
				transparent:true,
				lights: true,
				side:2,
				uniforms: THREE.UniformsUtils.merge( [
		
					THREE.UniformsLib[ "common" ],
					THREE.UniformsLib[ "fog" ],
					THREE.UniformsLib[ "lights" ],
					THREE.UniformsLib[ "shadowmap" ],
		
					{
						"ambient"  : { type: "c", value: new THREE.Color( 0xaaaaaa ) },
						"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
						"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) },
					
						"mNear": { type: "f", value: near },
						"mFar" : { type: "f", value: far }
					}
		
				] ),
		
				vertexShader: [
		
					"#define LAMBERT",
		
					"varying vec3 vLightFront;",
		
					"#ifdef DOUBLE_SIDED",
		
						"varying vec3 vLightBack;",
		
					"#endif",
		
					THREE.ShaderChunk[ "map_pars_vertex" ],
					THREE.ShaderChunk[ "lightmap_pars_vertex" ],
					THREE.ShaderChunk[ "envmap_pars_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
					THREE.ShaderChunk[ "color_pars_vertex" ],
					THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
					THREE.ShaderChunk[ "skinning_pars_vertex" ],
					THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
		
					"void main() {",
		
						THREE.ShaderChunk[ "map_vertex" ],
						THREE.ShaderChunk[ "lightmap_vertex" ],
						THREE.ShaderChunk[ "color_vertex" ],
		
						THREE.ShaderChunk[ "morphnormal_vertex" ],
						THREE.ShaderChunk[ "skinbase_vertex" ],
						THREE.ShaderChunk[ "skinnormal_vertex" ],
						THREE.ShaderChunk[ "defaultnormal_vertex" ],
		
						THREE.ShaderChunk[ "morphtarget_vertex" ],
						THREE.ShaderChunk[ "skinning_vertex" ],
						THREE.ShaderChunk[ "default_vertex" ],
		
						THREE.ShaderChunk[ "worldpos_vertex" ],
						THREE.ShaderChunk[ "envmap_vertex" ],
						THREE.ShaderChunk[ "lights_lambert_vertex" ],
						THREE.ShaderChunk[ "shadowmap_vertex" ],
		
					"}"
		
				].join("\n"),
		
				fragmentShader: [
					//mca
					"uniform float mNear;",
					"uniform float mFar;",
					
					
					"uniform float opacity;",
		
					"varying vec3 vLightFront;",
		
					"#ifdef DOUBLE_SIDED",
		
						"varying vec3 vLightBack;",
		
					"#endif",
		
					THREE.ShaderChunk[ "color_pars_fragment" ],
					THREE.ShaderChunk[ "map_pars_fragment" ],
					THREE.ShaderChunk[ "lightmap_pars_fragment" ],
					THREE.ShaderChunk[ "envmap_pars_fragment" ],
					THREE.ShaderChunk[ "fog_pars_fragment" ],
					THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
					THREE.ShaderChunk[ "specularmap_pars_fragment" ],
		
					"void main() {",
					
						
						
						
						"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
		
						THREE.ShaderChunk[ "map_fragment" ],
						THREE.ShaderChunk[ "alphatest_fragment" ],
						THREE.ShaderChunk[ "specularmap_fragment" ],
		
						"#ifdef DOUBLE_SIDED",
		
							//"float isFront = float( gl_FrontFacing );",
							//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
		
							"if ( gl_FrontFacing )",
								"gl_FragColor.xyz *= vLightFront;",
							"else",
								"gl_FragColor.xyz *= vLightBack;",
		
						"#else",
		
							"gl_FragColor.xyz *= vLightFront;",
		
						"#endif",
		
						THREE.ShaderChunk[ "lightmap_fragment" ],
						THREE.ShaderChunk[ "color_fragment" ],
						THREE.ShaderChunk[ "envmap_fragment" ],
						THREE.ShaderChunk[ "shadowmap_fragment" ],
		
						THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
		
						THREE.ShaderChunk[ "fog_fragment" ],
						
						//mca
						"float depth_ = gl_FragCoord.z / gl_FragCoord.w;",
						"float distOpacity = smoothstep( mNear, mFar, depth_ );",
						"gl_FragColor = vec4( gl_FragColor.rgb, distOpacity );",
						"if (distOpacity < 0.01) discard;", //depthBuffer will not be written
					"}"
		
				].join("\n")
		
			};
	
	THREE.ShaderMaterial.call(this, parameters);
};

GIScene.DistanceOpacityMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );/**
 * This Material renders a georeferenced texture on a mesh without using textureCoordinates, but realWorldCoordinates of each fragment(pixel).
 * 
 * @namespace GIScene
 * @class RasterOverlayMaterial
 * @constructor
 * @param {Object} config an Object with config properties
 * @example
 * 		rasterOverlayMaterial = new GIScene.RasterOverlayMaterial({
				lowerLeft: 	new GIScene.Coordinate2(llX, llY), //the lower left coordinate of the image boundingBox
				upperRight:	new GIScene.Coordinate2(urX, urY), //the upper right coordinate of the image boundingBox
				offset2:	new GIScene.Coordinate2(offsetX,offsetY), //optional
				url:"http://www.example.com/rasterimage.jpg",
				crossOrigin:"anonymous"	
				// texture: texture //instead of url you can also pass an existing texture	
		});
 * 
 */

GIScene.RasterOverlayMaterial = function(config) {
	//config-options: 
	//url or texture
	//crossOrigin default "anonymous" || "use-credentials"
	//lowerLeft (compute BBOX)
	//upperRight (compute BBOX)--> no offset needed
	//??? sceneOffset or LayerOffset??? translate??
	
	var defaults = {
		texture: null,
		url: null,
		crossOrigin : "anonymous",
		lowerLeft : new GIScene.Coordinate2(-100,-100), //GIScene.Coordinate2
		upperRight: new GIScene.Coordinate2(100,100), //GIScene.Coordinate2
		offset2: null,  //GIScene.Coordinate2
		isShared:true,  //if object will be disosed do not dispose material and its textures
		//standards
		emissive : new THREE.Color(0x000000)
	};
	
	/**
	 * The config which is used to initialize the RasterOverlayMaterial. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	//@TODO convert geo coordinates into system coordinates inclusive substraction of offset
	// var offset  = (offset) ? offset : new THREE.Vector2(0,0);
	// var lowerLeft  = lowerLeft.sub(offset)  || new THREE.Vector2(-100,-100);
	// var upperRight = upperRight.sub(offset) || new THREE.Vector2(100,100);
	this.url = this.config.url;
	this.crossOrigin = this.config.crossOrigin;
	this.offset2  = (this.config.offset2) ? this.config.offset2 : new GIScene.Coordinate2(0,0);
	this.lowerLeft  = this.config.lowerLeft.sub(this.offset2)  || new GIScene.Coordinate2(-100,-100);
	this.upperRight = this.config.upperRight.sub(this.offset2) || new GIScene.Coordinate2(100,100);
	this.texture = this.config.texture || new THREE.Texture();
	this.isShared = this.config.isShared;
	
	//standards
	var em = this.config.emissive;
	
	Object.defineProperty(this, 'emissive', {
	    get: function() {
	      console.log('get! emissive');
	      return em;
	    },
	    set: function(value) {
	      em = value;
	      this.uniforms.emissive.value = value;
	    }
	  });
	
	
	if (this.url){
		this.setTextureFromUrl(this.url, this.crossOrigin);
	}
	
	var parameters = {
				transparent:true,
				lights: true,
				side:0,
				shading: THREE.SmoothShading,
				uniforms: THREE.UniformsUtils.merge( [
		
					THREE.UniformsLib[ "common" ],
					THREE.UniformsLib[ "fog" ],
					THREE.UniformsLib[ "lights" ],
					THREE.UniformsLib[ "shadowmap" ],
		
					{
						"diffuse" : { type: "c", value: new THREE.Color( 0x36421E ) },
						"ambient"  : { type: "c", value: new THREE.Color( 0x36421E ) },
						"emissive" : { type: "c", value: this.emissive/*new THREE.Color( 0x000000 ) */},
						"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) },
					
						// "mNear": { type: "f", value: near },
						// "mFar" : { type: "f", value: far }
						"tOverlay"   : { type: "t",  value : this.texture},
						"lowerLeft"  : { type: "v2", value : this.lowerLeft},
						"upperRight" : { type: "v2", value : this.upperRight}
					}
		
				] ),
		
				vertexShader: [
					"varying vec3 vWorldPosition;",
		
					"#define LAMBERT",
		
					"varying vec3 vLightFront;",
					
					"varying vec3 vLightingOnly;",//mca
		
					"#ifdef DOUBLE_SIDED",
		
						"varying vec3 vLightBack;",
		
					"#endif",
		
					THREE.ShaderChunk[ "map_pars_vertex" ],
					THREE.ShaderChunk[ "lightmap_pars_vertex" ],
					THREE.ShaderChunk[ "envmap_pars_vertex" ],
					THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
					THREE.ShaderChunk[ "color_pars_vertex" ],
					THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
					THREE.ShaderChunk[ "skinning_pars_vertex" ],
					THREE.ShaderChunk[ "shadowmap_pars_vertex" ],
		
					"void main() {",
		
						THREE.ShaderChunk[ "map_vertex" ],
						THREE.ShaderChunk[ "lightmap_vertex" ],
						THREE.ShaderChunk[ "color_vertex" ],
		
						THREE.ShaderChunk[ "morphnormal_vertex" ],
						THREE.ShaderChunk[ "skinbase_vertex" ],
						THREE.ShaderChunk[ "skinnormal_vertex" ],
						THREE.ShaderChunk[ "defaultnormal_vertex" ],
		
						THREE.ShaderChunk[ "morphtarget_vertex" ],
						THREE.ShaderChunk[ "skinning_vertex" ],
						THREE.ShaderChunk[ "default_vertex" ],
		
						THREE.ShaderChunk[ "worldpos_vertex" ],
						THREE.ShaderChunk[ "envmap_vertex" ],
						//mca THREE.ShaderChunk[ "lights_lambert_vertex" ],
								"vLightFront = vec3( 0.0 );",

								"#ifdef DOUBLE_SIDED",
						
									"vLightBack = vec3( 0.0 );",
						
								"#endif",
						
								"transformedNormal = normalize( transformedNormal );",
						
								"#if MAX_DIR_LIGHTS > 0",
						
								"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",
						
									"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
									"vec3 dirVector = normalize( lDirection.xyz );",
						
									"float dotProduct = dot( transformedNormal, dirVector );",
									"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",
						
									"#ifdef DOUBLE_SIDED",
						
										"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
						
										"#ifdef WRAP_AROUND",
						
											"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
						
										"#endif",
						
									"#endif",
						
									"#ifdef WRAP_AROUND",
						
										"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
										"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",
						
										"#ifdef DOUBLE_SIDED",
						
											"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",
						
										"#endif",
						
									"#endif",
						
									"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",
						
									"#ifdef DOUBLE_SIDED",
						
										"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",
						
									"#endif",
						
								"}",
						
								"#endif",
						
								"#if MAX_POINT_LIGHTS > 0",
						
									"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",
						
										"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
										"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
						
										"float lDistance = 1.0;",
										"if ( pointLightDistance[ i ] > 0.0 )",
											"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",
						
										"lVector = normalize( lVector );",
										"float dotProduct = dot( transformedNormal, lVector );",
						
										"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",
						
										"#ifdef DOUBLE_SIDED",
						
											"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
						
											"#ifdef WRAP_AROUND",
						
												"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
						
											"#endif",
						
										"#endif",
						
										"#ifdef WRAP_AROUND",
						
											"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
											"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",
						
											"#ifdef DOUBLE_SIDED",
						
												"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",
						
											"#endif",
						
										"#endif",
						
										"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",
						
										"#ifdef DOUBLE_SIDED",
						
											"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",
						
										"#endif",
						
									"}",
						
								"#endif",
						
								"#if MAX_SPOT_LIGHTS > 0",
						
									"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",
						
										"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
										"vec3 lVector = lPosition.xyz - mvPosition.xyz;",
						
										"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",
						
										"if ( spotEffect > spotLightAngleCos[ i ] ) {",
						
											"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",
						
											"float lDistance = 1.0;",
											"if ( spotLightDistance[ i ] > 0.0 )",
												"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",
						
											"lVector = normalize( lVector );",
						
											"float dotProduct = dot( transformedNormal, lVector );",
											"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",
						
											"#ifdef DOUBLE_SIDED",
						
												"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",
						
												"#ifdef WRAP_AROUND",
						
													"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",
						
												"#endif",
						
											"#endif",
						
											"#ifdef WRAP_AROUND",
						
												"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
												"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",
						
												"#ifdef DOUBLE_SIDED",
						
													"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",
						
												"#endif",
						
											"#endif",
						
											"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",
						
											"#ifdef DOUBLE_SIDED",
						
												"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",
						
											"#endif",
						
										"}",
						
									"}",
						
								"#endif",
						
								"#if MAX_HEMI_LIGHTS > 0",
						
									"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",
						
										"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
										"vec3 lVector = normalize( lDirection.xyz );",
						
										"float dotProduct = dot( transformedNormal, lVector );",
						
										"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
										"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",
						
										"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",
						
										"#ifdef DOUBLE_SIDED",
						
											"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",
						
										"#endif",
						
									"}",
						
								"#endif",
								
								"vLightingOnly = vLightFront;", //mca
						
								"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",
						
								"#ifdef DOUBLE_SIDED",
						
									"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",
						
								"#endif",
								
								
						THREE.ShaderChunk[ "shadowmap_vertex" ],
						
						
						"vWorldPosition = worldPosition.xyz;",
					"}"
		
				].join("\n"),
		
				fragmentShader: [
					//mca
					// "uniform float mNear;",
					// "uniform float mFar;",
					"varying vec3 vWorldPosition;",
					"uniform vec2 lowerLeft;",
					"uniform vec2 upperRight;",
					"uniform sampler2D tOverlay;",
					
					"uniform vec3 ambient;",
					"uniform vec3 diffuse;",
					"uniform vec3 emissive;",
					"uniform vec3 ambientLightColor;",
					
					"uniform float opacity;",
		
					"varying vec3 vLightFront;",
					
					"varying vec3 vLightingOnly;",//mca
		
					"#ifdef DOUBLE_SIDED",
		
						"varying vec3 vLightBack;",
		
					"#endif",
		
					THREE.ShaderChunk[ "color_pars_fragment" ],
					THREE.ShaderChunk[ "map_pars_fragment" ],
					THREE.ShaderChunk[ "lightmap_pars_fragment" ],
					THREE.ShaderChunk[ "envmap_pars_fragment" ],
					THREE.ShaderChunk[ "fog_pars_fragment" ],
					THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
					THREE.ShaderChunk[ "specularmap_pars_fragment" ],
		
					"void main() {",
					
						
						
						
						"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",
						
						
		
						THREE.ShaderChunk[ "map_fragment" ],
						// "if(vWorldPosition.x >= lowerLeft.x && vWorldPosition.x <= upperRight.x && -vWorldPosition.z >= lowerLeft.y && -vWorldPosition.z <= upperRight.y)",
							// "{",
								// "vec2 worldPosGeo = vec2(vWorldPosition.x, -vWorldPosition.z);",
								// "vec4 tColor = texture2D(tOverlay,  (worldPosGeo-lowerLeft) / (upperRight - lowerLeft));",
								// // use emissive for selection, don't subtract it  "gl_FragColor = mix(gl_FragColor,vec4(((gl_FragColor.rgb - emissive - (ambient * ambientLightColor) )/diffuse) * tColor.rgb, opacity ),tColor.a) ;",
								// "gl_FragColor = mix(gl_FragColor,vec4((((gl_FragColor.rgb - emissive - (ambient * ambientLightColor) )/diffuse) +emissive)* tColor.rgb, opacity ),tColor.a) ;",
// 								
								// //new test
// 								
								// // "gl_FragColor =  mix(vec4(1.0),tColor, tColor.a);",
// 								
							// "}",
						THREE.ShaderChunk[ "alphatest_fragment" ],
						THREE.ShaderChunk[ "specularmap_fragment" ],
		
						"#ifdef DOUBLE_SIDED",
		
							//"float isFront = float( gl_FrontFacing );",
							//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",
		
							"if ( gl_FrontFacing )",
								"gl_FragColor.xyz *= vLightFront;",
							"else",
								"gl_FragColor.xyz *= vLightBack;",
		
						"#else",
		
							"gl_FragColor.xyz *= vLightFront;",
		
						"#endif",
		
						THREE.ShaderChunk[ "lightmap_fragment" ],
						//this was ShaderChunk color_fragment
						"#ifdef USE_COLOR",
							
							"gl_FragColor = gl_FragColor * vec4( vColor, opacity );",

						"#endif",
						THREE.ShaderChunk[ "envmap_fragment" ],
						THREE.ShaderChunk[ "shadowmap_fragment" ],
		
						THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
		
						THREE.ShaderChunk[ "fog_fragment" ],
						
						//mca
						// "float depth_ = gl_FragCoord.z / gl_FragCoord.w;",
						// "float distOpacity = smoothstep( mNear, mFar, depth_ );",
						// "gl_FragColor = vec4( gl_FragColor.rgb, distOpacity );",
						// "if (distOpacity < 0.01) discard;", //depthBuffer will not be written
						
						"if(vWorldPosition.x >= lowerLeft.x && vWorldPosition.x <= upperRight.x && -vWorldPosition.z >= lowerLeft.y && -vWorldPosition.z <= upperRight.y)",
							"{",
								"vec2 worldPosGeo = vec2(vWorldPosition.x, -vWorldPosition.z);",
								"vec4 tColor = texture2D(tOverlay,  (worldPosGeo-lowerLeft) / (upperRight - lowerLeft));",
								// use emissive for selection, don't subtract it  "gl_FragColor = mix(gl_FragColor,vec4(((gl_FragColor.rgb - emissive - (ambient * ambientLightColor) )/diffuse) * tColor.rgb, opacity ),tColor.a) ;",
								//"gl_FragColor = mix(gl_FragColor,vec4(((gl_FragColor.rgb - (ambient * ambientLightColor) )/diffuse) * tColor.rgb, opacity ),tColor.a) ;",
								
								//new test
								
								//"gl_FragColor =  mix(vec4(vec3(1.0),opacity),vec4(tColor.rgb* (((vLightFront-emissive-(ambient * ambientLightColor))/diffuse)+emissive), opacity), tColor.a);",
								//"gl_FragColor =  mix(gl_FragColor,vec4(tColor.rgb* (((vLightFront-emissive-(ambient * ambientLightColor))/diffuse)+emissive+ambientLightColor), opacity), tColor.a);",
								//"gl_FragColor =  mix(gl_FragColor,vec4(tColor.rgb* (((vLightFront-emissive-(ambient * ambientLightColor)))+emissive+ambientLightColor), opacity), tColor.a);",
								//"gl_FragColor =  mix(gl_FragColor,vec4(tColor.rgb* (((vLightFront-emissive-(ambient * ambientLightColor)) / diffuse)+emissive+ambientLightColor), opacity), tColor.a);",
								"gl_FragColor =  mix(gl_FragColor,vec4(tColor.rgb * (vLightingOnly + ambientLightColor + emissive), opacity), tColor.a);",
								  
								
							"}",
						
					"}"
		
				].join("\n")		
	};
	
	THREE.ShaderMaterial.call(this, parameters);
	
	
	
};

GIScene.RasterOverlayMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

/**
 * Sets the upper right corner coordinate of the bounding box which georeferences the texture
 * @method setUpperRight
 * @param {GIScene.Coordinate2} coord2 Coordinate in CRS units
 */
GIScene.RasterOverlayMaterial.prototype.setUpperRight = function(coord2) {
	this.upperRight = coord2.sub(this.offset2);
	this.uniforms.upperRight.value = this.upperRight;
};

/**
 * Sets the lower left corner coordinate of the bounding box which georeferences the texture
 * @method setLowerLeft
 * @param {GIScene.Coordinate2} coord2 Coordinate in CRS units
 */
GIScene.RasterOverlayMaterial.prototype.setLowerLeft = function(coord2) {
	this.lowerLeft = coord2.sub(this.offset2);
	this.uniforms.lowerLeft.value = this.lowerLeft;
};

/**
 * Sets a raster image as overlay texture
 * @method setTexture
 * @param {THREE.Texture} texture
 */
GIScene.RasterOverlayMaterial.prototype.setTexture = function(texture) {
	this.texture = this.uniforms.tOverlay.value = texture;
	/**
	 *@event settexture fires after a new texture has been set to the material
	 */
	this.dispatchEvent({type:"settexture", content:{texture:texture}});
};

/**
 * asyncronously loads and attaches a texture by specifiing a url to an image and optionally updates the material uniforms (lowerLeft and upperRight)
 * 
 * @method setTextureFromUrl
 * @param {String} url
 * @param {String} crossOrigin either "anonymous" or "use-credentials"
 * @param {Function} callback function after texture has been loaded and attached to material
 */
GIScene.RasterOverlayMaterial.prototype.setTextureFromUrl = function(url, crossOrigin, onSetTexture) {
	this.crossOrigin = (crossOrigin)? crossOrigin : this.crossOrigin;
	this.url = url;
	var texLoader = new THREE.TextureLoader();
	texLoader.setCrossOrigin(this.crossOrigin);
	var onOverlayLoad = function(e){
		if(onSetTexture) {onSetTexture();}
		this.setTexture(e);
	}.bind(this);
	texLoader.load(this.url, onOverlayLoad);
};

/**
 * Sets an offset which will be subtracted from real world coordinates in case the geometry uses also an offset (scene.offset)
 * @method setOffset2
 * @param {GIScene.Coordinate2} coord2
 */
GIScene.RasterOverlayMaterial.prototype.setOffset2 = function(coord2) {
	var offset2Old = this.offset2;
	this.offset2 = coord2;
	this.setLowerLeft(this.lowerLeft.add(offset2Old));
	this.setUpperRight(this.upperRight.add(offset2Old));
};

/**
 * Clones the material. BUT reuses the texture without cloning it.
 * @method clone
 * @return {GIScene.RasterOverlayMaterial} material 
 */
GIScene.RasterOverlayMaterial.prototype.clone = function() {
	var material = new GIScene.RasterOverlayMaterial();
	material.config = GIScene.Utils.mergeObjects(material.config, this.config);
	material.url = this.url;
	material.crossOrigin = this.crossOrigin;
	material.offset2  = this.offset2;
	material.lowerLeft  = this.lowerLeft;
	material.upperRight = this.upperRight;
	material.texture = this.texture;
	
	material.uniforms.lowerLeft.value = this.uniforms.lowerLeft.value;
	material.uniforms.upperRight.value = this.uniforms.upperRight.value;
	material.uniforms.tOverlay.value = this.uniforms.tOverlay.value;
	
	// THREE.ShaderMaterial.prototype.clone.call(this);
	
	return material;
};/**
 * special raster overlay material to use OGC-WMS services as image source 
 * 
 * @namespace GIScene
 * @class WMSOverlayMaterial
 * @constructor
 * @param {Object} config the config object for the material
 * @param {Object} params the OGC-WMS params for the request string
 */

GIScene.WMSOverlayMaterial = function(config, params) {
	//inherit
	GIScene.RasterOverlayMaterial.apply(this, [config]);
	
	var defaults = {
		wmsServiceUrl : "",
		crossOrigin : "anonymous"
	};
	
	var defaultParams = {
		service : "WMS",
		request : "GetMap",
		version : "1.1.1",
		format  : "image/png",
		srs		: "EPSG:32616",
		layers	: null,
		styles	: "",
		bbox	: null,
		width	: "256",
		height	: "256"
	};
	
	/**
	 * The config which is used to initialize the WMSOverlayMaterial. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	this.params = GIScene.Utils.mergeObjects(defaultParams, params || {});
	
	//make sure that url ends with ?
	this.wmsServiceUrl = (this.config.wmsServiceUrl=="")?"":this.config.wmsServiceUrl.trim().replace(/(\/|\?)*$/,"?");
	
	if (this.params.bbox){this.setLLURFromBboxParam();}
	
	if (!this.config.wmsServiceUrl==""){
		this.setTextureFromUrl(this.getGetMapUrl(), this.config.crossOrigin);
	}
	
	
};

GIScene.WMSOverlayMaterial.prototype = Object.create(GIScene.RasterOverlayMaterial.prototype);

/**
 * set BBOX paramter string from internal lowerLeft and upperRight properties 
 * @method setBboxParamFromLLUR
 */
GIScene.WMSOverlayMaterial.prototype.setBboxParamFromLLUR = function() {
	this.params.bbox = this.lowerLeft.clone().add(this.offset2).toArray().toString() + "," + this.upperRight.clone().add(this.offset2).toArray().toString();
};

/**
 * set internal lowerLeft and upperRight properties from params.bbox
 * @method setLLURFromBboxParam
 */
GIScene.WMSOverlayMaterial.prototype.setLLURFromBboxParam = function() {
	var bboxCoords = this.params.bbox.split(",");
	this.setLowerLeft(new GIScene.Coordinate2(bboxCoords[0],bboxCoords[1]));
	this.setUpperRight(new GIScene.Coordinate2(bboxCoords[2],bboxCoords[3]));
};

/**
 * Returns a URL with OGC-WMS parameters based on the material params
 * @method getGetMapUrl
 * @return {String} getMapUrl
 */
GIScene.WMSOverlayMaterial.prototype.getGetMapUrl = function() {
	if (!this.params.bbox){this.setBboxParamFromLLUR();}
	
	var getMapUrl = [
						this.wmsServiceUrl,
						"SERVICE="	+ this.params.service,
						"REQUEST="	+ this.params.request,
						"VERSION="	+ this.params.version,	
						"FORMAT=" 	+ this.params.format,
						"SRS="		+ this.params.srs,
						"LAYERS="	+ this.params.layers, 
						"STYLES="	+ this.params.styles,
						"BBOX=" 	+ this.params.bbox,
						"WIDTH="		+ this.params.width,
						"HEIGHT="	+ this.params.height
						
					].join("&");
	return getMapUrl;
};

/**
 * Clones the material. BUT reuses the texture without cloning it.
 * @method clone
 * @return {GIScene.WMSOverlayMaterial} material 
 */ 
GIScene.WMSOverlayMaterial.prototype.clone = function() {
	var material = new GIScene.WMSOverlayMaterial(); //this.config, this.params
	
	material.config = GIScene.Utils.mergeObjects(material.config, this.config);
	
	material.params = GIScene.Utils.mergeObjects(material.params, this.params);
	
	//make sure that url ends with ?
	material.wmsServiceUrl = this.wmsServiceUrl;
	
	//from RasterOverlayMaterial
	material.url = this.url;
	material.crossOrigin = this.crossOrigin;
	material.offset2  = this.offset2;
	material.lowerLeft  = this.lowerLeft;
	material.upperRight = this.upperRight;
	material.texture = this.texture;
	
	material.uniforms.lowerLeft.value = this.uniforms.lowerLeft.value;
	material.uniforms.upperRight.value = this.uniforms.upperRight.value;
	material.uniforms.tOverlay.value = this.uniforms.tOverlay.value;
	// GIScene.RasterOverlayMaterial.prototype.clone.call(this);
	
	// material.config = GIScene.Utils.mergeObjects(this.config, {});
	// material.params = GIScene.Utils.mergeObjects(this.params, {});
	// material.wmsServiceUrl = this.wmsServiceUrl;
	return material;
};/**
 * The PointAlignmentMaterial highlights fragments whose normals are heading to a given point.
 * 
 * @namespace GIScene
 * @class PointAlignmentMaterial
 * @constructor
 * @param {THREE.Vector3} point
 * @param {Number} maxDeviationDeg
 * @param {Number} maxUpDeviationDeg
 * 
 */

GIScene.PointAlignmentMaterial = function(point, maxDeviationDeg, maxUpDeviationDeg) {
	
	var _point = point || new THREE.Vector3(0,0,0);
	var _maxDeviationDeg = maxDeviationDeg || 15.0;
	var _maxUpDeviationDeg = maxUpDeviationDeg || 5.0;
	var _emissive = new THREE.Color( 0x000000 );
	
	Object.defineProperty(this, 'point', {
	    get: function() {
	      return _point;
	    },
	    set: function(value) {
	      _point = value;
	      this.uniforms.uPoint.value = value;
	    }
	  });
	  
	  Object.defineProperty(this, 'maxDeviationDeg', {
	    get: function() {
	      return _maxDeviationDeg;
	    },
	    set: function(value) {
	      _maxDeviationDeg = value;
	      this.uniforms.maxDeviationDeg.value = value;
	    }
	  });
	  
	  Object.defineProperty(this, 'maxUpDeviationDeg', {
	    get: function() {
	      return _maxUpDeviationDeg;
	    },
	    set: function(value) {
	      _maxUpDeviationDeg = value;
	      this.uniforms.maxUpDeviationDeg.value = value;
	    }
	  });
	  
	  Object.defineProperty(this, 'emissive', {
	    get: function() {
	      return _emissive;
	    },
	    set: function(value) {
	      _emissive = value;
	      this.uniforms.emissive.value = value;
	    }
	  });
	
	
	
	var parameters = {
		
		uniforms : {

			"opacity" : 		{type : "f",  value : 1.0},
			"uPoint"  : 		{type : "v3", value : this.point},
			"maxDeviationDeg" : {type : "f",  value : this.maxDeviationDeg},
			"maxUpDeviationDeg":{type : "f",  value : this.maxUpDeviationDeg},
			"emissive" : 		{type : "c",  value : this.emissive}

		},

		vertexShader : [
			"varying vec3 vNormal;", 
			"varying vec3 vWorldPosition;",
			"uniform vec3 emissive;",
			
			THREE.ShaderChunk["morphtarget_pars_vertex"], 
			
			"void main() {", 
				"vNormal = normalize(  normal );", 
				
				THREE.ShaderChunk["morphtarget_vertex"], 
				THREE.ShaderChunk["default_vertex"], 
				//THREE.ShaderChunk[ "worldpos_vertex" ],
				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",
			"}"
			].join("\n"),

		fragmentShader : [
			"uniform float opacity;", 
			"uniform vec3 uPoint;", 
			"uniform float maxDeviationDeg;", 
			"uniform float maxUpDeviationDeg;",
			"uniform vec3 emissive;",
			
			"varying vec3 vNormal;", 
			"varying vec3 vWorldPosition;",
			"float red;", 
			"float maxDeviation;", 
			"float maxUpDeviation;",
			
			"const float M_PI = 3.14159265358979323846;", 
			"vec3 hDir;", 
			"uniform mat4 modelMatrix;", 
			
			"void main() {", 
				"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * vNormal;", 
				"worldNormal = normalize( worldNormal );", 
				"maxDeviation = maxDeviationDeg * (M_PI / 180.0);",
				"maxUpDeviation = maxUpDeviationDeg * (M_PI / 180.0);",
	
				// 3D Direction
				//"red = (maxDeviation - acos(dot(worldNormal, compassDirection))) / maxDeviation;",
	
				//2D Direction (Aspect)
				//project face normal on horizontal plane
				// "hDir = worldNormal -  ( dot(worldNormal, vec3(0.0,1.0,0.0)) * vec3(0.0,1.0,0.0));",
				// "red = (maxDeviation - acos(dot(normalize(hDir), compassDirection))) / maxDeviation;",
		
				//exclude flat and almost flat areas from beeing colorized
				"float upDeviation = acos(dot(normalize(worldNormal), vec3(0.0,1.0,0.0)));", //deviation from up vector
				
				"if (upDeviation < maxUpDeviation || upDeviation > M_PI - maxUpDeviation)",
				"{",
					// "red = 0.0;",
					"gl_FragColor = vec4( vec3(0.5)+emissive, opacity );",
				"}",
				"else",
				"{",
				//3D direction to point
				"vec3 direction = uPoint-vWorldPosition;",
				
				//project directions on horizontal plane
				"vec3 hDirection = direction - ( dot(direction, vec3(0.0,1.0,0.0)) * vec3(0.0,1.0,0.0));",
				"vec3 hNormalDirection = worldNormal -  ( dot(worldNormal, vec3(0.0,1.0,0.0)) * vec3(0.0,1.0,0.0));",
				
				//angle between horizontal directions
				"float angle = acos(dot(normalize(hNormalDirection), normalize(hDirection)));",
				
				"red = (maxDeviation - angle) / maxDeviation;", //colorValue between 0..1
				
				"gl_FragColor = vec4( vec3(1.0,1.0-red,1.0-red) + emissive, opacity );",
				
				"}",
				
			
			"}"
			].join("\n")
	};
	
	THREE.ShaderMaterial.call(this, parameters);
	
	this.point = point || new THREE.Vector3(0,0,0);
	this.maxDeviationDeg = maxDeviationDeg || 15.0;
	this.maxUpDeviationDeg = maxUpDeviationDeg || 5.0;
	this.emissive = new THREE.Color( 0x000000 );
	
};

GIScene.PointAlignmentMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );

GIScene.PointAlignmentMaterial.prototype.clone = function() {
	
	var material = new GIScene.PointAlignmentMaterial();
	
	THREE.ShaderMaterial.prototype.clone.call( this, material );
	
	material.point = this.point.clone();
	
	material.maxDeviationDeg = this.maxDeviationDeg;
	
	material.maxUpDeviationDeg = this.maxUpDeviationDeg;
	
	material.emissive = this.emissive;
	
	return material;
};


/**
 * Abstract base class to implement override material handler. 
 * These are functions that will be called on each object just after the override Material will be assigned to each object by using the Layer-event "afterOverrideMaterial"
 * These handlers should be referenced in the overrideMaterialHandler property of the Layer
 * 
 * @namespace GIScene
 * @class OverrideMaterialHandler
 */

GIScene.OverrideMaterialHandler = function(event) {
	this.object = event.content.object;
	this.overrideMaterial = event.content.overrideMaterial;
	this.layer = event.content.layer;
};/**
 * OverrideMaterialHandler to assign WMS images to objects, like terrain tiles.
 * Works only with GIScene.RasterOverlayMaterial
 * 
 * @namespace GIScene
 * @class OverrideMaterialHandler.WMS
 */

GIScene.OverrideMaterialHandler.WMS = function(event) {
	//inherit from abstact base class
	GIScene.OverrideMaterialHandler.apply(this,[event]);
	//only act when material is WMSOverlayMateriakl and on objects containing geometry
	if( !(this.overrideMaterial instanceof GIScene.WMSOverlayMaterial)  || !this.object.geometry)return;
	
	var onSetTexture = function() {
		//set uniforms after new texture has been loaded, use old uniforms and texture during loading time
		objOverrideMaterial.uniforms.lowerLeft.value = objOverrideMaterial.lowerLeft;
		objOverrideMaterial.uniforms.upperRight.value = objOverrideMaterial.upperRight;	
		objOverrideMaterial.unsharedWmsTextureLoaded = true;
		
		
	}.bind(this);
	
	var bbox2 = new GIScene.Extent2().fromBox3(new THREE.Box3().setFromObject(this.object));
	var objOverrideMaterial = this.overrideMaterial.clone();
	
	objOverrideMaterial.waitForTexture = true;
	
	// objOverrideMaterial.setTexture(new THREE.Texture());
	// objOverrideMaterial.setTexture(null);
	objOverrideMaterial.lowerLeft = bbox2.min;
	// objOverrideMaterial.uniforms.lowerLeft.value = objOverrideMaterial.lowerLeft;
	objOverrideMaterial.upperRight = bbox2.max;
	// objOverrideMaterial.uniforms.upperRight.value = objOverrideMaterial.upperRight;
	
	objOverrideMaterial.isShared = false; //material and texture will be deleted in GIScene.Grid.TileStore.removeOldestEntry()	
	
	objOverrideMaterial.setBboxParamFromLLUR();
	
	//assign material
	this.object.material = objOverrideMaterial;
	objOverrideMaterial.setTextureFromUrl(objOverrideMaterial.getGetMapUrl(), objOverrideMaterial.config.crossOrigin, onSetTexture);
	// console.log("objOverrideMaterial",objOverrideMaterial);
	// //assign material
	// this.object.material = objOverrideMaterial;
};

GIScene.OverrideMaterialHandler.WMS.prototype = Object.create(GIScene.OverrideMaterialHandler.prototype);
/**
 * Abstract class used for Control classes
 * 
 * @namespace GIScene
 * @class Control
 *  
 */

GIScene.Control = function () {
	
	/**
	 * @property scene
	 * @type GIScene.Scene 
	 */
	this.scene = null;
	
	/**
	 * @property isActive
	 * @type Boolean 
	 */
	this.isActive = false;
	
};


GIScene.Control.prototype = {
	
	constructor : GIScene.Control,
	
	/**
	 * Sets the scene property. This is automatically called on scene.addControl()
 	 * @method setScene
 	 * @param {Object} scene
	 */
	setScene : function(scene){this.scene = scene;},
	
	/**
	 * Activates this Control ...
	 * 
	 * @method activate
	 *  
	 */
	activate : function (){this.isActive = true;},
	
	/**
	 * Dectivates this Control ...
	 * 
	 * @method deactivate
	 *  
	 */
	deactivate : function (){this.isActive = false;},
	
	//Provide EventDispatcher Functions
	addEventListener : THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener : THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener : THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent : THREE.EventDispatcher.prototype.dispatchEvent
	
};/**
 * Control to enable the interactive selection and or highlighting of 3D Objects in the scene
 * 
 * @namespace GIScene
 * @class Control.Select
 * @constructor
 * @extends GIScene.Control
 * @param {Array | THREE.Object3D} selectables An Array or single THREE.Object3D. Contains the potentially selectable Elements of type THREE.Object3D 
 * @param {THREE.Camera} camera The active camera  
 * @param {Object} [config] Configuration properties to influence the behaviour of this Control
 * 	
 * 
 *  You can use multiple options to customize the behaviour of the Select Control:
 * 	
 * 	Main options: 
 * 
 * 	1. Choose between hover or click behaviour by setting hover:true || hover:false
 *  2. Choose whether objects should be really selected or just highlighted by setting highlightOnly:true || highlightOnly:false
 *  3. Choose a highlighting color by setting e.g: selectColor:0xff0000
 * 
 *  The following options are only available if hover:false:
 * 
 *  multi    - whether it is possible to select only one object or multiple (hold down CTRL-Key)
 * 
 *  toggle   - whether click on a selected/highlighted object unselects/unhighlights it again
 * 
 *  clickout - whether a click somewhere not on a selectable object unselects all others 
 * 	
 *  You can even combine 2 Select controls to enable highlighting on mouseover ('hover') and selection on click:
 * @example
 * 		var selectControl = new GIScene.Control.Select(scene.root.children, scene.camera, {highlightOnly:false, hover:false, multi:false, toggle:true, clickout:true});
		scene.addControl(selectControl);
		selectControl.activate();

		var highlightControl = new GIScene.Control.Select(scene.root.children, scene.camera, {highlightOnly:true, hover:true});
		scene.addControl(highlightControl);
		highlightControl.activate(); 
 */

GIScene.Control.Select = function (selectables, camera, config) {
		
	//make this a control
	GIScene.Control.call(this);
	
	var defaults = {
		highlightOnly: false,
		hover:false,
		clickout:true,
		multi:false,
		toggle:true,
		selectColor: 0xffff00
	};
	
	/**
	 * The config which is used to initialize the Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {}); 
	
	this.selectables = (selectables instanceof Array)?selectables : (selectables instanceof THREE.Object3D)? [selectables] : [];
	this.camera = camera;
	this.domElement = null;
	this.hitObject = null;
	
	var projector = new THREE.Projector();
	var mouse = new THREE.Vector3(0,0,1); //warum z =1 und nicht 0?
	var isDblClick = false;
	
	this.selectedObjects = [];
	this.highlightedOnlyObjects = [];
	

	this.getHitObject = function(vector){
		var ray = projector.pickingRay(vector, this.camera);
		var hitObjects = ray.intersectObjects(this.selectables);
		// var hitObject = (hitObjects.length > 0) ? hitObjects[0].object : undefined;
		var hitObject;
		for(var i=0; i < hitObjects.length; i++){
			//@TODO MeshFaceMaterial is not supported
			if(hitObjects[i].object.geometry && hitObjects[i].object.visible && ((hitObjects[i].object.material.opacity)?hitObjects[i].object.material.opacity>0 : true)/* for multimaterial opacity not checked(always true)*/ ){
				hitObject = hitObjects[i].object;
				break;
			};
		};
		
		return hitObject;
	};
	
	/**
	 * Highlight an object. This will also be called by the select() function. Sets object.userData.isHighlighted = true.
	 * 
	 * @method highlight
	 * @param {THREE.Object3D} object
	 * @param {Boolean} interaction this flag is used to differentiate between user interaction triggered selection or programmatical selection resulting in a special event for user-triggerd selections.
	 */
	this.highlight = function (object, interaction) {
		
		if(!object.userData.isHighlighted){
			object.userData.isHighlighted = true;
			GIScene.Utils.WorkingMaterial.setSelectColor(object,new THREE.Color(this.config.selectColor));
		//-------
		// if(!object.userData.originalMaterial){
			// // if no working material exists create one 
			// object.userData.originalMaterial = object.material;
			// object.material = object.userData.originalMaterial.clone();
		// }
// 		
		// if(!object.userData.isHighlighted){
			// object.userData.isHighlighted = true;
// 			
			// // object.userData.originalMaterial = object.material;
			// // object.material = object.userData.originalMaterial.clone();
// 			
			// //for multimaterial
			// if("materials" in object.material){
				// object.material.materials.forEach(
					// function (e,i,a){
						// a[i].emissive.setHex(this.config.selectColor);
					// }.bind(this)
				// );
			// }
			// //for single material
			// else {
				// object.material.emissive.setHex(this.config.selectColor);
			// }
// 			
			// //set selected flag
			// object.userData.workingMaterialFlags = ("workingMaterialFlags" in object.userData)? object.userData.workingMaterialFlags ^ GIScene.WORKINGMATERIALFLAGS.SELECT : GIScene.WORKINGMATERIALFLAGS.SELECT ;
			
			if(this.config.highlightOnly){this.highlightedOnlyObjects.push(object);};
			/**
			 * The highlighted event will be triggered after the feature is highlighted.
			 * The event contains a content property with a reference to the highlighted object.
			 * 
			 * @event highlighted
			 */
			this.dispatchEvent({type:'highlighted', content:object});
			/**
			 * The highlightedbyuser event will be triggered after the feature is highlighted by a user interaction.
			 * The event contains a content property with a reference to the highlighted object.
			 * 
			 * @event highlightedbyuser
			 */
			if(interaction)this.dispatchEvent({type:'highlightedbyuser', content:object});
		}
		else {
			if(this.config.toggle){
				//console.log('toggle highlight');
				this.unhighlight(object,interaction);
			}
		}		
	};
	
	/**
	 * Unhighlight an object. This will also be called by the unselect() function. Sets object.userData.isHighlighted = false.
	 * 
	 * @method unhighlight
	 * @param {THREE.Object3D} object
	 * @param {Boolean} interaction this flag is used to differentiate between user interaction triggered selection or programmatical selection resulting in a special event for user-triggerd selections.
	 */
	this.unhighlight = function (object,interaction) {
		if(!object.userData.isSelected){
		
			GIScene.Utils.WorkingMaterial.setSelectColor(object,'default');
			// //remove select flag
			// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.SELECT;
// 			
			// if(object.userData.workingMaterialFlags != 0){
				// //working material is still in use, so just set property
// 				
				// //for multimaterial
				// if("materials" in object.material){
					// object.material.materials.forEach(
						// function (e,i,a){
							// a[i].emissive.setHex(object.userData.originalMaterial.materials[i].emissive.getHex());
						// }
					// );
				// }
				// //for single material
				// else {
					// object.material.emissive.setHex(object.userData.originalMaterial.emissive.getHex());
				// }
			// } else{
				// //working material not in use anymore, remove it and set back to original material
				// object.material = object.userData.originalMaterial;
				// object.userData.originalMaterial = null;
				// delete object.userData.originalMaterial;
			// }
		
		object.userData.isHighlighted = false;
		}
		
		for(var i = 0; i < this.highlightedOnlyObjects.length; i++){	
			if(object === this.highlightedOnlyObjects[i]){
				this.highlightedOnlyObjects.splice(i,1);
				break;
			}			
		};
		/**
		 * The unhighlighted event will be triggered after the feature is unhighlighted.
		 * The event contains a content property with a reference to the unhighlighted object.
		 * 
		 * @event unhighlighted
		 */
		this.dispatchEvent({type:'unhighlighted', content:object});
		/**
		 * The unhighlightedbyuser event will be triggered after the feature is unhighlighted through user interaction.
		 * The event contains a content property with a reference to the unhighlighted object.
		 * 
		 * @event unhighlightedbyuser
		 */
		if(interaction)this.dispatchEvent({type:'unhighlightedbyuser', content:object});
	};
	
	/**
	 * Select an object. This will also call the highlight() function. Sets object.userData.isSelected = true.
	 * 
	 * @method select
	 * @param {THREE.Object3D} object
	 * @param {Boolean} interaction this flag is used to differentiate between user interaction triggered selection or programmatical selection resulting in a special event for user-triggerd selections.
	 */
	this.select = function (object,interaction) {
		//console.log("select: object.userData.isSelected: " + object.userData.isSelected)
		if(!object.userData.isSelected){
			//console.log('select if unselected');
			object.userData.isSelected = true;
			this.selectedObjects.push(object);
			/**
			 * The selected event will be triggered before the feature is highlighted.
			 * The event contains a content property with a reference to the selected object.
			 * 
			 * @event selected
			 */
			this.dispatchEvent({type:'selected', content:object});
			/**
			 * The selectedbyuser event will be triggered before the feature is highlighted.
			 * The event contains a content property with a reference to the selected object.
			 * 
			 * @event selectedbyuser
			 */
			if(interaction)this.dispatchEvent({type:'selectedbyuser', content:object});
			
			this.highlight(object); //?? forward interaction
		}
		else {
			if (this.config.toggle) {
				//console.log('toggle select');
				this.unselect(object,interaction);
			}
		}
	};
	
	/**
	 * Unselect an object. This will also call the unhighlight() function. Sets object.userData.isSelected = false.
	 * 
	 * @method unselect
	 * @param {THREE.Object3D} object
	 * @param {Boolean} interaction this flag is used to differentiate between user interaction triggered selection or programmatical selection resulting in a special event for user-triggerd selections.
	 */
	this.unselect = function (object,interaction) {
		//console.log("unselect");
		object.userData.isSelected = false;
		this.unhighlight(object); //??forward interaction
		
		for(var i = 0; i < this.selectedObjects.length; i++){	
			if(object === this.selectedObjects[i]){
				this.selectedObjects.splice(i,1);
				break;
			}			
		};
		/**
		 * The unselected event will be triggered after the feature is unhighlighted.
		 * The event contains a content property with a reference to the unselected object.
		 * 
		 * @event unselected
		 */
		this.dispatchEvent({type:'unselected', content:object});
		/**
		 * The unselectedbyuser event will be triggered after the feature is unhighlighted.
		 * The event contains a content property with a reference to the unselected object.
		 * 
		 * @event unselectedbyuser
		 */
		if(interaction)this.dispatchEvent({type:'unselectedbyuser', content:object});
	};
	
	/**
	 * Removes an object from the selectables Array
	 * @method removeSelectable
	 * @param {THREE.Object3D} object
	 */
	this.removeSelectable = function (object) {
		//remove from selectedObjects and highlightedOnlyObjects Array
		if(object.userData.isHighlighted)this.unselect(object);
		//remove from selectables Array
		var newSelectables =[];
		for(var i=0,j=this.selectables.length; i<j; i++){
		  if(this.selectables[i] !== object){
		  	newSelectables.push(this.selectables[i]);
		  }  
		};
		this.selectables = newSelectables;
	};
	
	var onDisposeObject = function(event) {
		this.removeSelectable(event.content);
	}.bind(this);
	
	var onMouseEvent = function(event){
		
		event.preventDefault();
		
		// //get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);


		// Did the mouse hit an object? When yes which?
		var hitObject = this.getHitObject(mouse);

		//prevent misconfiguration of hover mode
		if(this.config.hover){this.config.toggle = false; this.config.clickout = true;this.config.multi = false;};
		
		//logic of hightlighting and selection
		if (hitObject) {
			//console.log('clickin');
			if (this.config.multi && event.ctrlKey) {
				if (this.config.highlightOnly) {
					if(!hitObject.userData.isHighlighted || this.config.toggle)this.highlight(hitObject, true);
				} else {
					if(!hitObject.userData.isSelected || this.config.toggle)this.select(hitObject, true);
				}
			}
			else //multi false
			{
				//console.log('multi false');
				if (this.config.highlightOnly) {
					
					//if(this.highlightedOnlyObjects[0] && this.highlightedOnlyObjects[0] !== hitObject)this.unhighlight(this.highlightedOnlyObjects[0]);
					if(this.highlightedOnlyObjects.length > 0){
						this.unhighlightAll(true);
						// var temp_highlightedOnlyObjects = this.highlightedOnlyObjects.slice(0);
						// temp_highlightedOnlyObjects.forEach(function(e,i,a){this.unhighlight(temp_highlightedOnlyObjects[i]);}.bind(this));
						// temp_highlightedOnlyObjects = null;
					}
					
					
					if(!hitObject.userData.isHighlighted || this.config.toggle)this.highlight(hitObject,true);
				
				
				} else {
					//if(this.selectedObjects[0] && this.selectedObjects[0] !== hitObject)this.unselect(this.selectedObjects[0]);
					if(!this.config.hover && this.selectedObjects.length > 0 /*&& !hitObject.userData.isSelected*/){
						//this.unselect(this.selectedObjects[0])
						//unselect all 
						this.unselectAll(true);
						 // var temp_selectedObjects = this.selectedObjects.slice(0);
						 // temp_selectedObjects.forEach(function(e,i,a){this.unselect(temp_selectedObjects[i]);}.bind(this));
						 // temp_selectedObjects = null;
						}
					else{
						//hover
						if(this.selectedObjects[0] && this.selectedObjects[0] !== hitObject)this.unselect(this.selectedObjects[0], true);
					}
					
					if(!hitObject.userData.isSelected || this.config.toggle)this.select(hitObject,true);
				}
			}
		} else {//clickout
			if (this.config.clickout) {
				//console.log("clickout");
				//unselect or unhighlight all
				if (this.config.highlightOnly) {
					// while (this.highlightedOnlyObjects.length > 0) {
						// this.unhighlight(this.highlightedOnlyObjects[0],true);
					// }
					this.unhighlightAll(true);
				} else {
					// while (this.selectedObjects.length > 0) {
						// this.unselect(this.selectedObjects[0],true);
					//}
					this.unselectAll(true);
				}
			}
		}

	}.bind(this);
	
	var onMouseDown = function(event) {
		if(this.config.hover){
			this.domElement.removeEventListener( 'mousemove', onMouseEvent, false );
		}
		else{
			//get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
		}
	}.bind(this);
	
	var onMouseUp = function(event) {
		if(this.config.hover){
			this.domElement.addEventListener( 'mousemove', onMouseEvent, false );
		}else{
			//get mouse ScreenCoords
		var mouseOld = mouse.clone();
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
		
		//avoid mouseup event if dblcklicked
		setTimeout(function(){
			console.log(isDblClick);
			if(isDblClick){
				dblClickCount++;
			}
			
			if(mouse.equals(mouseOld) && !isDblClick){onMouseEvent(event);};
			
			if(dblClickCount > 1){isDblClick = false; dblClickCount = 0;}
		}.bind(this),250);
		
		//if(mouse.equals(mouseOld) && !isDblClick){onMouseEvent(event);};
		
		}
	}.bind(this);
	
	var dblClickCount = 0;
	var onDblClick = function(event) {
		isDblClick = true;
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.domElement = this.scene.canvas;
		
		this.domElement.addEventListener( 'mousedown', onMouseDown, false );
		this.domElement.addEventListener( 'mouseup', onMouseUp, false ); //on document??
		this.domElement.addEventListener( 'dblclick', onDblClick, false );
		if(this.config.hover){
			this.domElement.addEventListener( 'mousemove', onMouseEvent, false );
		}
		// else{
			// this.domElement.addEventListener( 'click', onMouseEvent, false );
		// }
		this.scene.addEventListener( 'beforeDisposeObject', onDisposeObject );
		
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		this.domElement.removeEventListener( 'mouseup', onMouseUp, false );
		
		if(this.config.hover){
			this.domElement.removeEventListener( 'mousemove', onMouseEvent, false );
		}
		// else{
			// this.domElement.removeEventListener( 'click', onMouseEvent, false );
		// }
		this.scene.removeEventListener( 'beforeDisposeObject', onDisposeObject );
		
		GIScene.Control.prototype.deactivate.call(this);
	};
};

//Inherit from GIScene.Control
GIScene.Control.Select.prototype = Object.create( GIScene.Control.prototype );

GIScene.Control.Select.prototype.unhighlightAll = function(interaction){
	var temp_highlightedOnlyObjects = this.highlightedOnlyObjects.slice(0);
	temp_highlightedOnlyObjects.forEach(function(e,i,a){this.unhighlight(temp_highlightedOnlyObjects[i],interaction);}.bind(this));
	temp_highlightedOnlyObjects = null;
	/**
	 *@event unhighlightall 
	 */
	this.dispatchEvent({type:'unhighlightall'});
	/**
	 *@event unhighlightallbyuser 
	 */
	if(interaction)this.dispatchEvent({type:'unhighlightallbyuser'});
};

GIScene.Control.Select.prototype.unselectAll = function(interaction){
	var temp_selectedObjects = this.selectedObjects.slice(0);
	temp_selectedObjects.forEach(function(e,i,a){this.unselect(temp_selectedObjects[i], interaction);}.bind(this));
	temp_selectedObjects = null;
	/**
	 *@event unselectall 
	 */
	this.dispatchEvent({type:'unselectall'});
	/**
	 *@event unselectallbyuser 
	 */
	if(interaction)this.dispatchEvent({type:'unselectallbyuser'});
};
/**
 * Pan Control. *experimental, not ready to use*
 * 
 * @namespace GIScene
 * @class Control.Pan 
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 */

GIScene.Control.Pan = function( object, domElement ){
	
	//Make this a Control
	GIScene.Control.call(this);
	
	//Make this an EventDispatcher
	THREE.EventDispatcher.call( this );
	
	STATE = { NONE : -1, PAN : 0}; //mouse event.button = 0:left 1:click wheel 2: right 
	var _this = this;
	
	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;
	
	//API
	this.panSpeed = 0.825;
	
	//internals
	this.target = new THREE.Vector3();

	var lastPosition = new THREE.Vector3();

	var _keyPressed = false,
	_state = STATE.NONE,


	_eye = new THREE.Vector3(),

	// _rotateStart = new THREE.Vector3(),
	// _rotateEnd = new THREE.Vector3(),
// 
	// _zoomStart = new THREE.Vector2(),
	// _zoomEnd = new THREE.Vector2(),


	_panStart = new THREE.Vector2(),
	_panEnd = new THREE.Vector2();
	
	
	
	this.panCamera = function () {

		var mouseChange = _panEnd.clone().sub( _panStart );
		
		if ( mouseChange.lengthSq() ) {

			mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

			var pan = _eye.clone().cross( _this.object.up ).setLength( mouseChange.x );
			pan.add( _this.object.up.clone().setLength( mouseChange.y ) );


			_this.object.position.add( pan );
			_this.target.add( pan );

			//if ( _this.staticMoving ) {

				_panStart = _panEnd;

			// } else {
// 
				// _panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );
// 
			// }


		}

	};
	
	
	
	this.update = function () {
		_eye.copy( _this.object.position ).sub( _this.target );
		_this.panCamera();
		_this.object.position.Vectors( _this.target, _eye );
		_this.object.lookAt( _this.target );
	};
	

	mousedown = function (event) {
		_state = STATE.PAN;
	  	_panStart = _panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500);  //_this.getMouseOnScreen( event.clientX, event.clientY );
	};
	
	mousemove = function (event) {
		if(_state == STATE.PAN){
			_panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500); //_this.getMouseOnScreen( event.clientX, event.clientY );
		}
	};
	
	mouseup = function (event) {
		_state = STATE.NONE;
	}; 
	
	
	this.activate = function () {  
		if(this.isActive) return;
		
		this.domElement.addEventListener( 'mousedown', mousedown, false );
		this.domElement.addEventListener( 'mousemove', mousemove, false );
		this.domElement.addEventListener( 'mouseup', mouseup, false );
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	this.deactivate = function () {
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'mousedown', mousedown, false );
		this.domElement.removeEventListener( 'mousemove', mousemove, false );
		this.domElement.removeEventListener( 'mouseup', mouseup, false );
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};
/**
 * Control to Examine Objects. Rotates the Camera around a center, zooms in and out and pans the camera. 
 *
 * @namespace GIScene
 * @class Control.OrbitZoomPan
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 * 
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * modified by m.auer
 */

GIScene.Control.OrbitZoomPan = function ( object, domElement ) {
	
	GIScene.Control.call( this );

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.center = null; //will be first set on activate
	
	this.userZoom = true;
	this.userZoomSpeed = 1.0;

	this.userRotate = true;
	this.userRotateSpeed = 1.0;

	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// mca
	this.userPan = true;
	this.userPanSpeed = 0.825;

	
	// internals

	var scope = this;

	var EPS = 0.000001;
	var PIXELS_PER_ROUND = 1800;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var zoomStart = new THREE.Vector2();
	var zoomEnd = new THREE.Vector2();
	var zoomDelta = new THREE.Vector2();

	//mca
	var _eye = new THREE.Vector3(),
	_panStart = new THREE.Vector2(),
	_panEnd = new THREE.Vector2();

	var phiDelta = 0;
	var thetaDelta = 0;
	var scale = 1;

	var lastPosition = new THREE.Vector3();

	var STATE = { NONE : -1, ROTATE : 0, ZOOM : 1, PAN: 2 }; //mca
	var state = STATE.NONE;

	// events

	var changeEvent = { type: 'change' };


	this.rotateLeft = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta -= angle;

	};

	this.rotateRight = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta += angle;

	};

	this.rotateUp = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta -= angle;

	};

	this.rotateDown = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta += angle;

	};

	this.zoomIn = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale /= zoomScale;

	};

	this.zoomOut = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale *= zoomScale;

	};
	
	//mca inserted from TrackballControls _this-->scope
	this.panCamera = function () {

		var mouseChange = _panEnd.clone().sub( _panStart );
		
		if ( mouseChange.lengthSq() ) {

			mouseChange.multiplyScalar( _eye.length() * scope.userPanSpeed );  //panSpeed

			// var pan = _eye.clone().cross( scope.object.up ).setLength( mouseChange.x );
			// pan.add( scope.object.up.clone().setLength( mouseChange.y ) );
			var pan = _eye.clone().cross( scope.object.up ).setLength( mouseChange.x );
			pan.sub( _eye.clone().cross( _eye.clone().cross( scope.object.up ) ).setLength( mouseChange.y ) ); //mca: don't pan along y axis, pan perpendicular to eye vector
			

			scope.object.position.add( pan );
			var oldCenter = scope.center.clone();
			scope.center.add( pan ); //target-->center

			_panStart = _panEnd;

		}

	};

	this.update = function () {
		
		if (state != STATE.PAN) {
		
			var position = this.object.position;
			var offset = position.clone().sub( this.center );
	
			// angle from z-axis around y-axis
	
			var theta = Math.atan2( offset.x, offset.z );
	
			// angle from y-axis
	
			var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
	
			if ( this.autoRotate ) {
	
				this.rotateLeft( getAutoRotationAngle() );
	
			}
	
			theta += thetaDelta;
			phi += phiDelta;
	
			// restrict phi to be betwee EPS and PI-EPS
	
			phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );
	
			var radius = offset.length();
			offset.x = radius * Math.sin( phi ) * Math.sin( theta );
			offset.y = radius * Math.cos( phi );
			offset.z = radius * Math.sin( phi ) * Math.cos( theta );
			//zoom perspective
			offset.multiplyScalar( scale );
			//zoom ortho; mca
			if(this.object.inOrthographicMode){
				this.object.toOrthographic();
			}
			
			
			position.copy( this.center ).add( offset );
	
			this.object.lookAt( this.center );
	
			thetaDelta = 0;
			phiDelta = 0;
			scale = 1;
		}
		//mca PAN target --> center
		else {
			_eye.copy( scope.object.position ).sub( scope.center );
			scope.panCamera();
			scope.object.position.addVectors( scope.center, _eye );
			//scope.object.lookAt( scope.center );
		}
		//mca end

		if ( lastPosition.distanceTo( this.object.position ) > 0 ) {
			/**
			 *@event change 
			 */
			this.dispatchEvent( changeEvent );
			lastPosition.copy( this.object.position );
		}

	}.bind(this);


	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.userZoomSpeed );

	}

	function onMouseDown( event ) {
		/**
		 *@event beforechange 
		 */
		scope.dispatchEvent({type:'beforechange'});
		
		if ( !scope.userRotate ) return;

		event.preventDefault();

		if ( event.button === 0 ){	//|| event.button === 2 ) {

			state = STATE.ROTATE;

			rotateStart.set( event.clientX, event.clientY );

		} else if ( event.button === 1 ) {

			state = STATE.ZOOM;

			zoomStart.set( event.clientX, event.clientY );

		} 
		//mca
		else if (event.button === 2) {
			state = STATE.PAN;
			_panStart = _panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500);
		}

		document.addEventListener( 'mousemove', onMouseMove, false );
		document.addEventListener( 'mouseup', onMouseUp, false );

	}

	function onMouseMove( event ) {

		event.preventDefault();
		
		
		
		if ( state === STATE.ROTATE ) {

			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			scope.rotateLeft( 2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed );
			scope.rotateUp( 2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed );

			rotateStart.copy( rotateEnd );

		} else if ( state === STATE.ZOOM ) {

			zoomEnd.set( event.clientX, event.clientY );
			zoomDelta.subVectors( zoomEnd, zoomStart );

			if ( zoomDelta.y > 0 ) {

				scope.zoomIn();

			} else {

				scope.zoomOut();

			}

			zoomStart.copy( zoomEnd );

		}
		//mca
		else if ( state === STATE.PAN ) {
			_panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500);
		};

	}

	function onMouseUp( event ) {

		if ( ! scope.userRotate ) return;

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		state = STATE.NONE;
		/**
		 *@event afterchange 
		 */
		scope.dispatchEvent({type:'afterchange'});
	}

	function onMouseWheel( event ) {

		if ( ! scope.userZoom ) return;

		if ( ( event.wheelDelta && event.wheelDelta > 0 ) || ( event.detail && event.detail > 0 ) ) {

			scope.zoomOut();

		} else {

			scope.zoomIn();

		}

	}
	
	
	var onCenter = function(event){
		  
		this.center = event.content.center;
		
	}.bind(this);
	
	var onChange = function(event){
		
		this.scene.center = event.target.center.clone();
		this.object.target.position.setZ(-this.object.position.distanceTo(event.target.center));
		
	};
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.center = this.scene.center.clone();//new THREE.Vector3();
		this.object.up.set(0,1,0);
		//if(this.center.distanceTo(this.object.position)< 0.01){this.object.position.add(new THREE.Vector3(0,0,0.01));}
		var dir= new THREE.Vector3(0,0,-1); //cameras default direction
		dir.applyQuaternion(this.object.quaternion); //cameras actual direction
		dir.normalize();
		if(this.center.distanceTo(this.object.position)< 0.01){this.object.position.sub(dir.multiplyScalar(0.01));}
		
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.addEventListener( 'mousedown', onMouseDown, false );
		this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
		this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); //Firefox
		this.addEventListener('change', onChange);
		this.scene.addEventListener('center', onCenter);
		//hang in render loop
		this.scene.addEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		this.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );
		this.domElement.removeEventListener( 'DOMMouseScroll', onMouseWheel, false ); //Firefox
		this.addEventListener('change', onChange);
		this.scene.removeEventListener('center', onCenter);
		//remove from render loop
		this.scene.removeEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};


GIScene.Control.OrbitZoomPan.prototype = Object.create( GIScene.Control.prototype );


/**
 * Control to examine Objects and move around on a terrain. Rotates the Camera around a center, zooms in and out, pans the camera and moves to a new rotation center on double click. 
 *
 * @namespace GIScene
 * @class Control.PanOrbitZoomCenter
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 * 
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * modified by m.auer
 */

GIScene.Control.PanOrbitZoomCenter = function ( object, domElement ) {
	
	GIScene.Control.call( this );

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.center = null;
	
	this.userZoom = true;
	this.userZoomSpeed = 1.0;

	this.userRotate = true;
	this.userRotateSpeed = 1.0;

	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// mca
	this.userPan = true;
	this.userPanSpeed = 0.825;

	
	// internals

	var scope = this;

	var EPS = 0.000001;
	var PIXELS_PER_ROUND = 1800;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var zoomStart = new THREE.Vector2();
	var zoomEnd = new THREE.Vector2();
	var zoomDelta = new THREE.Vector2();

	//mca
	var _eye 	= new THREE.Vector3(),
	_panStart 	= new THREE.Vector2(),
	_panEnd 	= new THREE.Vector2(),
	mouse 		= new THREE.Vector3(),
	projector 	= new THREE.Projector();

	//mca end
	var phiDelta = 0;
	var thetaDelta = 0;
	var scale = 1;

	var lastPosition = new THREE.Vector3();

	var STATE = { NONE : -1, ROTATE : 0, ZOOM : 1, PAN: 2 }; //mca 0=left, 1=middle or both, 2=right
	var state = STATE.NONE;

	// events

	var changeEvent = { type: 'change' };


	this.rotateLeft = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta -= angle;

	};

	this.rotateRight = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		thetaDelta += angle;

	};

	this.rotateUp = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta -= angle;

	};

	this.rotateDown = function ( angle ) {

		if ( angle === undefined ) {

			angle = getAutoRotationAngle();

		}

		phiDelta += angle;

	};

	this.zoomIn = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale /= zoomScale;

	};

	this.zoomOut = function ( zoomScale ) {

		if ( zoomScale === undefined ) {

			zoomScale = getZoomScale();

		}

		scale *= zoomScale;

	};
	
	//mca inserted from TrackballControls _this-->scope
	this.panCamera = function () {

		var mouseChange = _panEnd.clone().sub( _panStart );
		
		if ( mouseChange.lengthSq() ) {

			mouseChange.multiplyScalar( _eye.length() * scope.userPanSpeed );  //panSpeed

			// var pan = _eye.clone().cross( scope.object.up ).setLength( mouseChange.x );
			// pan.add( scope.object.up.clone().setLength( mouseChange.y ) );
			var pan = _eye.clone().cross( scope.object.up ).setLength( mouseChange.x );
			pan.sub( _eye.clone().cross( _eye.clone().cross( scope.object.up ) ).setLength( mouseChange.y ) ); //mca: don't pan along y axis, pan perpendicular to eye vector
			

			scope.object.position.add( pan );
			var oldCenter = scope.center.clone();
			scope.center.add( pan ); //target-->center

			_panStart = _panEnd;

		}

	};

	this.update = function () {
		
		if (state != STATE.PAN) {
		
			var position = this.object.position;
			var offset = position.clone().sub( this.center );
	
			// angle from z-axis around y-axis
	
			var theta = Math.atan2( offset.x, offset.z );
	
			// angle from y-axis
	
			var phi = Math.atan2( Math.sqrt( offset.x * offset.x + offset.z * offset.z ), offset.y );
	
			if ( this.autoRotate ) {
	
				this.rotateLeft( getAutoRotationAngle() );
	
			}
	
			theta += thetaDelta;
			phi += phiDelta;
	
			// restrict phi to be betwee EPS and PI-EPS
	
			phi = Math.max( EPS, Math.min( Math.PI - EPS, phi ) );
	
			var radius = offset.length();
			offset.x = radius * Math.sin( phi ) * Math.sin( theta );
			offset.y = radius * Math.cos( phi );
			offset.z = radius * Math.sin( phi ) * Math.cos( theta );
			//zoom perspective
			offset.multiplyScalar( scale );
			//zoom ortho; mca
			if(this.object.inOrthographicMode){
				this.object.toOrthographic();
			}
			
			
			position.copy( this.center ).add( offset );
	
			this.object.lookAt( this.center );
	
			thetaDelta = 0;
			phiDelta = 0;
			scale = 1;
		}
		//mca PAN target --> center
		else {
			_eye.copy( scope.object.position ).sub( scope.center );
			scope.panCamera();
			scope.object.position.addVectors( scope.center, _eye );
			//scope.object.lookAt( scope.center );
		}
		//mca end

		if ( lastPosition.distanceTo( this.object.position ) > 0 ) {
			/**
			 *@event change 
			 */
			this.dispatchEvent( changeEvent );
			lastPosition.copy( this.object.position );
		}

	}.bind(this);

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow( 0.95, scope.userZoomSpeed );

	}

	function onMouseDown( event ) {
		/**
		 *@event beforechange 
		 */
		scope.dispatchEvent({type:'beforechange'});
		
		if ( !scope.userRotate ) return;

		event.preventDefault();

		if ( event.button === STATE.ROTATE ){	//|| event.button === 2 ) {

			state = STATE.ROTATE;

			rotateStart.set( event.clientX, event.clientY );

		} else if ( event.button === STATE.ZOOM ) {

			state = STATE.ZOOM;

			zoomStart.set( event.clientX, event.clientY );

		} 
		//mca
		else if (event.button === STATE.PAN) {
			state = STATE.PAN;
			_panStart = _panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500);
		}

		document.addEventListener( 'mousemove', onMouseMove, false );
		document.addEventListener( 'mouseup', onMouseUp, false );

	}

	function onMouseMove( event ) {

		event.preventDefault();
		
		
		
		if ( state === STATE.ROTATE ) {

			rotateEnd.set( event.clientX, event.clientY );
			rotateDelta.subVectors( rotateEnd, rotateStart );

			scope.rotateLeft( 2 * Math.PI * rotateDelta.x / PIXELS_PER_ROUND * scope.userRotateSpeed );
			scope.rotateUp( 2 * Math.PI * rotateDelta.y / PIXELS_PER_ROUND * scope.userRotateSpeed );

			rotateStart.copy( rotateEnd );

		} else if ( state === STATE.ZOOM ) {

			zoomEnd.set( event.clientX, event.clientY );
			zoomDelta.subVectors( zoomEnd, zoomStart );

			if ( zoomDelta.y > 0 ) {

				scope.zoomIn();

			} else {

				scope.zoomOut();

			}

			zoomStart.copy( zoomEnd );

		}
		//mca
		else if ( state === STATE.PAN ) {
			_panEnd = new THREE.Vector2(event.clientX, event.clientY).multiplyScalar(1/500);
		};

	}

	function onMouseUp( event ) {

		if ( ! scope.userRotate ) return;

		document.removeEventListener( 'mousemove', onMouseMove, false );
		document.removeEventListener( 'mouseup', onMouseUp, false );

		state = STATE.NONE;
		/**
		 *@event afterchange 
		 */
		scope.dispatchEvent({type:'afterchange'});
	}

	function onMouseWheel( event ) {

		if ( ! scope.userZoom ) return;

		if ( ( event.wheelDelta && event.wheelDelta > 0 ) || ( event.detail && event.detail > 0 ) ) {

			scope.zoomOut();

		} else {

			scope.zoomIn();

		}

	}
	
	var onDoubleClick = function( event ){
		event.preventDefault();
		//get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		
		//only set if down and up coords are the same	
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
		var ray = projector.pickingRay(mouse, this.object);
		var pickables = this.scene.root.getDescendants().filter(function (e,i,a){return e.geometry;}); //@TODO currently all scene objects are pickable 
		var pickResults = ray.intersectObjects(pickables);
		
		var pickResult;
		for(var i=0; i < pickResults.length; i++){
			if(pickResults[i].object.geometry && pickResults[i].object.visible){
				pickResult = pickResults[i];
				break;
			};
		};
		if(pickResult){
			// this.deactivate();
			var _onCenter = function(event) {
				this.scene.removeEventListener("center", _onCenter);
				// this.activate();
				this.scene.addEventListener("beforeRender", this.update);
			}.bind(this);
			this.scene.addEventListener("center", _onCenter);
			this.scene.removeEventListener("beforeRender", this.update);
			this.scene.setCenter(pickResult.point,this.object.position.clone().sub(this.center),500);
			
		}	
	}.bind(this);
	
	var onCenter = function(event){
		  
		this.center = event.content.center;
		
	}.bind(this);
	
	var onChange = function(event){
		
		this.scene.center = event.target.center.clone();
		this.object.target.position.setZ(-this.object.position.distanceTo(event.target.center));
		
	};
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.center = this.scene.center.clone();//new THREE.Vector3();
		this.object.up.set(0,1,0);
		
		var dir= new THREE.Vector3(0,0,-1); //cameras default direction
		dir.applyQuaternion(this.object.quaternion); //cameras actual direction
		dir.normalize();
		
		//if(this.center.distanceTo(this.object.position)< 0.01){this.object.position.add(new THREE.Vector3(0,0,0.01));}
		if(this.center.distanceTo(this.object.position)< 0.01){this.object.position.sub(dir.multiplyScalar(0.01));}
		
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.addEventListener( 'mousedown', onMouseDown, false );
		this.domElement.addEventListener( 'mousewheel', onMouseWheel, false );
		this.domElement.addEventListener( 'DOMMouseScroll', onMouseWheel, false ); //Firefox
		this.domElement.addEventListener( 'dblclick', onDoubleClick, false ); 
		this.addEventListener('change', onChange);
		this.scene.addEventListener('center', onCenter);
		//hang in render loop
		this.scene.addEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		this.domElement.removeEventListener( 'mousewheel', onMouseWheel, false );
		this.domElement.removeEventListener( 'DOMMouseScroll', onMouseWheel, false ); //Firefox
		this.domElement.removeEventListener( 'dblclick', onDoubleClick, false ); 
		this.removeEventListener('change', onChange);
		this.scene.removeEventListener('center', onCenter);
		//remove from render loop
		this.scene.removeEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};


GIScene.Control.PanOrbitZoomCenter.prototype = Object.create( GIScene.Control.prototype );


/**
 * Control to freely move the camera around a target point. Rotates, zooms, pans.
 * 
 * @namespace GIScene
 * @class Control.Trackball
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 *
 * @author Eberhard Graether / http://egraether.com/
 * modified by m.auer
 */

GIScene.Control.Trackball = function ( object, domElement ) {

	GIScene.Control.call( this );

	var _this = this;
	var STATE = { NONE: -1, ROTATE: 0, ZOOM: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_ZOOM: 4, TOUCH_PAN: 5 };

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;

	// API

	this.enabled = true;

	this.screen = { left: 0, top: 0, width: 0, height: 0 };

	this.rotateSpeed = 1.0;//1.0;
	this.zoomSpeed = 1.2;
	this.panSpeed = 0.3;

	this.noRotate = false;
	this.noZoom = false;
	this.noPan = false;
	this.noRoll = true;

	this.staticMoving = true;
	this.dynamicDampingFactor = 0.2;

	this.minDistance = 0;
	this.maxDistance = Infinity;

	this.keys = [ 65 /*A*/, 83 /*S*/, 68 /*D*/ ];

	// internals

	this.target = new THREE.Vector3();

	var lastPosition = new THREE.Vector3();

	var _state = STATE.NONE,
	_prevState = STATE.NONE,

	_eye = new THREE.Vector3(),

	_rotateStart = new THREE.Vector3(),
	_rotateEnd = new THREE.Vector3(),

	_zoomStart = new THREE.Vector2(),
	_zoomEnd = new THREE.Vector2(),

	_touchZoomDistanceStart = 0,
	_touchZoomDistanceEnd = 0,

	_panStart = new THREE.Vector2(),
	_panEnd = new THREE.Vector2();

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();
	this.up0 = this.object.up.clone();

	// events

	var changeEvent = { type: 'change' };
	var startEvent = { type: 'start'};
	var endEvent = { type: 'end'};


	// methods

	this.handleResize = function () {

		if ( this.domElement === document ) {

			this.screen.left = 0;
			this.screen.top = 0;
			this.screen.width = window.innerWidth;
			this.screen.height = window.innerHeight;

		} else {

			this.screen = this.domElement.getBoundingClientRect();

		}

	};

	this.handleEvent = function ( event ) {

		if ( typeof this[ event.type ] == 'function' ) {

			this[ event.type ]( event );

		}

	};

	this.getMouseOnScreen = function ( clientX, clientY ) {

		return new THREE.Vector2(
			( clientX - _this.screen.left ) / _this.screen.width,
			( clientY - _this.screen.top ) / _this.screen.height
		);

	};

	this.getMouseProjectionOnBall = function ( clientX, clientY ) {

		var mouseOnBall = new THREE.Vector3(
			( clientX - _this.screen.width * 0.5 - _this.screen.left ) / (_this.screen.width*.5),
			( _this.screen.height * 0.5 + _this.screen.top - clientY ) / (_this.screen.height*.5),
			0.0
		);

		var length = mouseOnBall.length();

		if ( _this.noRoll ) {

			if ( length < Math.SQRT1_2 ) {

				mouseOnBall.z = Math.sqrt( 1.0 - length*length );

			} else {

				mouseOnBall.z = .5 / length;
				
			}

		} else if ( length > 1.0 ) {

			mouseOnBall.normalize();

		} else {

			mouseOnBall.z = Math.sqrt( 1.0 - length * length );

		}

		_eye.copy( _this.object.position ).sub( _this.target );

		var projection = _this.object.up.clone().setLength( mouseOnBall.y );
		projection.add( _this.object.up.clone().cross( _eye ).setLength( mouseOnBall.x ) );
		projection.add( _eye.setLength( mouseOnBall.z ) );

		return projection;

	};

	this.rotateCamera = function () {

		var angle = Math.acos( _rotateStart.dot( _rotateEnd ) / _rotateStart.length() / _rotateEnd.length() );

		if ( angle ) {

			var axis = ( new THREE.Vector3() ).crossVectors( _rotateStart, _rotateEnd ).normalize(),
				quaternion = new THREE.Quaternion();

			angle *= _this.rotateSpeed;

			quaternion.setFromAxisAngle( axis, -angle );

			_eye.applyQuaternion( quaternion );
			_this.object.up.applyQuaternion( quaternion );

			_rotateEnd.applyQuaternion( quaternion );

			if ( _this.staticMoving ) {

				_rotateStart.copy( _rotateEnd );

			} else {

				quaternion.setFromAxisAngle( axis, angle * ( _this.dynamicDampingFactor - 1.0 ) );
				_rotateStart.applyQuaternion( quaternion );

			}

		}

	};

	this.zoomCamera = function () {

		if ( _state === STATE.TOUCH_ZOOM ) {

			var factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;
			_touchZoomDistanceStart = _touchZoomDistanceEnd;
			_eye.multiplyScalar( factor );

		} else {

			var factor = 1.0 + ( _zoomEnd.y - _zoomStart.y ) * _this.zoomSpeed;

			if ( factor !== 1.0 && factor > 0.0 ) {

				_eye.multiplyScalar( factor );

				if ( _this.staticMoving ) {

					_zoomStart.copy( _zoomEnd );

				} else {

					_zoomStart.y += ( _zoomEnd.y - _zoomStart.y ) * this.dynamicDampingFactor;

				}

			}

		}

	};

	this.panCamera = function () {

		var mouseChange = _panEnd.clone().sub( _panStart );

		if ( mouseChange.lengthSq() ) {

			mouseChange.multiplyScalar( _eye.length() * _this.panSpeed );

			var pan = _eye.clone().cross( _this.object.up ).setLength( mouseChange.x );
			pan.add( _this.object.up.clone().setLength( mouseChange.y ) );

			_this.object.position.add( pan );
			_this.target.add( pan );

			if ( _this.staticMoving ) {

				_panStart = _panEnd;

			} else {

				_panStart.add( mouseChange.subVectors( _panEnd, _panStart ).multiplyScalar( _this.dynamicDampingFactor ) );

			}

		}

	};

	this.checkDistances = function () {

		if ( !_this.noZoom || !_this.noPan ) {

			if ( _eye.lengthSq() > _this.maxDistance * _this.maxDistance ) {

				_this.object.position.addVectors( _this.target, _eye.setLength( _this.maxDistance ) );

			}

			if ( _eye.lengthSq() < _this.minDistance * _this.minDistance ) {

				_this.object.position.addVectors( _this.target, _eye.setLength( _this.minDistance ) );

			}

		}

	};

	this.update = function () {

		_eye.subVectors( _this.object.position, _this.target );

		if ( !_this.noRotate ) {

			_this.rotateCamera();

		}

		if ( !_this.noZoom ) {

			_this.zoomCamera();

		}

		if ( !_this.noPan ) {

			_this.panCamera();

		}

		_this.object.position.addVectors( _this.target, _eye );

		_this.checkDistances();

		_this.object.lookAt( _this.target );

		if ( lastPosition.distanceToSquared( _this.object.position ) > 0 ) {

			_this.dispatchEvent( changeEvent );

			lastPosition.copy( _this.object.position );

		}

	};

	this.reset = function () {

		_state = STATE.NONE;
		_prevState = STATE.NONE;

		_this.target.copy( _this.target0 );
		_this.object.position.copy( _this.position0 );
		_this.object.up.copy( _this.up0 );

		_eye.subVectors( _this.object.position, _this.target );

		_this.object.lookAt( _this.target );

		_this.dispatchEvent( changeEvent );

		lastPosition.copy( _this.object.position );

	};

	// listeners

	function keydown( event ) {

		if ( _this.enabled === false ) return;

		window.removeEventListener( 'keydown', keydown );

		_prevState = _state;

		if ( _state !== STATE.NONE ) {

			return;

		} else if ( event.keyCode === _this.keys[ STATE.ROTATE ] && !_this.noRotate ) {

			_state = STATE.ROTATE;

		} else if ( event.keyCode === _this.keys[ STATE.ZOOM ] && !_this.noZoom ) {

			_state = STATE.ZOOM;

		} else if ( event.keyCode === _this.keys[ STATE.PAN ] && !_this.noPan ) {

			_state = STATE.PAN;

		}

	}

	function keyup( event ) {

		if ( _this.enabled === false ) return;

		_state = _prevState;

		window.addEventListener( 'keydown', keydown, false );

	}

	function mousedown( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		if ( _state === STATE.NONE ) {

			_state = event.button;

		}

		if ( _state === STATE.ROTATE && !_this.noRotate ) {

			_rotateStart = _this.getMouseProjectionOnBall( event.clientX, event.clientY );
			_rotateEnd.copy(_rotateStart);

		} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

			_zoomStart = _this.getMouseOnScreen( event.clientX, event.clientY );
			_zoomEnd.copy(_zoomStart);

		} else if ( _state === STATE.PAN && !_this.noPan ) {

			_panStart = _this.getMouseOnScreen( event.clientX, event.clientY );
			_panEnd.copy(_panStart);

		}

		document.addEventListener( 'mousemove', mousemove, false );
		document.addEventListener( 'mouseup', mouseup, false );
		_this.dispatchEvent( startEvent );


	}

	function mousemove( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		if ( _state === STATE.ROTATE && !_this.noRotate ) {

			_rotateEnd = _this.getMouseProjectionOnBall( event.clientX, event.clientY );

		} else if ( _state === STATE.ZOOM && !_this.noZoom ) {

			_zoomEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

		} else if ( _state === STATE.PAN && !_this.noPan ) {

			_panEnd = _this.getMouseOnScreen( event.clientX, event.clientY );

		}

	}

	function mouseup( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		_state = STATE.NONE;

		document.removeEventListener( 'mousemove', mousemove );
		document.removeEventListener( 'mouseup', mouseup );
		_this.dispatchEvent( endEvent );

	}

	function mousewheel( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		var delta = 0;

		if ( event.wheelDelta ) { // WebKit / Opera / Explorer 9

			delta = event.wheelDelta / 40;

		} else if ( event.detail ) { // Firefox

			delta = - event.detail / 3;

		}

		_zoomStart.y += delta * 0.01;
		_this.dispatchEvent( startEvent );
		_this.dispatchEvent( endEvent );

	}

	function touchstart( event ) {

		if ( _this.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:
				_state = STATE.TOUCH_ROTATE;
				_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

			case 2:
				_state = STATE.TOUCH_ZOOM;
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
				_touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt( dx * dx + dy * dy );
				break;

			case 3:
				_state = STATE.TOUCH_PAN;
				_panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

			default:
				_state = STATE.NONE;

		}
		_this.dispatchEvent( startEvent );


	}

	function touchmove( event ) {

		if ( _this.enabled === false ) return;

		event.preventDefault();
		event.stopPropagation();

		switch ( event.touches.length ) {

			case 1:
				_rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

			case 2:
				var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
				var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;
				_touchZoomDistanceEnd = Math.sqrt( dx * dx + dy * dy );
				break;

			case 3:
				_panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

			default:
				_state = STATE.NONE;

		}

	}

	function touchend( event ) {

		if ( _this.enabled === false ) return;

		switch ( event.touches.length ) {

			case 1:
				_rotateStart = _rotateEnd = _this.getMouseProjectionOnBall( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

			case 2:
				_touchZoomDistanceStart = _touchZoomDistanceEnd = 0;
				break;

			case 3:
				_panStart = _panEnd = _this.getMouseOnScreen( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );
				break;

		}

		_state = STATE.NONE;
		_this.dispatchEvent( endEvent );

	}

	var onCenter = function(event){
		// var positionFromCenter = (event.content.positionFromCenter.length() < 0.01)? new THREE.Vector3(0,0,0.01) : event.content.positionFromCenter;  
		this.target = event.content.center;
		// this.object.position = event.content.center.clone().add(positionFromCenter);
		// this.object.target.position = positionFromCenter.clone().multiplyScalar(-1);
	}.bind(this);
	
	var onChange = function(event){
		this.scene.center = event.target.target.clone();
		this.object.target.position.setZ(-this.object.position.distanceTo(event.target.target));
		//event.target.scene.setCenter(event.target.center);//, event.target.object.position.sub(event.target.center));
	};


	this.activate = function() {
		if(this.isActive) return;
		
		this.target = this.scene.center.clone();
	
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	
		this.domElement.addEventListener( 'mousedown', mousedown, false );
	
		this.domElement.addEventListener( 'mousewheel', mousewheel, false );
		this.domElement.addEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox
	
		this.domElement.addEventListener( 'touchstart', touchstart, false );
		this.domElement.addEventListener( 'touchend', touchend, false );
		this.domElement.addEventListener( 'touchmove', touchmove, false );
	
		window.addEventListener( 'keydown', keydown, false );
		window.addEventListener( 'keyup', keyup, false );
	
		this.handleResize();
		window.addEventListener( 'resize', this.handleResize, false );
		
		this.addEventListener('change', onChange);
		this.scene.addEventListener('center', onCenter);
		//hang in render loop
		this.scene.addEventListener("beforeRender", this.update);
		
		GIScene.Control.prototype.activate.call(this);
	};
	
	this.deactivate = function() {
		if(!this.isActive) return;
	
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
	
		this.domElement.removeEventListener( 'mousedown', mousedown, false );
	
		this.domElement.removeEventListener( 'mousewheel', mousewheel, false );
		this.domElement.removeEventListener( 'DOMMouseScroll', mousewheel, false ); // firefox
	
		this.domElement.removeEventListener( 'touchstart', touchstart, false );
		this.domElement.removeEventListener( 'touchend', touchend, false );
		this.domElement.removeEventListener( 'touchmove', touchmove, false );
	
		window.removeEventListener( 'keydown', keydown, false );
		window.removeEventListener( 'keyup', keyup, false );
		
		this.removeEventListener('change', onChange);
		this.scene.removeEventListener('center', onCenter);
		
		window.removeEventListener( 'resize', this.handleResize, false );
		
		//hang in render loop
		this.scene.removeEventListener("beforeRender", this.update);
	
		
		GIScene.Control.prototype.deactivate.call(this);
	};

};

GIScene.Control.Trackball.prototype = Object.create( GIScene.Control.prototype );

/**
 * Control to Fly over through a scene. 
 *
 * @namespace GIScene
 * @class Control.Fly
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 * 
 * 
 * @author James Baicoianu / http://www.baicoianu.com/
 * @author modified by m.auer
 * 
 */

GIScene.Control.Fly = function ( object, domElement ) {
	
	GIScene.Control.call( this );

	this.object = object;
	this.domElement = ( domElement !== undefined ) ? domElement : document;
	if ( domElement ) this.domElement.setAttribute( 'tabindex', -1 ); //focus domelement for key input

	// API
	
	this.center = null; //mca

	this.movementSpeed = 1.0;
	this.rollSpeed = 0.005;

	this.dragToLook = false;
	this.autoForward = false;

	// disable default target object behavior

	// internals

	this.tmpQuaternion = new THREE.Quaternion();

	this.mouseStatus = 0;

	this.moveState = { up: 0, down: 0, left: 0, right: 0, forward: 0, back: 0, pitchUp: 0, pitchDown: 0, yawLeft: 0, yawRight: 0, rollLeft: 0, rollRight: 0 };
	this.moveVector = new THREE.Vector3( 0, 0, 0 );
	this.rotationVector = new THREE.Vector3( 0, 0, 0 );

	// this.handleEvent = function ( event ) {
// 
		// if ( typeof this[ event.type ] == 'function' ) {
// 
			// this[ event.type ]( event );
// 
		// }
// 
	// };

	var keydown = function( event ) {

		if ( event.altKey ) {

			return;

		}

		//event.preventDefault();

		switch ( event.keyCode ) {

			case 16: /* shift */ this.movementSpeedMultiplier = .1; break;

			case 87: /*W*/ this.moveState.forward = 1; break;
			case 83: /*S*/ this.moveState.back = 1; break;

			case 65: /*A*/ this.moveState.left = 1; break;
			case 68: /*D*/ this.moveState.right = 1; break;

			case 82: /*R*/ this.moveState.up = 1; break;
			case 70: /*F*/ this.moveState.down = 1; break;

			case 38: /*up*/ this.moveState.pitchUp = 1; break;
			case 40: /*down*/ this.moveState.pitchDown = 1; break;

			case 37: /*left*/ this.moveState.yawLeft = 1; break;
			case 39: /*right*/ this.moveState.yawRight = 1; break;

			case 81: /*Q*/ this.moveState.rollLeft = 1; break;
			case 69: /*E*/ this.moveState.rollRight = 1; break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	}.bind(this);

	var keyup = function( event ) {

		switch( event.keyCode ) {

			case 16: /* shift */ this.movementSpeedMultiplier = 1; break;

			case 87: /*W*/ this.moveState.forward = 0; break;
			case 83: /*S*/ this.moveState.back = 0; break;

			case 65: /*A*/ this.moveState.left = 0; break;
			case 68: /*D*/ this.moveState.right = 0; break;

			case 82: /*R*/ this.moveState.up = 0; break;
			case 70: /*F*/ this.moveState.down = 0; break;

			case 38: /*up*/ this.moveState.pitchUp = 0; break;
			case 40: /*down*/ this.moveState.pitchDown = 0; break;

			case 37: /*left*/ this.moveState.yawLeft = 0; break;
			case 39: /*right*/ this.moveState.yawRight = 0; break;

			case 81: /*Q*/ this.moveState.rollLeft = 0; break;
			case 69: /*E*/ this.moveState.rollRight = 0; break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	}.bind(this);

	var mousedown = function( event ) {

		if ( this.domElement !== document ) {

			this.domElement.focus();

		}

		event.preventDefault();
		event.stopPropagation();

		if ( this.dragToLook ) {

			this.mouseStatus ++;

		} else {

			switch ( event.button ) {

				case 0: this.moveState.forward = 1; break;
				case 2: this.moveState.back = 1; break;

			}

			this.updateMovementVector();

		}

	}.bind(this);

	var mousemove = function( event ) {

		if ( !this.dragToLook || this.mouseStatus > 0 ) {

			var container = this.getContainerDimensions();
			var halfWidth  = container.size[ 0 ] / 2;
			var halfHeight = container.size[ 1 ] / 2;

			this.moveState.yawLeft   = - ( ( event.pageX - container.offset[ 0 ] ) - halfWidth  ) / halfWidth;
			this.moveState.pitchDown =   ( ( event.pageY - container.offset[ 1 ] ) - halfHeight ) / halfHeight;

			this.updateRotationVector();

		}

	}.bind(this);

	var mouseup = function( event ) {

		event.preventDefault();
		event.stopPropagation();

		if ( this.dragToLook ) {

			this.mouseStatus --;

			this.moveState.yawLeft = this.moveState.pitchDown = 0;

		} else {

			switch ( event.button ) {

				case 0: this.moveState.forward = 0; break;
				case 2: this.moveState.back = 0; break;

			}

			this.updateMovementVector();

		}

		this.updateRotationVector();

	}.bind(this);

	this.update = function() {
		console.log('FLY.update()');
		delta = this.scene.delta;
		console.log("delta", delta);
		var moveMult = delta * this.movementSpeed;
		var rotMult = delta * this.rollSpeed;

		this.object.translateX( this.moveVector.x * moveMult );
		this.object.translateY( this.moveVector.y * moveMult );
		this.object.translateZ( this.moveVector.z * moveMult );
		
		/**
		 *@event change 
		 */
		this.dispatchEvent( {type:'change'} );
		
		this.tmpQuaternion.set( this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1 ).normalize();
		this.object.quaternion.multiply( this.tmpQuaternion );

		// expose the rotation vector for convenience
		this.object.rotation.setFromQuaternion( this.object.quaternion, this.object.rotation.order );


	}.bind(this);

	this.updateMovementVector = function() {
console.log("FLY.updateMovementVector()");
		var forward = ( this.moveState.forward || ( this.autoForward && !this.moveState.back ) ) ? 1 : 0;

		this.moveVector.x = ( -this.moveState.left    + this.moveState.right );
		this.moveVector.y = ( -this.moveState.down    + this.moveState.up );
		this.moveVector.z = ( -forward + this.moveState.back );

		//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

	};

	this.updateRotationVector = function() {
console.log("FLY.updateRotationVector()");
		this.rotationVector.x = ( -this.moveState.pitchDown + this.moveState.pitchUp );
		this.rotationVector.y = ( -this.moveState.yawRight  + this.moveState.yawLeft );
		this.rotationVector.z = ( -this.moveState.rollRight + this.moveState.rollLeft );

		//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

	};

	this.getContainerDimensions = function() {

		if ( this.domElement != document ) {

			return {
				size	: [ this.domElement.offsetWidth, this.domElement.offsetHeight ],
				offset	: [ this.domElement.offsetLeft,  this.domElement.offsetTop ]
			};

		} else {

			return {
				size	: [ window.innerWidth, window.innerHeight ],
				offset	: [ 0, 0 ]
			};

		}

	};

	// function bind( scope, fn ) {
// 
		// return function () {
// 
			// fn.apply( scope, arguments );
// 
		// };
// 
	// };

	// this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
// 
	// this.domElement.addEventListener( 'mousemove', bind( this, this.mousemove ), false );
	// this.domElement.addEventListener( 'mousedown', bind( this, this.mousedown ), false );
	// this.domElement.addEventListener( 'mouseup',   bind( this, this.mouseup ), false );
// 
	// this.domElement.addEventListener( 'keydown', bind( this, this.keydown ), false );
	// this.domElement.addEventListener( 'keyup',   bind( this, this.keyup ), false );
// 
	// this.updateMovementVector();
	// this.updateRotationVector();
	
////////OLD PART

	
	var onCenter = function(event){
		  
		this.center = event.content.center;
		
	}.bind(this);
	
	var onChange = function(event){
		
		this.scene.center = event.target.center.clone();
		
		//camera and camera target are the same in this control
		//this.object.target.position.setZ(-this.object.position.distanceTo(event.target.center));
		
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.center = this.scene.center.clone();//new THREE.Vector3();
		//this.object.up.set(0,1,0);
		
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

		this.domElement.addEventListener( 'mousemove', mousemove, false );
		this.domElement.addEventListener( 'mousedown', mousedown, false );
		this.domElement.addEventListener( 'mouseup',   mouseup, false );
	
		this.domElement.addEventListener( 'keydown', keydown, false );
		this.domElement.addEventListener( 'keyup',   keyup, false );
		
		this.addEventListener('change', onChange);
		this.scene.addEventListener('center', onCenter);
	
		this.updateMovementVector();
		this.updateRotationVector();
		
		//hang in render loop
		this.scene.addEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

		this.domElement.removeEventListener( 'mousemove', mousemove, false );
		this.domElement.removeEventListener( 'mousedown', mousedown, false );
		this.domElement.removeEventListener( 'mouseup',   mouseup, false );
	
		this.domElement.removeEventListener( 'keydown', keydown, false );
		this.domElement.removeEventListener( 'keyup',   keyup, false );
		
		this.removeEventListener('change', onChange);
		this.scene.removeEventListener('center', onCenter);
		
		//hang in render loop
		this.scene.removeEventListener("beforeRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};


GIScene.Control.Fly.prototype = Object.create( GIScene.Control.prototype );


/**
 * Control to simulate walking. Use keybord controls.
 *
 * @namespace GIScene
 * @class Control.Walk
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} object The camera object to be used with this control
 * @param {DOMElement} [domElement] The DOM Element to which the mouse events will be added
 * 
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author paulirish / http://paulirish.com/
 * @author modified by m.auer
 */

GIScene.Control.Walk = function ( object, domElement ) {
	
	GIScene.Control.call( this );

	this.object = object;
	this.target = new THREE.Vector3( 0, 0, 0 );
	this.center = null;
	
	this.bodyPivot = null;//activate: new THREE.Object3D();//mca

	this.domElement = ( domElement !== undefined ) ? domElement : document;

	this.movementSpeed = 1.0*5;
	this.lookSpeed = 0.005*5;
	this.maxMovementSpeed = 100;
	this.minMovementSpeed = 0.01;
	
	this.jumpOffset = 1.0; //scene units, e.g. meters

	this.lookVertical = true;
	this.autoForward = false;
	// this.invertVertical = false;

	this.activeLook = false;//true; you get crazy when everything is moving all the time

	this.heightSpeed = false;
	this.heightCoef = 1.0;
	this.heightMin = 0.0;
	this.heightMax = 1.0;

	this.constrainVertical = false;
	this.verticalMin = 0;
	this.verticalMax = Math.PI;

	this.autoSpeedFactor = 0.0;

	// this.mouseX = 0;
	// this.mouseY = 0;
	var mouse = new THREE.Vector3();
	var projector 	= new THREE.Projector();
	
	this.mouseStart = new THREE.Vector2();
	this.mouseEnd = new THREE.Vector2();
	this.mouseDelta = new THREE.Vector2();

	this.lat = 0;
	this.oldLat = 0;
	this.lon = 0;
	this.phi = 0;
	this.theta = 0;

	this.moveForward = false;
	this.moveBackward = false;
	this.moveLeft = false;
	this.moveRight = false;
	this.freeze = false;

	this.mouseDragOn = false;

	this.viewHalfX = 0;
	this.viewHalfY = 0;

	if ( this.domElement !== document ) {

		this.domElement.setAttribute( 'tabindex', -1 );

	}

	//

	// this.handleResize = function () {
// 
		// if ( this.domElement === document ) {
// 
			// this.viewHalfX = window.innerWidth / 2;
			// this.viewHalfY = window.innerHeight / 2;
// 
		// } else {
// 
			// this.viewHalfX = this.domElement.offsetWidth / 2;
			// this.viewHalfY = this.domElement.offsetHeight / 2;
// 
		// }
// 
	// };

	this.onMouseDown = function ( event ) {

		document.addEventListener( 'mousemove', this.onMouseMove, false );

		if ( this.domElement !== document ) {

			this.domElement.focus();

		}

		event.preventDefault();
		event.stopPropagation();

		if ( this.activeLook ) {

			switch ( event.button ) {

				case 0: this.moveForward = true; break;
				case 2: this.moveBackward = true; break;

			}

		}

		this.mouseEnd.set( event.clientX, event.clientY ); //mca
		this.mouseStart.set( event.clientX, event.clientY ); //mca
		
		//update lat
		this.oldLat += this.lat;
		this.lat = 0;
		this.mouseDelta.set(0,0);//set(0,this.lat*5);

		this.mouseDragOn = true;
		
		

	}.bind(this);

	this.onMouseUp = function ( event ) {
		
		document.removeEventListener( 'mousemove', this.onMouseMove, false );

		event.preventDefault();
		event.stopPropagation();

		if ( this.activeLook ) {

			switch ( event.button ) {

				case 0: this.moveForward = false; break;
				case 2: this.moveBackward = false; break;

			}

		}

		this.mouseDragOn = false;
		
		//mca
		this.oldLat += this.lat;
		this.lat = 0;

	}.bind(this);

	this.onMouseMove = function ( event ) {

		// if ( this.domElement === document ) {
// 
			// this.mouseX = event.pageX - this.viewHalfX;
			// this.mouseY = event.pageY - this.viewHalfY;
// 
		// } else {
// 
			// this.mouseX = event.pageX - this.domElement.offsetLeft - this.viewHalfX;
			// this.mouseY = event.pageY - this.domElement.offsetTop - this.viewHalfY;
// 
		// }
		
		//mca
		this.mouseEnd.set( event.clientX, event.clientY ); //mca
		this.mouseDelta.subVectors(this.mouseEnd, this.mouseStart);//mca
		
	}.bind(this);

	this.onKeyDown = function ( event ) {

		//event.preventDefault();

		switch ( event.keyCode ) {

			case 73: /*I*/
			case 38: /*up*/this.moveForward = true; break;
			
			case 87: /*W*/ this.lookUp = true;break;

			case 74: /*J*/
			case 37: /*left*/ this.rotateLeft = true;break;
			
			case 65: /*A*/ this.moveLeft = true; break;

			case 75: /*K*/
			case 40: /*down*/this.moveBackward = true; break;
			
			case 83: /*S*/ this.lookDown = true; break;

			case 76: /*L*/
			case 39: /*right*/this.rotateRight = true; break;
			
			case 68: /*D*/ this.moveRight = true; break;

			case 82: /*R*/ this.moveUp = true; break;
			case 70: /*F*/ this.moveDown = true; break;

			case 81: /*Q*/ this.freeze = !this.freeze; break;
			
			//faster
			case 107:/*NUM+*/
			//FF
			case 171:/*+ (DEU, ESP)*/ 
			case 61: /*+ (US)*/ 
			//Chrome
			case 187: /*+ (DEU, US, ESP)*/
				this.movementSpeed = Math.min(this.movementSpeed *= 1.5, this.maxMovementSpeed);  break;
			
			//slower
			case 109:/*NUM-*/
			//FF(
			case 163:/*# */
			case 173:/*- (DEU, US, ESP)*/ 
			//Chrome
			case 191: /*# (DEU)*/
			case 189: /*- (DEU, US, ESP)*/
				this.movementSpeed = Math.max(this.movementSpeed /= 1.5, this.minMovementSpeed); break;

		}

	}.bind(this);

	this.onKeyUp = function ( event ) {

		switch( event.keyCode ) {
			
			case 73: /*I*/
			case 38: /*up*/this.moveForward = false; break;
			
			case 87: /*W*/ this.lookUp = false;break;

			case 74: /*J*/
			case 37: /*left*/this.rotateLeft = false;break;
			
			case 65: /*A*/ this.moveLeft = false; break;

			case 75: /*K*/
			case 40: /*down*/this.moveBackward = false; break;
			
			case 83: /*S*/ this.lookDown = false; break;

			case 76: /*L*/
			case 39: /*right*/this.rotateRight = false; break;
			
			case 68: /*D*/ this.moveRight = false; break;

			case 82: /*R*/ this.moveUp = false; break;
			case 70: /*F*/ this.moveDown = false; break;

		}

	}.bind(this);

	this.update = function( /*delta*/ ) {

		delta = this.scene.delta;
		
		if ( this.freeze ) {

			return;

		}

		if ( this.heightSpeed ) {

			var y = THREE.Math.clamp( this.object.position.y, this.heightMin, this.heightMax );
			var heightDelta = y - this.heightMin;

			this.autoSpeedFactor = delta * ( heightDelta * this.heightCoef );

		} else {

			this.autoSpeedFactor = 0.0;

		}

		var actualMoveSpeed = delta * this.movementSpeed;

		if ( this.moveForward || ( this.autoForward && !this.moveBackward ) ) this.bodyPivot.translateZ( - ( actualMoveSpeed + this.autoSpeedFactor ) );
		if ( this.moveBackward ) this.bodyPivot.translateZ( actualMoveSpeed );

		if ( this.moveLeft ) this.bodyPivot.translateX( - actualMoveSpeed );
		if ( this.moveRight ) this.bodyPivot.translateX( actualMoveSpeed );

		if ( this.moveUp ) this.bodyPivot.translateY( actualMoveSpeed );
		if ( this.moveDown ) this.bodyPivot.translateY( - actualMoveSpeed );

		var actualLookSpeed = delta * this.lookSpeed;

		if ( !this.activeLook ) {

			actualLookSpeed = 0;

		}

		var verticalLookRatio = 1;

		if ( this.constrainVertical ) {

			verticalLookRatio = Math.PI / ( this.verticalMax - this.verticalMin );

		}

		// this.lon += this.mouseX * actualLookSpeed;
		
		if( this.mouseDragOn && Math.abs(this.mouseDelta.x) > 5) {
			var dXSign = this.mouseDelta.x / Math.abs(this.mouseDelta.x);
			this.lon += dXSign * Math.min( (Math.abs(this.mouseDelta.x)-5) / 20, delta * this.lookSpeed *800);
		}
		if( this.rotateLeft  /* || (this.mouseDragOn && this.mouseDelta.x < 0 )*/ ) this.lon -= delta * this.lookSpeed *800;//2;//mca
		if( this.rotateRight /* || (this.mouseDragOn && this.mouseDelta.x > 0 )*/ ) this.lon += delta * this.lookSpeed *800;//2;//mca
		
		if( this.lookVertical && this.mouseDragOn) this.lat =  /*verticalLookRatio * */ this.mouseDelta.y / 5;
		if( this.lookVertical && this.lookUp) this.oldLat -= delta * this.lookSpeed *800;//2;//mca
		if( this.lookVertical && this.lookDown) this.oldLat += delta * this.lookSpeed *800;//2;//mca
		
		// if( this.lookVertical ) {
			// if()this.lat -= this.mouseY * actualLookSpeed * verticalLookRatio;	
		// }

		this.lat = Math.max( - 85, Math.min( 85, this.lat ) );
		this.phi = THREE.Math.degToRad( 90 /*- this.lat*/ );

		this.theta = THREE.Math.degToRad( this.lon );

		if ( this.constrainVertical ) {

			this.phi = THREE.Math.mapLinear( this.phi, 0, Math.PI, this.verticalMin, this.verticalMax );

		}

		var targetPosition = this.target,
			position = this.bodyPivot.position;

		targetPosition.x = position.x + 100 * Math.sin( this.phi ) * Math.cos( this.theta );
		targetPosition.y = position.y + 100 * Math.cos( this.phi );
		targetPosition.z = position.z + 100 * Math.sin( this.phi ) * Math.sin( this.theta );

		this.bodyPivot.lookAt( targetPosition );
		
		//apply position and horizontal rotation to camera
		
		this.object.position.copy(position);
		//this.object.quaternion.copy(this.bodyPivot.quaternion);
		
		//create vertical rotation
		var q = new THREE.Quaternion();
		q.setFromAxisAngle(new THREE.Vector3(1,0,0),THREE.Math.degToRad(-10 - this.oldLat - this.lat));
		//apply horiz and vert rotation
		this.object.quaternion.multiplyQuaternions(this.bodyPivot.quaternion, q);// multiply(q);
		
		
		//this.object.rotation.set(this.object.rotation.x,this.bodyPivot.rotation.y,this.object.rotation.z);
		
		// this.center.set(position.x, position.y, position.z);
		 
		/**
		 * Fires when camera position or rotation is changed 
		 *
		 *@event change 
		 */
		this.dispatchEvent({type:'change'});

	}.bind(this);
	
		var onDoubleClick = function( event ){
		event.preventDefault();
		//get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		
		//only set if down and up coords are the same	
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
		var ray = projector.pickingRay(mouse, this.object);
		var pickables = this.scene.root.getDescendants().filter(function (e,i,a){return e.geometry;}); //@TODO currently all scene objects are pickable 
		var pickResults = ray.intersectObjects(pickables);
		
		var pickResult;
		for(var i=0; i < pickResults.length; i++){
			if(pickResults[i].object.geometry && pickResults[i].object.visible){
				pickResult = pickResults[i];
				break;
			};
		};
		if(pickResult){
			
			// this.deactivate();
			var _onCenter = function(event) {
				this.scene.removeEventListener("center", _onCenter);
				// this.activate();
				this.scene.addEventListener("beforeRender", this.update);
			}.bind(this);
			this.scene.addEventListener("center", _onCenter);
			this.scene.removeEventListener("beforeRender", this.update);
			var offsetPoint = pickResult.point.clone().add(new THREE.Vector3(0,1,0));
			var offsetDir = this.object.position.clone().sub(offsetPoint).normalize();//keep a little distance from the picked point
			var newCenter = offsetPoint;//@TODO distfromfacenormal .add(offsetDir.clone().multiplyScalar(this.jumpOffset));
			// this.scene.center = this.center = newCenter.clone();
			
			this.scene.setCenter(newCenter, offsetDir.clone().multiplyScalar(this.jumpOffset),500);

			/**
			 * Fires when camera position or rotation is changed 
			 *
			 *@event change 
			 */
			this.dispatchEvent({type:'change'});
		}	
	}.bind(this);
	
////////OLD PART

	
	var onCenter = function(event){
		  
		this.center = event.content.center;
		
		
		this.bodyPivot.matrix.copy(this.object.matrixWorld); //mca
		this.bodyPivot.updateMatrixWorld();//mca
		this.bodyPivot.position.copy(this.object.position);
		this.bodyPivot.quaternion.setFromRotationMatrix(this.object.matrixWorld);
		
		
		// this.bodyPivot = this.object.clone();
		
		//keep former camera orientation
		var dir= new THREE.Vector3(0,0,-1); //cameras default direction
		var north= dir.clone();
		var up = new THREE.Vector3(0,1,0);
		dir.applyQuaternion(this.bodyPivot.quaternion); //cameras actual direction
		var dirOnPlane = dir.clone().projectOnPlane(up);
		var isEastside = (dirOnPlane.clone().cross(up).angleTo(north) > Math.PI/2) ? true : false;
		var angleToNorth = dirOnPlane.angleTo(north);
		var compassAngle = (isEastside) ? angleToNorth : Math.PI*2 - angleToNorth;
		var compassDegrees = THREE.Math.radToDeg(compassAngle);		
		
		this.lon = compassDegrees+90; // set former camera orientation
		this.lat = THREE.Math.radToDeg(dir.angleTo(this.scene.camera.up))-90-10-this.oldLat; // set former camera pitch

	}.bind(this);
	
	var onChange = function(event){
		
		this.center = this.object.localToWorld(this.object.target.position.clone());
		
		this.scene.center = this.center;//;event.target.center.clone();
		
		this.scene.dispatchEvent('cameraChange');
		//camera and camera target are the same in this control
		//this.object.target.position.setZ(-this.object.position.distanceTo(event.target.center));
		
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		//this.center = this.scene.camera.position.clone();//this.scene.center.clone();//new THREE.Vector3();
		this.scene.camera.target.position.setZ(-this.jumpOffset);
		this.center = this.scene.camera.localToWorld(this.scene.camera.target.position.clone());
		this.scene.setCenter(this.center, this.scene.camera.position.clone().sub(this.center), 0);
		
		this.bodyPivot = new THREE.Object3D();
		this.bodyPivot.applyMatrix(this.object.matrixWorld); //martixWorld?
		this.bodyPivot.matrixWorldNeedsUpdate = true;
		
		//keep former camera orientation
		var dir= new THREE.Vector3(0,0,-1); //cameras default direction
		var north= dir.clone();
		var up = new THREE.Vector3(0,1,0);
		dir.applyQuaternion(this.bodyPivot.quaternion); //cameras actual direction
		var dirOnPlane = dir.clone().projectOnPlane(up);
		var isEastside = (dirOnPlane.clone().cross(up).angleTo(north) > Math.PI/2) ? true : false;
		var angleToNorth = dirOnPlane.angleTo(north);
		var compassAngle = (isEastside) ? angleToNorth : Math.PI*2 - angleToNorth;
		var compassDegrees = THREE.Math.radToDeg(compassAngle);		
		
		this.lon = compassDegrees+90; // set former camera orientation
		this.lat = THREE.Math.radToDeg(dir.angleTo(this.scene.camera.up))-90-10-this.oldLat; // set former camera pitch
		
		//set eventListeners
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		//this.domElement.addEventListener( 'mousemove', this.onMouseMove, false );
		this.domElement.addEventListener( 'mousedown', this.onMouseDown, false );
		document.addEventListener( 'mouseup', this.onMouseUp, false );
		this.domElement.addEventListener( 'keydown', this.onKeyDown, false );
		this.domElement.addEventListener( 'keyup', this.onKeyUp, false );
		this.domElement.addEventListener( 'dblclick', onDoubleClick, false );
		
		this.addEventListener('change', onChange);
		this.scene.addEventListener('center', onCenter);
		
		//hang in render loop
		this.scene.addEventListener("beforeRender", this.update);
		// this.scene.addEventListener("afterRender", this.update);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );

		//this.domElement.removeEventListener( 'mousemove', this.onMouseMove, false );
		this.domElement.removeEventListener( 'mousedown', this.onMouseDown, false );
		document.removeEventListener( 'mouseup', this.onMouseUp, false );
		this.domElement.removeEventListener( 'keydown', this.onKeyDown, false );
		this.domElement.removeEventListener( 'keyup', this.onKeyUp, false );
		this.domElement.removeEventListener( 'dblclick', onDoubleClick, false );
		
		this.removeEventListener('change', onChange);
		this.scene.removeEventListener('center', onCenter);
		
		//hang in render loop
		this.scene.removeEventListener("beforeRender", this.update);
		// this.scene.removeEventListener("afterRender", this.update);
		
		//set camera and target
		// var dir= new THREE.Vector3(0,0,-1); //cameras default direction
		// dir.applyQuaternion(this.object.quaternion); //cameras actual direction
		// dir.normalize();
		// this.scene.center.add(dir); //add 1m offset between camera and scene center to make orbit cotrols work better after WALK
		// this.object.target.position.setZ(-1);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};


GIScene.Control.Walk.prototype = Object.create( GIScene.Control.prototype );


/**
 * A control which adds a sprite to the viewport for interactive movement of a directional light source.
 * The Light will always stay relative to the camera. This ensures to keep a chosen lighting angle while moving the camera.
 * Changing interactively the lighting angle gives the user a good impression of surface characteristics.
 * 
 * @namespace GIScene
 * @class Control.CameraLight
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} camera
 * @param {THREE.DirectionalLight} light 
 * @param {Object} [config] config.<properties> are: maxHorizontalAngle, maxVerticalAngle both Numbers in degrees between 0..90
 * 
 */

GIScene.Control.CameraLight = function (camera, light, config){
	
	//make this a control
	GIScene.Control.call(this);
	
	var defaults = {
		maxHorizontalAngle	: 65,
		maxVerticalAngle	: 65
	};
	
	/**
	 * The config which is used to initialize the CameraLight-Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	this.camera = camera;
	this.light = light || new THREE.DirectionalLight(0xffffff, 0.5);
	this.pivotLight = new THREE.Object3D();
	this.domElement = null; //will be set in this.activate()
	var degrees = new THREE.Vector2(0,0); //illumination angles
	
	this.maxHorizontalAngle	= this.config.maxHorizontalAngle; 
	this.maxVerticalAngle	= this.config.maxVerticalAngle;
	
	
	var STATE = { NONE : -1, PAN: 1 }; 
	var state = STATE.NONE;
	var isMouseover = false;
	
	
	//var spriteTexture = THREE.ImageUtils.loadTexture( GIScene.LIBRARYPATH + GIScene.RESOURCESPATH.replace(/([^\/])$/, "$1/") +"resources/images/sprite1.png" );
	// spriteTexture.flipY=false;
	var imgDataURL = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QTg5OEJENDc1ODUyMTFFMEExNjhDMjM3RjM1NjdBMkYiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QTg5OEJENDg1ODUyMTFFMEExNjhDMjM3RjM1NjdBMkYiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBODk4QkQ0NTU4NTIxMUUwQTE2OEMyMzdGMzU2N0EyRiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBODk4QkQ0NjU4NTIxMUUwQTE2OEMyMzdGMzU2N0EyRiIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PpQl4IgAABkpSURBVHja7F0JbFzH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";


	var spriteTexture = new THREE.Texture(null);
	var spriteImg = new Image();
		spriteImg.onload = function() {
			spriteTexture.image = spriteImg;
			spriteTexture.needsUpdate = true;
		};
		spriteImg.src = imgDataURL;
	
	var spriteMaterial = new THREE.SpriteMaterial({ map : spriteTexture, opacity:0.7  });
	this.sprite = new THREE.Sprite(spriteMaterial);
	this.sprite.scale.set( 50, 50, 1 );
	
	
	var panStart, panEnd, panDelta;
	
	/**
	 * Moves the UI graphic sprite and changes the light position accordingly
	 * 
	 * @method panSprite
	 * @param {THREE.Vector2()} panDelta A Vector used to translate the UI-graphic in Pixels  
	 */
	this.panSprite = function (panDelta) {
		
		var p = this.sprite.position;
		//pan sprite
		p.set(p.x+panDelta.x, p.y-panDelta.y, p.z);
		//move light		
		this.updateLightPosition();
		
	};
	
	/**
	 * Updates the light position to the correct angle according to sprite.position
	 * 
	 * @method updateLightPosition 
	 */
	this.updateLightPosition = function(){
		
		var normalizedDeviceCoordinate = this.sprite.position.clone();
		normalizedDeviceCoordinate.x /= this.scene.canvas.width/2;
		normalizedDeviceCoordinate.y /= this.scene.canvas.height/2;
		
		degrees = normalizedDeviceCoordinate.clone().set(normalizedDeviceCoordinate.x * this.maxHorizontalAngle, normalizedDeviceCoordinate.y * -this.maxVerticalAngle);
		this.pivotLight.rotation.set(THREE.Math.degToRad(degrees.y),THREE.Math.degToRad(degrees.x),0);
		
	};
	
	/**
	 * Returns the position of the light in polar angles relative to the light.target and the camera.position
	 * 
	 * @method getIlluminationAngles
	 * @return {Object} illuminationAngles an object with two properties: "theta" and "phi" containing the actual values in degrees
	 */
	this.getIlluminationAngles = function(){
		var illumAngles = {
			'theta' : degrees.x,
			'phi'	: degrees.y
		};
		return illumAngles;
	};
	
	// this.update = function () {
		// //currently not in use
	// };
	
	var onMouseDown = function(event){
		
		if(isMouseover){
			/**
			 * Fires on mouse down but before mouse moved
			 * 
			 * @event panstart 
			 */
			this.dispatchEvent( {type:'panstart'} );
			state = STATE.PAN;
			var relativeScreenCoords = GIScene.Utils.getRelativeScreenCoordsFromDOMEvent(this.domElement, event);
			panStart = relativeScreenCoords;
			
			this.domElement.addEventListener( 'mouseup', onMouseUp, false );
		}
	}.bind(this);
	
	var onMouseMove = function(event){
		
		var viewportCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement, event);
		viewportCoords.x *= this.scene.canvas.width/2;
		viewportCoords.y *= this.scene.canvas.height/2;
		
		var distance = viewportCoords.distanceTo(this.sprite.position);
		
		if (distance <= Math.max(this.sprite.scale.x, this.sprite.scale.y)/2){
			if(isMouseover == false){
				//over
				this.sprite.material.opacity = 1;
			}
			
			isMouseover = true;
			
		} else {
			if(isMouseover == true){
				//out
				this.sprite.material.opacity = 0.7;
			}
			isMouseover = false;
		}
		if (state == STATE.PAN){
			
			panEnd = GIScene.Utils.getRelativeScreenCoordsFromDOMEvent(this.domElement, event);
			panDelta = panEnd.clone().sub(panStart);
			this.panSprite(panDelta);
			panStart = panEnd;
			
			/**
			 * Fires while panning
			 * 
			 * @event pan
			 */
			this.dispatchEvent( {type:'pan'} );
		}
	}.bind(this);
	
	var onMouseUp = function(event){
		
		if(state == STATE.PAN){
			/**
			 * Fires on mouse up after a pan operation
			 * 
			 * @event panend 
			 */
			
			this.dispatchEvent( {type:'panend'} );
		}
		
		state = STATE.NONE;
		
		this.domElement.removeEventListener( 'mouseup', onMouseUp, false );
	}.bind(this);
	
	
	var onCameraChange = function(event){
		
		// var camTargetWorld = this.camera.localToWorld(this.camera.target.position.clone());
		// this.light.target.position = camTargetWorld;
		// this.light.position.setZ(this.camera.target.position.z);
		
		// this.light.position.setZ(this.camera.position.distanceTo(camTargetWorld));	
		// if(state != STATE.PAN)return; //@TODO Käs
		// this.light.target.position = camTargetWorld;
		
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		//var camTargetWorld = this.camera.target.parent.localToWorld(this.camera.target.position.clone());
		var camTargetWorld = new THREE.Vector3().getPositionFromMatrix(this.camera.target.matrixWorld);
		
		//reset pivot
		this.pivotLight.rotation.set(0,0,0);
		//pivot Light should be identical with camera target position. simply add it as child;
		this.camera.target.add(this.pivotLight);
		
		this.light.position.set(0,0,this.camera.position.distanceTo(camTargetWorld));
		this.pivotLight.add(this.light);
		
		//dont update light.target manually
		//this.light.target.position.copy(camTargetWorld); //= camTargetWorld.clone(); // this only works for OrbitZoomPan: this.scene.center;
		//instead add to cam target
		this.light.target.position.set(0,0,0);
		this.camera.target.add( this.light.target );
		
		this.domElement = this.scene.canvas;
		// var initialSpritePosition = GIScene.Utils.transformViewportCoordsToRelativeScreenCoords(new THREE.Vector2(0,0),this.domElement.offsetWidth, this.domElement.offsetHeight);
		// this.sprite.position.set(initialSpritePosition.x,initialSpritePosition.y,0);
		this.sprite.position.set(0,0,0);		this.scene.spriteRoot.add(this.sprite);
		
		//events
		this.domElement.addEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.addEventListener( 'mousemove', onMouseMove, false );
		this.domElement.addEventListener( 'mousedown', onMouseDown, false );
		
		//this.scene.addEventListener('cameraChange', onCameraChange);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.scene.spriteRoot.remove(this.sprite);
		
		//detach light.target from camera.target
		THREE.SceneUtils.detach(this.light.target, this.camera.target, this.scene.root);
		
		//detach light from pivot (keep last light world-position)
		THREE.SceneUtils.detach(this.light, this.light.parent, this.scene.root);
		
		
		//remove pivot from camera target
		this.camera.target.remove(this.pivotLight);
		
		
		this.domElement.removeEventListener( 'contextmenu', function ( event ) { event.preventDefault(); }, false );
		this.domElement.removeEventListener( 'mousemove', onMouseMove, false );
		this.domElement.removeEventListener( 'mousedown', onMouseDown, false );
		
		//this.scene.removeEventListener('cameraChange', onCameraChange);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
	
};

//Inherit from GIScene.Control
GIScene.Control.CameraLight.prototype = Object.create( GIScene.Control.prototype );/**
 * The Pick-Control lets you pick an Object by clicking. 
 * As a result you get the an Object containing various information on the clicked point or event.content == false.
 * 
 * The click-Event content looks like this:
 * 
 * 		{
 *  		distance: 	{Number in Scene units},
 *  		object:		{A reference to the clicked object},
 *  		face:		{A reference to the clicked face},
 *  		faceIndex:	{Index Number of the geomerty.faces Array},
 *  		point:		{The intersection point on the clicked face as THREE.Vector3}
 * 		}
 * 
 * @namespace GIScene
 * @class Control.Pick
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} camera
 * @param {Object} [config] Configuration properties. e.g. {color : new THREE.Color(0xff0000)}
 * 
 */

GIScene.Control.Pick = function(camera, config){
	//make this a control
	GIScene.Control.call(this);
	
	this.camera = camera;
	var defaults = {
		color: new THREE.Color( 0x00ff00 )
	};
	/**
	 * The config which is used to initialize the Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {}); 
	
	this.domElement = null; //will be set on activate
	this.pickables = [];	//must be set after objects/layers have been loaded
	var mouse = new THREE.Vector3(0,0,1);
	var projector = new THREE.Projector();
	var pickSymbol = THREE.ImageUtils.loadTexture( GIScene.LIBRARYPATH + GIScene.RESOURCESPATH.replace(/([^\/])$/, "$1/") +"resources/images/particle_cross.png");
	var resultsLayerConfig = {
		"layerGroup" : "User-generated"
	};
	var resultsLayer = new GIScene.Layer("Picked Coordinate", resultsLayerConfig);
	var pickedPointGeom = new THREE.Geometry();
	pickedPointGeom.vertices[0]=new THREE.Vector3(0,0,0);
	var pickedPointMaterial = new THREE.ParticleBasicMaterial({
												color:this.config.color,
												sizeAttenuation:false,
												size:32,
												map:pickSymbol,
												alphaTest:0.5	
											});
	var pickedPoint = new THREE.ParticleSystem(pickedPointGeom, pickedPointMaterial);
	pickedPoint.visible=false;
	resultsLayer.root.add(pickedPoint);
	
	var onMouseDown = function(event) {
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
	}.bind(this);
	
	var onMouseUp = function(event){
		//get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		
		//only set if down and up coords are the same
		if(mouse.equals(new THREE.Vector3().set(viewPortCoords.x, viewPortCoords.y, 1)) ){
			mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
			var ray = projector.pickingRay(mouse, this.camera);
			var pickResults = ray.intersectObjects(this.pickables);
			// var pickResult = (pickResults.length > 0) ? pickResults[0] : false;
			var pickResult;
			for(var i=0; i < pickResults.length; i++){
				if(pickResults[i].object.geometry && pickResults[i].object.visible){
					pickResult = pickResults[i];
					break;
				};
			};
			if(pickResult){
				this.drawPickResult(pickResult);
			}	
			/**
			 * The click event contains a content property with an result object or false
			 * 
			 * @event click
			 */
			//pickResult has the following properties: distance, face, faceIndex, object, point
			this.dispatchEvent({type:'click', content:pickResult});
			
		}
	}.bind(this);
	
	/**
	 * Draws a cross symbol to where the user has picked.
	 * 
	 * @method drawPickResult
	 * @param  {Object} pickResult A Raycaster intersect object 
	 */
	this.drawPickResult = function(pickResult) {
		pickedPoint.visible=true;
		var pickedPointCoords = pickResult.point;
		//create Layer for Result
		
		//create point object
		
		pickedPointGeom.vertices[0] = pickedPointCoords;
		pickedPointGeom.verticesNeedUpdate = true;
	
	
		
		
	};
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(!this.isActive){
			this.domElement = this.scene.canvas;
			resultsLayer.config.offset = this.scene.config.offset;
			this.scene.addLayer(resultsLayer);
			
			
			//eventListeners
			this.domElement.addEventListener('mousedown',onMouseDown, false);
			this.domElement.addEventListener('mouseup',onMouseUp, false);
			
			//call super class method
			GIScene.Control.prototype.activate.call(this);
		}
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		
		if(this.isActive){
			this.domElement.removeEventListener('mousedown',onMouseDown, false);
			this.domElement.removeEventListener('mouseup',onMouseUp, false);
			this.scene.removeLayer(resultsLayer);
			pickedPoint.visible=false;
			
			//call super class method
			GIScene.Control.prototype.deactivate.call(this);
		}
	};
	
};

//Inherit from GIScene.Control
GIScene.Control.Pick.prototype = Object.create( GIScene.Control.prototype );/**
 * The Measure-Control lets you pick two points of an Object by clicking. 
 * As a result you get the an Object containing the measured distance in scene units.
 * 
 * The measure-Event content looks like this:
 * 
 * 		{
 * 			distance: 			{Number in Scene units},
 * 			angleToNorth : 		{Number angle in degrees}
 * 		}
 * 
 * @namespace GIScene
 * @class Control.Measure
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} camera
 * @param {Object} [config] Configuration properties. e.g. {color : new THREE.Color(0xff0000)}
 * 
 */

GIScene.Control.Measure = function(camera, config){
	//make this a control
	GIScene.Control.call(this);
	
	this.camera = camera;
	var defaults = {
		color: new THREE.Color( 0xff0000 )
	};
	/**
	 * The config which is used to initialize the Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {}); 
	
	this.domElement = null; //will be set on activate
	this.measureables = [];	//must be set after objects/layers have been loaded
	var mouse = new THREE.Vector3(0,0,1);
	var projector = new THREE.Projector();
	var pickSymbol = null;
	var resultsLayer = null;
	var pickedPointMaterial = null;
	var measureLineMaterial = null;
	// var measureLineHiddenMaterial = null;
	// var foregroundScene = new THREE.Scene();
	
	// var onBeforeRender = function() {this.scene.renderer.clear();}.bind(this);
// 	
	// var onAfterRender = function() {
		// this.scene.renderer.clear( false, true, false );
		// this.scene.renderer.render( foregroundScene, this.camera );
	// }.bind(this);
	
	var onMouseDown = function(event) {
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
	}.bind(this);
	
	var onMouseUp = function(event){
		//get mouse ScreenCoords
		var viewPortCoords = GIScene.Utils.getViewportCoordsFromDOMEvent(this.domElement,event);
		
		//only set if down and up coords are the same
		if(mouse.equals(new THREE.Vector3().set(viewPortCoords.x, viewPortCoords.y, 1)) ){
			mouse.set(viewPortCoords.x, viewPortCoords.y, 1);
			var ray = projector.pickingRay(mouse, this.camera);
			var pickResults = ray.intersectObjects(this.measureables);
			var pickResult;
			for(var i=0; i < pickResults.length; i++){
				if(pickResults[i].object.geometry && pickResults[i].object.visible){
					pickResult = pickResults[i];
					break;
				};
			};
			if(pickResult){
				this.drawPickResult(pickResult);
			}
		}
	}.bind(this);
	
	/**
	 * Draws a cross symbol to where the user has picked and a connection line.
	 * 
	 * @method drawPickResult
	 * @param  {Object} pickResult A Raycaster intersect object 
	 */
	this.drawPickResult = function(pickResult) {
		
		if(resultsLayer.root.children.length<2){
			var pickedPointCoords = pickResult.point;
			//create point object
			pickedPointGeom = new THREE.Geometry();
			pickedPointGeom.vertices.push(pickedPointCoords);
		}
		
		if(resultsLayer.root.children.length==1){
			// set second point 
			var pickedPoint = new THREE.ParticleSystem(pickedPointGeom.clone(), pickedPointMaterial);
			resultsLayer.root.add(pickedPoint);
			
			//set measure Line
			var measureLineGeom = new THREE.Geometry();
			var measurePoint1 = resultsLayer.root.children[0].geometry.vertices[0];
			var measurePoint2 = resultsLayer.root.children[1].geometry.vertices[0];
			
			measureLineGeom.vertices.push(measurePoint1);
			measureLineGeom.vertices.push(measurePoint2);
			
			var measureLine = new THREE.Line(measureLineGeom, measureLineMaterial);
			resultsLayer.root.add(measureLine);
			
			// //draw in foreground
			// var measureLineHidden = new THREE.Line(measureLineGeom.clone(), measureLineHiddenMaterial);
			// foregroundScene.add(measureLineHidden);
			// this.scene.renderer.autoClear = false;
			// this.scene.addEventListener('beforeRender', onBeforeRender);
			// this.scene.addEventListener('afterRender', onAfterRender);
			
			//calc angle to v3 0,0,-1
			var north = new THREE.Vector3(0,0,-1);
			var mp2_2d = measurePoint2.clone().setY(0);
			var mp1_2d = measurePoint1.clone().setY(0);
			var measureDirection = mp2_2d.sub(mp1_2d);
			var isEastSide = (measureDirection.x >= 0)?true:false;
			var angle = north.angleTo(measureDirection);
			if(!isEastSide)angle = Math.PI*2 - angle;
			var angleDeg = THREE.Math.radToDeg(angle);
			
			var measureResult = {
				distance : measurePoint1.distanceTo(measurePoint2),
				angleToNorth : angleDeg
			};
			
			/**
			 * The measure event contains a content property with an result object
			 * 
			 * @event measure
			 */
			//pickResult has the following properties: distance, face, faceIndex, object, point
			this.dispatchEvent({type:'measure', content:measureResult});
		}
		
		if(resultsLayer.root.children.length==0){
			// set first point
			var pickedPoint = new THREE.ParticleSystem(pickedPointGeom.clone(), pickedPointMaterial);
			resultsLayer.root.add(pickedPoint);
		}
		
	};
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.domElement = this.scene.canvas;
		resulstLayerConfig = {
			offset : this.scene.config.offset,
			layerGroup : "User-generated"
		};
		resultsLayer = new GIScene.Layer("Measurements", resulstLayerConfig);
		this.scene.addLayer(resultsLayer);
		pickSymbol = THREE.ImageUtils.loadTexture( GIScene.LIBRARYPATH + GIScene.RESOURCESPATH.replace(/([^\/])$/, "$1/") +"resources/images/particle_cross.png");
		pickedPointMaterial = new THREE.ParticleBasicMaterial({
												color:this.config.color,
												sizeAttenuation:false,
												size:32,
												map:pickSymbol,
												alphaTest:0.5	
											});
		measureLineMaterial = new THREE.LineBasicMaterial({
												color: this.config.color,
												linewidth:1
											});
		// measureLineHiddenMaterial = new THREE.LineBasicMaterial({
												// color: new THREE.Color(0xff0000),
												// linewidth:1
											// });
											
		
		//eventListeners
		this.domElement.addEventListener('mousedown',onMouseDown, false);
		this.domElement.addEventListener('mouseup',onMouseUp, false);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.domElement.removeEventListener('mousedown',onMouseDown, false);
		this.domElement.removeEventListener('mouseup',onMouseUp, false);
		this.scene.disposeLayer(resultsLayer);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};

//Inherit from GIScene.Control
GIScene.Control.Measure.prototype = Object.create( GIScene.Control.prototype );/**
 * The LoadIndicator-Control provides visual feedback about the current state of loading activity.
 * 
 * @namespace GIScene
 * @class Control.LoadIndicator
 * @constructor
 * @extends GIScene.Control
 */

GIScene.Control.LoadIndicator = function(){
	//make this a control
	GIScene.Control.call(this);
	
	this.domElement = null; //will be set on activate
	
	this.indicatorElement = null; 
	
	var loaderCounter = 0;
	
	
	var createIndicatorElement = function() {
		var div = document.createElement('div');
		div.setAttribute('id','GIScene_LoadIndicator_wrapper');	
		div.setAttribute('style', 'bottom: 20px;font-family: Sans-serif;left: 50%;opacity: 1;position: absolute;text-shadow: 0 0 2px #000000;color:#FFFFFF;font-weight:bold;letter-spacing:2px;');
		div.textContent = 'Loading...';
		return div;
	};
	
	var onBeforeLoad = function() {
		if(loaderCounter==0){
			this.domElement.appendChild(this.indicatorElement);
		}
		loaderCounter++;
	}.bind(this);

	var onLoad = function() {
		loaderCounter--;
		if(loaderCounter==0){
			this.domElement.removeChild(this.indicatorElement);
		}
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.domElement = this.scene.containerDiv;
		this.indicatorElement = createIndicatorElement();									
		
		//eventListeners
		
		GIScene.ModelLoader.prototype.addEventListener('beforeLoad', onBeforeLoad);
		GIScene.ModelLoader.prototype.addEventListener('load', onLoad);
		GIScene.ModelLoader.prototype.addEventListener('abort', onLoad);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		GIScene.ModelLoader.prototype.removeEventListener('beforeLoad', onBeforeLoad);
		GIScene.ModelLoader.prototype.removeEventListener('load', onLoad);
		GIScene.ModelLoader.prototype.removeEventListener('abort', onLoad);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	
};

//Inherit from GIScene.Control
GIScene.Control.LoadIndicator.prototype = Object.create( GIScene.Control.prototype );/**
 * The Compass Control provides a graphical information on the current camera orientation, like a compass.
 * 
 * @namespace GIScene
 * @class Control.Compass
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} camera 
 */

GIScene.Control.Compass = function(camera, config) {
	
	//make this a control
	GIScene.Control.call(this);
	
	var defaults = {
		//positioning in px from canvas border
	};
	
	/**
	 * The config which is used to initialize the Compass-Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	
	this.camera = camera;
	
	var compassDegrees = 0;
	
	var windroseDataURL = "data:image/png;base64,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";
	
	
	var spriteTexture = new THREE.Texture(null);
	var windroseImg = new Image();
		windroseImg.onload = function() {
			spriteTexture.image = windroseImg;
			spriteTexture.needsUpdate = true;
		};
		windroseImg.src = windroseDataURL;
	
	// var spriteTexture = THREE.ImageUtils.loadTexture( GIScene.LIBRARYPATH + GIScene.RESOURCESPATH.replace(/([^\/])$/, "$1/") +"resources/images/windrose3.png" );

	var spriteMaterial = new THREE.SpriteMaterial({ map : spriteTexture, /*useScreenCoordinates:true,*/ opacity:1  });
	this.sprite = new THREE.Sprite(spriteMaterial);
	this.sprite.scale.set( 100, 100, 1 );
	// this.sprite.position.set(60,60,0);
	
	
	this.update = function() {
		//calc angle
		
		var ctp = this.camera.localToWorld(this.camera.target.position.clone());
		var cp = this.camera.position;
		var dir = ctp.sub(cp);
		var up = new THREE.Vector3(0,1,0);
		var north = new THREE.Vector3(0,0,-1);
		var dirOnPlane = dir.projectOnPlane(up);
		var isEastside = (dirOnPlane.clone().cross(up).angleTo(north) > Math.PI/2) ? true : false;
		var angleToNorth = dirOnPlane.angleTo(north);
		var compassAngle = (isEastside) ? angleToNorth : Math.PI*2 - angleToNorth;
		compassDegrees = THREE.Math.radToDeg(compassAngle);
		this.sprite.material.rotation = compassAngle;
		
	}.bind(this);
	
	/**
	 * Get Compass direction in degrees
	 * 
	 * @method getCompassDegrees 
	 * @return {Number} heading of compass in degrees
	 */
	
	this.getCompassDegrees = function() {
		return compassDegrees;
	};
	
	var onResize = function() {
		this.sprite.position.set((-this.scene.canvas.width/2)+60,(this.scene.canvas.height/2)-60,0);
	}.bind(this);
	
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.scene.spriteRoot.add(this.sprite);
		this.sprite.position.set((-this.scene.canvas.width/2)+60,(this.scene.canvas.height/2)-60,0);
		this.update();
		
		//eventListeners
		//hang in render loop
		this.scene.addEventListener("cameraChange", this.update);
		window.addEventListener('resize', onResize, false);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.scene.spriteRoot.remove(this.sprite);
		//remove from render loop
		this.scene.removeEventListener("cameraChange", this.update);
		window.removeEventListener('resize', onResize, false);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	

};
//Inherit from GIScene.Control
GIScene.Control.Compass.prototype = Object.create( GIScene.Control.prototype );
/**
 * The AxisHelper Control provides a graphical information on the current camera orientation in 3D space.
 * 
 * @namespace GIScene
 * @class Control.AxisHelper
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Camera} camera 
 * @param {Object} [config] you can configure the size with an config object {size:50}
 */

GIScene.Control.AxisHelper = function(camera, config) {
	
	//make this a control
	GIScene.Control.call(this);
	
	var defaults = {
		//positioning in px from canvas border
		size:50
	};
	
	/**
	 * The config which is used to initialize the AxisHelper-Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	this.camera = camera;
	this.axisHelper = new THREE.AxisHelper(this.config.size);
	
	var update = function() {
	
		this.axisHelper.rotation.setFromRotationMatrix(this.camera.matrixWorldInverse.extractRotation(this.camera.matrixWorldInverse));	
		
	}.bind(this);
	
	var onResize = function() {
		
		this.axisHelper.position.set((-this.scene.canvas.width/2)+60,(-this.scene.canvas.height/2)+60,0);
	
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.scene.spriteRoot.add(this.axisHelper);
		this.axisHelper.position.set((-this.scene.canvas.width/2)+60,(-this.scene.canvas.height/2)+60,0);

		update();
		
		//eventListeners
		//hang in render loop
		this.scene.addEventListener("cameraChange", update);
		window.addEventListener('resize', onResize, false);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.scene.spriteRoot.remove(this.axisHelper);
		
		//remove from render loop
		this.scene.removeEventListener("cameraChange", update);
		window.removeEventListener('resize', onResize, false);
 		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	

};
//Inherit from GIScene.Control
GIScene.Control.AxisHelper.prototype = Object.create( GIScene.Control.prototype );
/**
 * The Compass Control provides a panel on which you can add text.
 * 
 * @namespace GIScene
 * @class Control.TextPanel
 * @constructor
 * @extends GIScene.Control
 * @param {Object} [config] object properties may be: width, height, text:['Line1','Line2'], textAlign:'left|start|center|end|right', pxFromLeft, pxFromTop, fontSize, lineSpace, fontFamily, fontStyle, color, halo
 */

GIScene.Control.TextPanel = function(config) {
	
	//make this a control
	GIScene.Control.call(this);
	
	var defaults = {
		width:256,
		height:100,
		text: ['Hello World','Zeile 2'],
		textAlign: 'start',
		pxFromLeft:0,
		pxFromTop :400,
		fontSize: 10,
		lineSpace :6,
		fontFamily: 'sans-serif',
		fontStyle: 'normal',
		color: 'ivory',
		halo: 'black'
	};
	
	/**
	 * The config which is used to initialize the CameraLight-Control. Merged from defaults and passed config Object.
	 * 
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	this.height = this.config.height;
	var text = (this.config.text instanceof Array)? this.config.text : [this.config.text];
	var numLines = text.length;
	var horizontalOffset = (this.config.textAlign == 'left' || this.config.textAlign == 'start')? 0 : (this.config.textAlign == 'center')? this.config.width/2 : this.config.width; //last case is 'right' or 'end'	
	
	this.canvas2d = document.createElement('canvas');
	this.canvas2d.width = this.config.width;
	this.canvas2d.height = this.height;
	this.context2d = this.canvas2d.getContext('2d');
	this.context2d.textBaseline = 'middle';
	this.context2d.font = this.config.fontStyle + ' ' + this.config.fontSize + 'pt ' + this.config.fontFamily;
	// this.context2d.lineWidth = 0.5;
	this.context2d.textAlign = this.config.textAlign;
	this.context2d.fillStyle = this.config.color;
	this.context2d.shadowColor = this.config.halo;
	this.context2d.shadowBlur = 3;
	
	this.texture = new THREE.Texture(this.canvas2d);
	// this.texture.flipY = false;
	
	
	var spriteMaterial = new THREE.SpriteMaterial({ map : this.texture, opacity:1  });
	this.sprite = new THREE.Sprite(spriteMaterial);
	this.sprite.scale.set( this.config.width, this.height, 1 );
	// this.sprite.position.set((-this.scene.canvas.width/2) + this.config.width/2 + this.config.pxFromLeft,this.config.pxFromTop, 0);
	
	this.update = function() {
		this.context2d.clearRect(0,0,this.config.width, this.height);
		//render lines
		for (var i=0; i < numLines; i++){
			this.context2d.fillText(text[i], horizontalOffset,this.height/2 - ((numLines-1)*(this.config.fontSize + this.config.lineSpace)/2) + i*(this.config.fontSize + this.config.lineSpace));
		}
		this.texture.needsUpdate=true;
	}.bind(this);
	
	this.setText = function(newText) {
		text = (newText instanceof Array)? newText : [newText];
		numLines = text.length;
		this.update();
	}.bind(this);
	
	/**
	 * Activates this Control
	 * 
	 * @method activate
	 *  
	 */
	this.activate = function(){
		if(this.isActive) return;
		
		this.scene.spriteRoot.add(this.sprite);
		this.sprite.position.set((-this.scene.canvas.width/2) + this.config.width/2 + this.config.pxFromLeft,this.config.pxFromTop, 0);
		this.texture.needsUpdate=true;
		this.update();
		//eventListeners
		//hang in render loop
		// this.scene.addEventListener("cameraChange", this.update);
		
		//call super class method
		GIScene.Control.prototype.activate.call(this);
	};
	
	/**
	 * Deactivates this Control
	 * 
	 * @method deactivate
	 *  
	 */
	this.deactivate = function(){
		if(!this.isActive) return;
		
		this.scene.spriteRoot.remove(this.sprite);
		//remove from render loop
		//this.scene.removeEventListener("cameraChange", this.update);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	};
	

};
//Inherit from GIScene.Control
GIScene.Control.TextPanel.prototype = Object.create( GIScene.Control.prototype );
/**
 * This Control diplays the Object position coordinates in a TextPanel
 * 
 * @namespace GIScene
 * @class Control.ObjectPosition
 * @constructor
 * @extends GIScene.Control
 * @param {THREE.Object3D} object
 */

GIScene.Control.ObjectPosition = function(object) {
	
	//make this a control
	GIScene.Control.call(this);
	
	//this.domElement = null;
	this.object = object;
	this.height = 3*18;
	this.textPanel = new GIScene.Control.TextPanel(
		{
			height: this.height,
			width : 200,
			textAlign: 'left',
			pxFromLeft:10,
			fontSize:10,
			//pxFromTop: this.scene.canvas.height - this.height
		}
	);
	
	this.updateCoords = function() {
		var a = [];
		this.object.position.clone().add(this.scene.config.offset.toVector3()).toArray().forEach(function (el) {
		  a.push(el.toFixed(3));
		});
		this.textPanel.setText(['Height: '+a[1],'X Y: '+a[0]+' '+ -a[2]]);
	}.bind(this);
	
	var onResize = function() {
		// this.textPanel.sprite.position.setY((-this.scene.canvas.height/2) + (this.height/2));
		this.textPanel.sprite.position.set((-this.scene.canvas.width/2) + this.textPanel.config.width/2 + this.textPanel.config.pxFromLeft,(-this.scene.canvas.height/2) + (this.height/2), 0);
	}.bind(this); 


	this.activate = function() {
		if(this.isActive) return;
		
		this.textPanel.setScene(this.scene),
		this.textPanel.activate();
		// this.textPanel.sprite.position.setY((-this.scene.canvas.height/2) + (this.height/2));
		this.textPanel.sprite.position.set((-this.scene.canvas.width/2) + this.textPanel.config.width/2 + this.textPanel.config.pxFromLeft,(-this.scene.canvas.height/2) + (this.height/2), 0);
		
		this.scene.addEventListener('cameraChange', this.updateCoords);
		window.addEventListener('resize', onResize, false);
		
		GIScene.Control.prototype.activate.call(this);
	};
	
	this.deactivate = function() {
		if(!this.isActive) return;
		
		this.textPanel.deactivate();
		this.scene.removeEventListener('cameraChange', this.updateCoords);
		window.removeEventListener('resize', onResize, false);
		
		GIScene.Control.prototype.deactivate.call(this);
	};
};

//Inherit from GIScene.Control
GIScene.Control.ObjectPosition.prototype = Object.create( GIScene.Control.prototype );/**
 * This Control enables to render a Scene with a Screen Space Ambient Occlusion (SSAO) effect.
 * 
 * @namespace GIScene
 * @class Control.SSAO
 * @constructor
 * @extends GIScene.Control
 */
GIScene.Control.SSAO = function() {
	
	//inherit
	GIScene.Control.call(this);
	
	var scenePass;
	var ssaoEffect;
	var fxaaEffect;
	var depthTarget;
	var depthShader;
	var depthUniforms;
	var depthMaterial;
	var depthCam;
	var activeCam;
	
	var updateDepthCam = function() {
		
		// if(depthCam !== undefined && depthCam.parent !== undefined){
			// this.scene.camera.remove(depthCam);
		// }
		
		//depthCam
		activeCam = (this.scene.camera instanceof THREE.CombinedCamera)? 
							( (this.scene.camera.inPerspectiveMode)? this.scene.camera.cameraP : this.scene.camera.cameraO ) 
						: 
							this.scene.camera;
						
		depthCam = activeCam.clone();
		this.scene.camera.add(depthCam);
		
		// depthCam = new THREE.PerspectiveCamera();
		// //POSITION
		// depthCam.fov	= activeCam.fov;
		// depthCam.aspect = activeCam.aspect;
		depthCam.near	= 0.1;
		depthCam.far	= 1000;
		depthCam.updateProjectionMatrix();
		//console.log(depthCam);
		//updateSsaoUniforms();//mca
		
	}.bind(this);
	
	var updateSsaoUniforms = function() {
		ssaoEffect.uniforms[ 'tDepth' ].value = depthTarget;
		ssaoEffect.uniforms[ 'size' ].value.x = this.scene.canvas.width;
		ssaoEffect.uniforms[ 'size' ].value.y = this.scene.canvas.height;
		ssaoEffect.uniforms[ 'cameraNear' ].value = depthCam.near;
		ssaoEffect.uniforms[ 'cameraFar' ].value = depthCam.far;
	}.bind(this);
	
	var onBeforeRender = function() {
// activeCam = (this.scene.camera instanceof THREE.CombinedCamera)? 
							// ( (this.scene.camera.inPerspectiveMode)? this.scene.camera.cameraP : this.scene.camera.cameraO ) 
						// : 
							// this.scene.camera;
		// activeCam = this.scene.camera.cameraP.clone();
// 							
		this.scene.root.overrideMaterial = depthMaterial;//new THREE.MeshDepthMaterial({blending: THREE.NoBlending});
		// activeCam.near = 0.1;
		// activeCam.far = 1500;
		// activeCam.updateProjectionMatrix();
		this.scene.renderer.clearTarget(depthTarget,true, true, false); //color, depth, stencil
		this.scene.renderer.render(this.scene.root, depthCam, depthTarget);
		
		// activeCam.near = this.scene.config.near;
		// activeCam.far = this.scene.config.far;
		// activeCam.updateProjectionMatrix();
		this.scene.root.overrideMaterial = null;
// 		
		// this.scene.root.overrideMaterial = null;

	}.bind(this); 
	
	var onChangedProjection = function(event) {
		console.log("chPrj2",activeCam);
		updateDepthCam();
		
	};
	
	var onResize = function() {
		
		updateDepthCam();
		depthTarget = new THREE.WebGLRenderTarget( this.scene.canvas.width, this.scene.canvas.height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
		updateSsaoUniforms();
		fxaaEffect.uniforms[ 'resolution' ].value.set( 1 / this.scene.canvas.width, 1 / this.scene.canvas.height );
		
	}.bind(this);
	
	this.activate_ = function() {
		if(!this.isActive){


		scenePass = new THREE.RenderPass( this.scene.root, this.scene.camera );
		ssaoEffect = new THREE.ShaderPass( THREE.SSAOShader );
		
		depthTarget = new THREE.WebGLRenderTarget( this.scene.canvas.width, this.scene.canvas.height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
		depthShader = THREE.ShaderLib[ "depthRGBA" ];
		depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
		depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		depthMaterial.blending = THREE.NoBlending;
		
		this.scene.addEventListener('beforeRender', onBeforeRender);
					// function(){
		// 		
					// this.scene.root.overrideMaterial = depthMaterial;//new THREE.MeshDepthMaterial({blending: THREE.NoBlending});
					// this.scene.camera.cameraP.near = 0.1;
					// this.scene.camera.cameraP.far = 1500;
					// this.scene.camera.cameraP.updateProjectionMatrix();
					// this.scene.renderer.clearTarget(depthTarget,true, true, true);
					// this.scene.renderer.render(this.scene.root, this.scene.camera, depthTarget);
		// 			
					// this.scene.camera.cameraP.near = this.scene.config.near;
					// this.scene.camera.cameraP.far = this.scene.config.far;
					// this.scene.camera.cameraP.updateProjectionMatrix();
					// this.scene.root.overrideMaterial = null;
		// 		
				// }.bind(this)
			// );
			
		ssaoEffect.uniforms[ 'tDepth' ].value = depthTarget;
		ssaoEffect.uniforms[ 'size' ].value.x = this.scene.canvas.width;
		ssaoEffect.uniforms[ 'size' ].value.y = this.scene.canvas.height;
		ssaoEffect.uniforms[ 'cameraNear' ].value = this.scene.camera.near;
		ssaoEffect.uniforms[ 'cameraFar' ].value = this.scene.camera.far;
		ssaoEffect.uniforms[ 'onlyAO' ].value = 1;
		ssaoEffect.renderToScreen = true;
		
		this.scene.effectComposer.addPass(scenePass);
		this.scene.effectComposer.addPass(ssaoEffect);

}

			//call super class method
			GIScene.Control.prototype.activate.call(this);
	};
	
	this.activate = function() {
		if(!this.isActive){
			
			//depth map
			depthTarget = new THREE.WebGLRenderTarget( this.scene.canvas.width, this.scene.canvas.height, { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat } );
				depthShader = THREE.ShaderLib[ "depthRGBA" ];
				depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
			depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
				depthMaterial.blending = THREE.NoBlending;
			
			//depthCam
			updateDepthCam();
			
			//define passes
			scenePass  = new THREE.RenderPass( this.scene.root, this.scene.camera );
			ssaoEffect = new THREE.ShaderPass( THREE.SSAOShader );
			fxaaEffect = new THREE.ShaderPass( THREE.FXAAShader );
		
			updateSsaoUniforms();
			ssaoEffect.renderToScreen = true;
			fxaaEffect.uniforms[ 'resolution' ].value.set( 1 / this.scene.canvas.width, 1 / this.scene.canvas.height );
			fxaaEffect.renderToScreen = false;
			//add beforeRender Event
			this.scene.addEventListener('beforeRender2', onBeforeRender);
		
			//be sure, there are no other passes active
			//add passes
			this.scene.effectComposer.passes = [scenePass, fxaaEffect, ssaoEffect];
			// this.scene.effectComposer.addPass(scenePass);
			// this.scene.effectComposer.addPass(ssaoEffect);
			
			
			
			//add other events
			window.addEventListener('resize', onResize, false);
			this.scene.camera.addEventListener('changedProjection', onChangedProjection);
			
			//call super class method
			GIScene.Control.prototype.activate.call(this);
		}
	};
	
	this.deactivate = function() {
	if(this.isActive){
		
		//remove passes
		this.scene.effectComposer.passes = [];
		
		//remove depthCam
		this.scene.camera.remove(depthCam);
		
		//remove Events
		this.scene.removeEventListener('beforeRender2', onBeforeRender);
		window.removeEventListener('resize', onResize, false);
		this.scene.camera.removeEventListener('changedProjection', onChangedProjection);
		
		//call super class method
		GIScene.Control.prototype.deactivate.call(this);
	}
	};
	
};

GIScene.Control.SSAO.prototype = Object.create(GIScene.Control.prototype);/**
 * Edge Detection Control to render scenes with FreiChen Filter 
 * 
 * @namespace GIScene
 * @class Control.EdgeDetectionFreiChen
 * @constructor
 * @extends GIScene.Control
 */

GIScene.Control.EdgeDetectionFreiChen = function() {
	
	//inherit
	GIScene.Control.call(this);
	
	var scenePass = null;
	var edgeEffect = null;
	var intensity = 1.0; // 0.0 ... 1.0
	var invert = 1.0; //black on white 0.0 || 1.0
	var threshold = 0.5; // 0.0 ... 1.0
	
	var onResize = function() {
		
		edgeEffect.uniforms[ 'aspect' ].value.set(this.scene.canvas.width,this.scene.canvas.height);
		fxaaEffect.uniforms[ 'resolution' ].value.set( 1 / this.scene.canvas.width, 1 / this.scene.canvas.height );
		
	}.bind(this);
	
	this.setIntensity = function(value) {
		intensity = value;
		if(edgeEffect){edgeEffect.uniforms[ 'intensity' ].value = intensity;}
	};
	
	this.getIntensity = function() {
		return intensity;
	};
	
	this.setThreshold = function(value){
		threshold = value;
		if(edgeEffect){edgeEffect.uniforms[ 'threshold' ].value = threshold;}
	};
	
	this.getThreshold = function() {
		return threshold;
	};
	
	this.invert = function() {
		invert = (invert == 1.0)? 0.0 : 1.0;
		if(edgeEffect){edgeEffect.uniforms[ 'invert' ].value = invert;}
	};
	
	this.activate = function() {
		if(!this.isActive){
depthShader = THREE.ShaderLib[ "depthRGBA" ];
		depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );
		depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		depthMaterial.blending = THREE.NoBlending;
		// depthMaterial.uniforms.mNear.value = 0.1;
		// depthMaterial.uniforms.mFar.value = 1;
		
			scenePass = new THREE.RenderPass( this.scene.root, this.scene.camera /*, depthMaterial*/ );
			
			unpackDepthRGBAEffect = new THREE.ShaderPass( THREE.UnpackDepthRGBAShader );
			unpackDepthRGBAEffect.renderToScreen = false;
			
			edgeEffect = new THREE.ShaderPass( THREE.EdgeShader );
			edgeEffect.uniforms[ 'aspect' ].value.set(this.scene.canvas.width,this.scene.canvas.height);
			edgeEffect.uniforms[ 'intensity' ].value = intensity;
			edgeEffect.uniforms[ 'invert' ].value = invert;
			edgeEffect.uniforms[ 'threshold' ].value = threshold;
			edgeEffect.renderToScreen = false;
			
			fxaaEffect = new THREE.ShaderPass( THREE.FXAAShader );
			fxaaEffect.uniforms[ 'resolution' ].value.set( 1 / this.scene.canvas.width, 1 / this.scene.canvas.height );
			fxaaEffect.renderToScreen = true;
			
			this.scene.effectComposer.addPass(scenePass);
			//this.scene.effectComposer.addPass(unpackDepthRGBAEffect);
			this.scene.effectComposer.addPass(edgeEffect);
			this.scene.effectComposer.addPass(fxaaEffect);
			
			//register events
			window.addEventListener('resize', onResize, false);
			
			//call super class method
			GIScene.Control.prototype.activate.call(this);
			
		}
	};
		
	this.deactivate = function() {
		if(this.isActive){
			
			//remove passes
			this.scene.effectComposer.passes = [];
			
			//remove Events
			window.removeEventListener('resize', onResize, false);
			
			
			//call super class method
			GIScene.Control.prototype.deactivate.call(this);
		}
	};
	
};

GIScene.Control.EdgeDetectionFreiChen.prototype = Object.create(GIScene.Control.prototype);
/**
 * Base class for processes
 * 
 * @namespace GIScene
 * @class Process
 * @constructor 
 * @param {Object} config
 * 
 * @author mcauer https://github.com/mcauer
 */

GIScene.Process = function(config){
	
	var defaults = {
		identifier		: null,
		title			: null,
		abstract		: null,
		metadata		: null,
		processVersion 	: null,
		description		: 	{
								inputs:[],
								outputs:[]
							}
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, config || {}); 
	
	this.identifier = this.config.identifier;
	this.title		= this.config.title;
	this.abstract	= this.config.abstract;
	this.metadata	= this.config.metadata;
	this.processVersion = this.config.processVersion;
	this.description	= this.config.description;
	
	this.data = {
		inputs:{},
		outputs:{}
	};



};

GIScene.Process.prototype = {
	
	constructor : GIScene.Process,
	
	/**
	 * Method to set a specific input parameter
	 * 
	 * @method setInput 
 	 * @param {String} inputIdentifier the inputIdentifier defined in the process description
 	 * @param {Mixed} value the value of the input to be set
	 */
	setInput : function(inputIdentifier, value) {
		this.data.inputs[inputIdentifier] = value;
	},	
	
	/**
	 * Method to set several inputs at a time
	 *
	 * @method setInputs 
 	 * @param {Object} inputParams An object with key:value pairs of input parameters, where key corresponds to the inputIdentifiers defined in the process description
	 */
	setInputs : function(inputParams) {
		for(param in inputParams){
			this.setInput(param, inputParams[param]);
		}
	},
	
	/**
	 * Method to get a specific output result after process execution
	 *  
 	 * @method getOutput
 	 * @param {Object} outputIdentifier
 	 * @return {Mixed} an output value of the process
	 */
	getOutput : function(outputIdentifier){
		return this.data.outputs[outputIdentifier];
	},
	
	/**
	 * Method to get all process outputs after process execution 
	 * 
	 * @method getOutputs
	 * @return {Object} An object containing all process outputs
	 */
	getOutputs : function(){
		return this.data.outputs;
	},
	
	/**
	 * Get a param desription (input or ouput) by its identifier
	 * 
	 * @method  getParamDescriptionById
	 * @param {String} identifier
	 * @return {Object} parameterDescription
	 */
	getParamDescriptionById : function(identifier) {
		
		var inputs 	= this.description.inputs;
		var outputs = this.description.outputs;
		
		var params = inputs.concat(outputs);
		
		var parameterDescription = params.filter(function(e,i,a){return e.identifier == identifier;});
		
		parameterDescription = (parameterDescription.length == 0)? undefined : parameterDescription[0];
		
		return parameterDescription;
	},
	
	//Provide EventDispatcher Functions
	addEventListener : THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener : THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener : THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent : THREE.EventDispatcher.prototype.dispatchEvent
	
};/**
 * The Line of Sight Process calculates the visibility bewtween two points in the scene. Only for static/fixed layers.
 * 
 * @namespace GIScene
 * @class Process.LineOfSight
 * @constructor
 * @extends GIScene.Process 
 * 
 * @author mcauer https://github.com/mcauer
 */
GIScene.Process.LineOfSight = function() {
	
	var config = {
		identifier		: "GIScene:lineOfSight",
		title			: "Line of Sight",
		abstract		: "Given two loactions and possible obstacle objects this process will compute the visibility between the two loactions and provides a graphical 3D line.",
		metadata		: null,
		processVersion	: "1.0",
		description		: {inputs:[
								{
									identifier: 'GIScene:lineOfSight:observerPoint',
									title:    'Observer Point', 
									abstract: 'Point of Observer, where the line of sight starts.', 
									dataType:   'THREE.Vector3', //???
									minOccurs: 1,
									maxOccurs: 1,
								},
								{
									identifier: 'GIScene:lineOfSight:observerOffset',
									title:	'Observer Offset',
									abstract:	'Additional height offset to observer point.',
									dataType:	'Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{	identifier: 'GIScene:lineOfSight:targetPoint',
									title:    'Tartget Point', 
									abstract: 'Point of Target, where the line of sight ends.', 
									dataType:   'THREE.Vector3', //???
									minOccurs: 1,
									maxOccurs: 1
								},
								{
									identifier: 'GIScene:lineOfSight:targetOffset',
									title:	'Target Offset',
									abstract:	'Additional height offset to target point.',
									dataType:	'Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{
									identifier: 'GIScene:lineOfSight:obstacles',
									title:    'Obstacles',
									abstract: 'Possible obstacles to be reflected in the calculation.',
									dataType  : 'Array(THREE.Mesh)',
									minOccurs: 1,
									maxOccurs: 1 //????
								}
							],
							outputs:[
								{
									identifier: 'GIScene:lineOfSight:lineOfSight',
									title:	'Line Of Sight',
									abstract:	'The calculated Line of Sight between observer and target.',
									dataType:	'THREE.Object3D' //???
									
								},
								{
									identifier: 'GIScene:lineOfSight:isVisible',
									title:	'Target is visible',
									abstract:	'The result of the visibility calculation.',
									dataType:	'boolean'
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 

	
	this.raycaster	= new THREE.Raycaster();

	//INPUTS
	// this.inputs.observerPoint  = null; //THREE.Vector3
	// this.inputs.targetPoint	= null; //THREE.Vector3
	// this.inputs.observerOffset = 0;
	// this.inputs.targetOffset	= 0;
	// this.inputs.obstacles		= null;
// 	
	// //OUTPUTS
	// this.ouputs.visibility = null;
	// this.ouputs.lineOfSight = null;
	
	// var inputParams = {
		// 'GIScene:lineOfSight:observerPoint'	: new THREE.Vector3(0,100,0),
		// 'GIScene:lineOfSight:observerOffset': 5,
		// 'GIScene:lineOfSight:targetPoint'	: new THREE.Vector3(0,-100,0),
		// 'GIScene:lineOfSight:targetOffset'	: 0,
		// 'GIScene:lineOfSight:obstacles'		: null//this.scene.root		
	// };
// 	
	// this.setInputs(inputParams);
	
	var lineMatVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0x00ff00)});
	var lineMatNotVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0xff0000)});
	
		
	this.execute = function() {
		
		var observerV3 		= this.data.inputs['GIScene:lineOfSight:observerPoint'];
		var observerOffset 	= this.data.inputs['GIScene:lineOfSight:observerOffset'];	
		var targetV3		= this.data.inputs['GIScene:lineOfSight:targetPoint'];
		var targetOffset	= this.data.inputs['GIScene:lineOfSight:targetOffset'];
		var obstacles		= this.data.inputs['GIScene:lineOfSight:obstacles'];	
		
		var start 		= observerV3.clone().add(new THREE.Vector3(0,observerOffset,0));
		var end			= targetV3.clone().add(new THREE.Vector3(0,targetOffset,0));
		var direction 	= end.clone().sub(start).normalize();
		
		this.raycaster.set(start, direction); //(origin, direction) direction must be normalized
		
		this.raycaster.far = start.distanceTo(end);//targetV3.clone().sub(observerV3).length();
		
		console.log("far", this.raycaster.far);
		
		var intersections = this.raycaster.intersectObjects(obstacles, true);
		
		console.log("intersections",intersections);
		
		var targetIsVisible = true;
		var visibilityLines;
		var group = new THREE.Object3D();
		
		if( intersections.length > 0 ) { 
			targetIsVisible = false; 
			
			//visLine
			var geomVis = new THREE.Geometry();
			geomVis.vertices = [start,intersections[0].point];
			var visLine = new THREE.Line(geomVis, lineMatVisible);
			//notVisLine
			var geomNotVis = new THREE.Geometry();
			geomNotVis.vertices = [intersections[0].point,end];
			var notvisLine = new THREE.Line(geomNotVis, lineMatNotVisible);
			
			group.add(visLine);
			group.add(notvisLine);
			}
		else {
			var geom = new THREE.Geometry();
			geom.vertices = [start,end];
			var visLine = new THREE.Line(geom, lineMatVisible);
			
			group.add(visLine);
		}
		
		this.data.outputs['GIScene:lineOfSight:lineOfSight'] = group;
		this.data.outputs['GIScene:lineOfSight:isVisible']	 = targetIsVisible;
		
		console.log(this._listeners);
		this.dispatchEvent({type:'execute', content : this.data});
		
		return this.data;
		
	};
};

//Inherit from GIScene.Layer
GIScene.Process.LineOfSight.prototype = Object.create( GIScene.Process.prototype );/**
 * The Line of Sight Process calculates the visibility bewtween two points in the scene
 * 
 * @namespace GIScene
 * @class Process.LineOfSight_simpleClient
 * @constructor
 * @extends GIScene.Process 
 * 
 * @author mcauer https://github.com/mcauer
 */
GIScene.Process.LineOfSight_simpleClient = function() {
	
	var config = {
		identifier		: "GIScene:lineOfSight",
		title			: "Line of Sight",
		abstract		: "Given two locations and possible obstacle objects this process will compute the visibility between the two locations and provides a graphical 3D line.",
		metadata		: null,
		processVersion	: "1.0",
		description		: {inputs:[
								{
									identifier: 'GIScene:lineOfSight:observerPoint',
									title:    'Observer Point', 
									abstract: 'Point of Observer, where the line of sight starts.', 
									dataType:  'GIScene.Coordinate3', //long geo coords
									maxOccurs: 1,
								},
								{
									identifier: 'GIScene:lineOfSight:observerOffset',
									title:	'Observer Offset',
									abstract:	'Additional height offset to observer point.',
									dataType:	'Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{	identifier: 'GIScene:lineOfSight:targetPoint',
									title:    'Tartget Point', 
									abstract: 'Point of Target, where the line of sight ends.', 
									dataType:   'GIScene.Coordinate3', //long geo coords
									minOccurs: 1,
									maxOccurs: 1
								},
								{
									identifier: 'GIScene:lineOfSight:targetOffset',
									title:	'Target Offset',
									abstract:	'Additional height offset to target point.',
									dataType:	'Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{
									identifier: 'GIScene:lineOfSight:obstacleLayers',
									title:    'Obstacle Layers',
									abstract: 'Layers whose objects are possible obstacles to be reflected in the calculation.',
									dataType  : 'Array(GIScene.Layer)',
									minOccurs: 1,
									maxOccurs: 'unbounded' //like in xml
								}
							],
							outputs:[
								{
									identifier: 'GIScene:lineOfSight:lineOfSight',
									title:	'Line Of Sight',
									abstract:	'The calculated Line of Sight between observer and target.',
									dataType:	'THREE.Object3D' //???
									
								},
								{
									identifier: 'GIScene:lineOfSight:isVisible',
									title:	'Target is visible',
									abstract:	'The result of the visibility calculation.',
									dataType:	'boolean'
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 
	
	this.raycaster	= new THREE.Raycaster();
	
	var lineMatVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0x00ff00)});
	var lineMatNotVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0xff0000)});
	
	
	
	/**
	 * run the process with the inputs that have been set before
	 *  @method execute
	 *  @param {Function} [onExecute] callback that will be called when process is finished
	 *  
	 */
	
	this.execute = function(onExecute) {
		// var observerV3 		= this.data.inputs['GIScene:lineOfSight:observerPoint'];
		var observerC3 		= this.data.inputs['GIScene:lineOfSight:observerPoint'];
		console.log('observerc3');
		console.log(observerC3);
		var observerOffset 	= this.data.inputs['GIScene:lineOfSight:observerOffset'];	
		//var targetV3		= this.data.inputs['GIScene:lineOfSight:targetPoint'];
		var targetC3		= this.data.inputs['GIScene:lineOfSight:targetPoint'];
		var targetOffset	= this.data.inputs['GIScene:lineOfSight:targetOffset'];
		var obstacleLayers	= this.data.inputs['GIScene:lineOfSight:obstacleLayers'];	
		
		var onExecute = onExecute || function(){};
		
		//@TODO evaluate inputs (occurences etc.)
		var scene = obstacleLayers[0].scene; // get scene from layers, better set scene as a process param?
		
		//short graphic coords
		var observerV3 		= observerC3.clone().sub(scene.config.offset).toVector3();
		var targetV3		= targetC3.clone().sub(scene.config.offset).toVector3();
		
		var start 		= observerV3.clone().add(new THREE.Vector3(0,observerOffset,0)); //short graphic coords
		var end			= targetV3.clone().add(new THREE.Vector3(0,targetOffset,0));
		var direction 	= end.clone().sub(start).normalize();
		// var loading = new GIScene.Grid.TileStore(); // need it per layer
		var intersections; 
		var nearestIntersection = null;
		var numCheckedLayers = 0;
		var targetIsVisible;
		
		//global analysis state
		var analysisDone= false;
		
		
		this.raycaster.set(start, direction); //(origin, direction) direction must be normalized
		
		this.raycaster.far = start.distanceTo(end);//targetV3.clone().sub(observerV3).length();
		
		console.log("far", this.raycaster.far);
		
		/**
		 * 
		 * @method getNearestIntersectionObject
		 * @private
		 * @param {THREE.Vector3} referencePoint
		 * @param {Object} intersectionObjectA object returned from Raycaster.intersectObjects() method
		 * @param {Object} intersectionObjectB object returned from Raycaster.intersectObjects() method
		 * @return {Object} nearestIntersectionObject
		 */
		var getNearestIntersectionObject = function(referencePoint, intersectionObjectA, intersectionObjectB) {
			//only valid if both are created by the same ray
			return ( intersectionObjectA.distance < intersectionObjectB.distance )?
					 intersectionObjectA
					:
					 intersectionObjectB
					;
			
			// return ( referencePoint.distanceTo(intersectionObjectA.point) < referencePoint.distanceTo(intersectionObjectB.point) )?
					  // intersectionObjectA
					 // :
					  // intersectionObjectB
					 // ;
			
		};
		
		//returns true if newIntersection is nearest
		var updateNearestIntersection = function(nearestIntersection_, newIntersection) {
			if ( !!(newIntersection) ){ //intersections found
			  	if(!nearestIntersection){ 
			  		nearestIntersection = newIntersection;
			  		updateAllNearestIntersectionTileIndices();
			  		return true;
			  	}
			  	else{
			  		nearestIntersection = getNearestIntersectionObject(start,nearestIntersection_,newIntersection);
			  		if(nearestIntersection === newIntersection){
			  				updateAllNearestIntersectionTileIndices();
			  				return true;
			  			};
			  		
			  		};
			  	}
			 else { //no intersections found
			 	return false;
			 }
		};
		
		var updateAllNearestIntersectionTileIndices = function() {
			
			//only do it for gridlayers, stop in phase of static layer checking
			if(!gridLayers[0].LineOfSightAnalysisController){return;}
			
			for(var i=0,j=gridLayers.length; i<j; i++){
			  
			  var layer = gridLayers[i];
			  
			  var nearestIntersectionGridIndex = (nearestIntersection)? layer.grid.getIndexFromPoint2d(GIScene.Utils.vector3ToVector2(nearestIntersection.point), layer.LineOfSightAnalysisController.smallestTileSize) : undefined;
			  
			  layer.LineOfSightAnalysisController.analysisTiles.forEach(function(e,idx,a){
								  			if(nearestIntersectionGridIndex && e.equals(nearestIntersectionGridIndex)){layer.LineOfSightAnalysisController.nearestIntersectionTileIndex = idx;}
								 		}.bind(this)
								 );
			};
		};
		
		
		// //find indexOf first element with true if no undefined is found before, otherwise if 
		// undefined before return -1
		// if no undefined is found and all are false return false
		var getIndexOfFirstIntersectionTile = function(ctrl){
		  var first = false;
		  for (var i=0,j=ctrl.length;i<j;i++){
		
		    if(ctrl[i] === undefined)	{first = -1;	break;}
		    if(ctrl[i] === true)		{first = true;	break;}
		  
		  }
		  return first;
		};
		
		//all from here must be wrapped in a returnResults function
		var returnResults = function(layer/*, loading, computeTileIndicesHandler*/) {
			
			if (layer) {var losCtrl = layer.LineOfSightAnalysisController;}
			if(losCtrl){ //only available in gridLayers
				var computeTileIndicesHandler = losCtrl.computeTileIndicesHandler;
				var loading = losCtrl.loading;	
			}
			
			
			if(layer && loading){
				//abort all still loading in a finished layer
				var aborts = 0;
				for ( tile in loading.store ){
					loading.store[tile].object.abort();
					aborts++;
					loading.remove(new GIScene.Grid.Index().fromString(tile));
				}
				console.log(layer.name + ": optimized uncached tiles by abort running requests: " + aborts);
			}
			
			//restore original state
		  	if(computeTileIndicesHandler) layer.computeTileIndicesHandler = computeTileIndicesHandler;
			
			//wait until last layer has finished 
			if( !( numCheckedLayers == obstacleLayers.length ) ){
				console.log("Number of checked Layers",numCheckedLayers);	
				return;
				}
			
			//all layers are checked now
			analysisDone = true;
			console.log("Number of checked Layers",numCheckedLayers, "Ready.");
			
			
			//return to normal work
			
			gridLayers.forEach(function(layer,i,a){ 
					
					layer.startUpdate(); 
					
					//cleanup
					layer.LineOfSightAnalysisController = null;
					losCtrl = null;
					delete layer.LineOfSightAnalysisController;
					
				});
			
			//evaluate intersections
			console.log("THE END");
			
			// var targetIsVisible = true;
			var visibilityLines;
			var group = new THREE.Object3D();
			
			if( nearestIntersection ) { 
				targetIsVisible = false; 
				
				//visLine
				var geomVis = new THREE.Geometry();
				geomVis.vertices = [start,nearestIntersection.point];
				var visLine = new THREE.Line(geomVis, lineMatVisible);
				//notVisLine
				var geomNotVis = new THREE.Geometry();
				geomNotVis.vertices = [nearestIntersection.point,end];
				var notvisLine = new THREE.Line(geomNotVis, lineMatNotVisible);
				
				group.add(visLine);
				group.add(notvisLine);
				}
			else {
				targetIsVisible = true;
				var geom = new THREE.Geometry();
				geom.vertices = [start,end];
				var visLine = new THREE.Line(geom, lineMatVisible);
				
				group.add(visLine);
			}
			
			this.data.outputs['GIScene:lineOfSight:lineOfSight'] = group;
			this.data.outputs['GIScene:lineOfSight:isVisible']	 = targetIsVisible;
			
			this.dispatchEvent({type:'execute', content : this.data});
			
			onExecute(this.data);
			
		}.bind(this);
		
		var checkUncachedTile = function(index, layer/*, loading, controlArray, uncachedTiles, uncachedTilesIndex, computeTileIndicesHandler,analysisState, nearestIntersectionTileIndex*/) {
			
			var losCtrl = layer.LineOfSightAnalysisController;
			
			var loading = losCtrl.loading;
			var controlArray = losCtrl.controlArray;
			var uncachedTilesIndex = losCtrl.uncachedTilesIndex;
			
			var gridIndex = losCtrl.uncachedTiles[index];
			
						
			var requestUrl = layer.config.service.getGetSceneUrl(gridIndex, layer.grid);
			
			var onSuccess = function(result) { //result is a THREE.Scene Object
				
				
				
				var checkIntersection = true;
				
				console.log(layer.name + ': LineOfSight:load uncached tiles:onSuccess',index);
				
				if (losCtrl.layerChecked){
					console.log(layer.name + ": Analysis already DONE!");
					return;
				}; //for async callbacks after first intersection already found
				
				//remove from loading
				loading.remove(gridIndex);
				
				//TODO don't check intersection if already nearer tile is checked positive (from other uncached tile / layer)
				console.log("nearestIntersectionTileIndex",losCtrl.nearestIntersectionTileIndex);
				//short hack only for current layer
				if(index > losCtrl.nearestIntersectionTileIndex) {console.log("already behind nearest intersection. SKIP processing loaded tile.");checkIntersection = false;controlArray[uncachedTilesIndex[index]] = false;/*return;*/}
				//long hack across all layers 
				// if(nearestIntersection){
					// var tileCenter = layer.grid.getCentroidFromIndex(gridIndex); //Vec2 short graphic coords
					// // var boundingRadius = Math.sqrt( 2 * Math.pow(gridIndex.tileSize*0.5, 2) );
					// // var nearestIntTileCenterDistance = tileCenter.distanceTo( GIScene.Utils.vector3ToVector2(nearestIntersection.point) );
// 					
					// // if (nearestIntTileCenterDistance > boundingRadius){
						// // console.log(layer.name + ": optimize uncached tiles. Already nearer intersection found. Skip analysisTiles index" + uncachedTilesIndex[index]);
						// // //return false;
						// // checkIntersection = false;
						// // controlArray[uncachedTilesIndex[index]] = false;
					// // }
// 					
					// if( GIScene.Utils.vector3ToVector2(nearestIntersection.point.clone().sub(start)).length() < tileCenter.clone().sub(GIScene.Utils.vector3ToVector2(start)).length() ){
						// console.log(layer.name + ": optimize uncached tiles. Already nearer intersection found. Skip analysisTiles index" + uncachedTilesIndex[index]);
						// //return false;
						// // return; 
						// checkIntersection = false;
						// controlArray[uncachedTilesIndex[index]] = false;
					// }
				// }
				
				if (checkIntersection){
					//rotate model if z is up
					if(layer.verticalAxis.toUpperCase() == "Z"){
						result.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI/2 ) );
					}
					
					//setOverrideMaterial
					layer.setOverrideMaterial(result, layer.config.overrideMaterial);
					
					layer.root.add(result);
			  		result.updateMatrixWorld();
			  		
			  		//TODO OPTIONALLY compute BBOX
			  		result.traverse(function(object){if(object.geometry){object.geometry.computeBoundingBox();}});
			  		
			  		//TODO may be wait for after render, so that everything is updated correctly?
			  		intersections = this.raycaster.intersectObject(layer.root, true);
			  		
			  		//TODO if no obstruction point needed then if intersections.length > 0 indicates visibility false and the whole process can be stopped here
			  		if(intersections.length > 0){
				  		var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
				  		
				  		if(isNearestTile){losCtrl.nearestIntersectionTileIndex = uncachedTilesIndex[index]; }
				  		console.log("nearestIntersectionTileIndex", losCtrl.nearestIntersectionTileIndex);
				  		
				  		controlArray[uncachedTilesIndex[index]] = true;
			  		}
			  		else{
			  			controlArray[uncachedTilesIndex[index]] = false;
			  		}
			  		layer.root.remove(result);
				}
				
		  		
		  		//add tile to cache to make use of having loaded it for after analysis visualization
		  		layer.cache.add(gridIndex,result);
				
			//if there is no tile before left to be checked and an intersection was found here: continue the loop to the next layer
			//check if all tiles have been tested then execute returnResults()
			var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray);
			console.log("doreturnResults?", firstIntersectionTile !== -1);
			console.log("intersectionsLength: ", intersections.length);
			console.log("Loading Requests:" , loading.length);
			if(firstIntersectionTile !== -1){
				numCheckedLayers++;
				losCtrl.layerChecked = true;
				console.log(layer.name +" : firstIntersection found! Layer checked by UNCACHED!");
				returnResults(layer/*, loading, computeTileIndicesHandler*/);
			}
			
			
			}.bind(this);
			
			var onError = function(event) {
				console.log(event);
				
				console.log(layer.name + ': LineOfSight:load uncached tiles:onError',index);
				
				//remove from loading
				loading.remove(gridIndex);
				alert ("XHRError");
								
			}.bind(this);//TODO Sceneloader will never throw it // now it should
			
			var loader = new GIScene.ModelLoader(); //need a loader for every parallel request
			loader.load(requestUrl, layer.format, onSuccess, undefined, onError);
			loading.add(gridIndex,loader);
		}.bind(this);
		
		
		/////////////////////
		// START ANALIZING //
		/////////////////////
		
		//get layers to be included in analysis
				
		//find out which are Grid and which not
		var gridLayers = [];
		var staticLayers = [];
		obstacleLayers.forEach(function(e,i,a){
			if (e instanceof GIScene.Layer.Grid){gridLayers.push(e);}
			else {staticLayers.push(e);}
		});
		
		console.log("obstacle layers", obstacleLayers.length);
		console.log("static layers", staticLayers.length);
		console.log("grid layers", gridLayers.length);
		
		//first check the STATIC layers then the more complicated gridLayers
		for(var i=0,j=staticLayers.length; i<j; i++){
		  
		  intersections = this.raycaster.intersectObject(staticLayers[i].root, true);
		  
		  //TODO if no obstruction point needed then if intersections.length > 0 indicates visibility false and the whole process can be stopped here
		  
		  //check which intersection is the first (nearest to start)
		  if(intersections.length > 0) updateNearestIntersection(nearestIntersection, intersections[0]);
		  
		  numCheckedLayers++;
		  console.log(staticLayers[i].name +" : Layer checked STATIC!");
		  returnResults();
		  
		}; //static layer check end
		
		
		
		//INIT gridlayers checking for checking
		for(var i=0,j=gridLayers.length; i<j; i++){
			
			var layer = gridLayers[i];
			var grid = layer.grid;
			
			//controller object for each grid layer
			layer.LineOfSightAnalysisController = {};
		  	var losCtrl = layer.LineOfSightAnalysisController;
		  		  
		  	losCtrl.layerChecked = false;
		  	losCtrl.loading = new GIScene.Grid.TileStore();
		    losCtrl.smallestTileSize = grid.tileSizes[grid.tileSizes.length-1]; //tilesizes are sorted from big to small
		    
		    //get AnalysisTiles per layer
			var observerV2 = new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(observerV3.clone().add(grid._sceneOffset)) );
			var targetV2 =   new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  targetV3.clone().add(grid._sceneOffset)) );
			  
			var optimizedTarget1 = (nearestIntersection)? new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  nearestIntersection.point.clone().add(grid._sceneOffset)) ) : targetV2;
			//8-connected rasterline (DDA grid traversal algorithm)
			var woOptimizedTarget = grid.getTilesFromLineIntersection(observerV2,targetV2,losCtrl.smallestTileSize);
			losCtrl.analysisTiles = grid.getTilesFromLineIntersection(observerV2,optimizedTarget1,losCtrl.smallestTileSize);
			  
			console.log(layer.name + ": "+ optimizedTarget1.toArray());
			console.log(layer.name + ": optimized number of tiles: " + losCtrl.analysisTiles.length +"/"+ woOptimizedTarget.length + " " + ((losCtrl.analysisTiles.length *100) / woOptimizedTarget.length) + "%");
			
			losCtrl.controlArray = new Array(losCtrl.analysisTiles.length);
 
			//check each analysisTile for obstructions: first chached tiles synchronously, then uncached tiles asnchronuously
			//tiles have to be loaded and added to the scene, to be sure that all matrices are applied correctly when tested with Raycaster

			//store layer function to be restored after the analysis
			losCtrl.computeTileIndicesHandler = layer.computeTileIndicesHandler;

			// remove all tiles
			//better in future: remove tiles in two steps to be sure that the analysis tile get into the cache at last
			layer.stopUpdate();
			layer.computeTileIndicesHandler = function() {
				return [];
			};
			layer.update();
			//this removes all tiles from the scene

			//first check available tiles from cache
			losCtrl.cachedTiles = [];	//Objects
			losCtrl.cachedTilesIndex = [];
			losCtrl.uncachedTiles = [];	//TileIndex
			losCtrl.uncachedTilesIndex = [];

			//var nearestIntersectionTileIndex;//analysisTiles Array Index
			losCtrl.nearestIntersectionTileIndex = undefined;

			losCtrl.analysisTiles.forEach( function(e, i, a) {

				var tileFromCache = layer.cache.getTile(e);
				if (tileFromCache) {
					losCtrl.cachedTiles.push(tileFromCache);  //Object3D
					losCtrl.cachedTilesIndex.push(i);
				} else {
					losCtrl.uncachedTiles.push(e);  	//Grid.Index
					losCtrl.uncachedTilesIndex.push(i);
				}
			}.bind(this));

			console.log(layer.name + ": cached / uncached tiles", losCtrl.cachedTiles.length, losCtrl.uncachedTiles.length); 

			
		}
		
		//////////////////////////////////////////////////////////// 
		//START checking ALL gridlayers CACHED tiles synchronously//
		////////////////////////////////////////////////////////////
		for(var i=0,j=gridLayers.length; i<j; i++){
		  
		  var layer = gridLayers[i];
		  var losCtrl = layer.LineOfSightAnalysisController;
		  
		  	  
		  console.log("Start Analyzing " + layer.name);
		  console.log(layer.name + ": Analyzing "+ losCtrl.cachedTiles.length +" CACHED tiles");
		  
		  
		  // CHECK CACHED TILES
		  for(var iiii=0,jjjj=losCtrl.cachedTiles.length; iiii<jjjj; iiii++){
		  	
		  	var tileFromCache = losCtrl.cachedTiles[iiii];
		  	
		  	layer.root.add(tileFromCache);
		  		
	  		//TODO may be wait for after render, so that everything is updated correctly?
	  		intersections = this.raycaster.intersectObject(layer.root, true);
	  		
	  		//TODO if no obstruction point needed then if intersections.length > 0 indicates visibility false and the whole process can be stopped here
	  		if(intersections.length > 0){
	  			var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
	  		
	  			if(isNearestTile){losCtrl.nearestIntersectionTileIndex = losCtrl.cachedTilesIndex[iiii]; }
	  			console.log("nearestIntersectionTileIndex", losCtrl.nearestIntersectionTileIndex);
	  			losCtrl.controlArray[losCtrl.cachedTilesIndex[iiii]] = true;
	  		}
	  		else{
	  			losCtrl.controlArray[losCtrl.cachedTilesIndex[iiii]] = false;
	  		}
	  		
	  		layer.root.remove(tileFromCache);
	  		
	  		var firstIntersectionTile = getIndexOfFirstIntersectionTile(losCtrl.controlArray); // true (first found), false (all checked but none found) or -1 (keep on checking)
	  		console.log(layer.name + ' :firstIntersectionTile', firstIntersectionTile, losCtrl.controlArray.length);
	  		if(firstIntersectionTile !== -1){
	  			numCheckedLayers++;
	  			console.log(layer.name +" : firstIntersection found! Layer checked by CACHED!");
				returnResults(layer/*, loading, computeTileIndicesHandler*/);
				
				losCtrl.layerChecked = true;
				break; //no more cached tile testing
			}
		  };
		  //if(layerChecked){continue;} //when checked by cached no testing of uncached --> test next layer
		  
		} //DONE checking all gridlayers CACHED tiles
		  
		 
		 if( analysisDone ) return; 
		  
		 ///////////////////////////////////////////////////////////////
		 //START checking ALL gridlayers UNCACHED tiles asynchronously//
		 ///////////////////////////////////////////////////////////////
		 for(var i=0,j=gridLayers.length; i<j; i++){ 
		  
		  var layer = gridLayers[i];
		  var losCtrl = layer.LineOfSightAnalysisController;
		  if (losCtrl.layerChecked){ return; };
		  //OPTIMIZE
		  //reduce uncachedTiles according to former found intersections
		  //2nd reduction if uncached are left but found intersection in cached
		  if(nearestIntersection){
		  	var deleteFromIndex = null;
		  	for(var iii=losCtrl.uncachedTilesIndex.length-1, jjj=0; iii>=jjj; iii--){
				if(losCtrl.uncachedTilesIndex[iii] >= losCtrl.nearestIntersectionTileIndex){
					deleteFromIndex = iii;
				}
			  };
			  
			 if(deleteFromIndex != null){
			 	console.log('controlArray:before', losCtrl.controlArray);
			 	var uncached_orig_length = losCtrl.uncachedTiles.length;
			 	
			 	losCtrl.uncachedTiles.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	
			 	//update controlArray
			 	for(var v = deleteFromIndex, vi = uncached_orig_length/*uncachedTiles.length*/; v < vi; v++){
			 		losCtrl.controlArray[losCtrl.uncachedTilesIndex[v]] = false;
			 	}
			 	
			 	//update uncachedTilesIndex
			 	losCtrl.uncachedTilesIndex.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	 
			 	console.log(layer.name + ": optimized number of uncached tiles: " + uncached_orig_length +"-->"+ losCtrl.uncachedTiles.length);
			 	// console.log('controlArray:after', losCtrl.controlArray);
			 }
		  }
		  
		  
		  //CHECK remaining UNCACHED tiles (async)
		  console.log(layer.name + ": Analyzing "+ losCtrl.uncachedTiles.length +" UNCACHED tiles");
		  for(var ii=0,jj=losCtrl.uncachedTiles.length; ii<jj; ii++){
					
			if (checkUncachedTile(ii, layer/*, loading, controlArray, uncachedTiles, uncachedTilesIndex,computeTileIndicesHandler,analysisState, nearestIntersectionTileIndex*/) === false) { continue; }
			
		  };
		  
		  
		}; // gridLayer check end
		
	};
		
};

//Inherit from GIScene.Layer
GIScene.Process.LineOfSight_simpleClient.prototype = Object.create( GIScene.Process.prototype );/**
 * The Intervisibility Process calculates the intervisibility between two points in the scene. 
 * It takes different observer offset and target offset heights into account.
 * 
 * @namespace GIScene
 * @class Process.Intervisibility
 * @constructor
 * @extends GIScene.Process 
 * 
 * @author mcauer https://github.com/mcauer
 */
GIScene.Process.Intervisibility = function(scene) {
	
	var config = {
		identifier		: "GIScene:intervisibility",
		title			: "Intervisibility",
		abstract		: "Given two loactions, observer and target offsets and possible obstacle objects this process will compute the intervisibility between each observer and target of the two loactions and provides graphical 3D lines.",
		metadata		: null,
		processVersion	: "1.0",
		description		: {inputs:[
								{
									identifier: 'GIScene:intervisibility:points',
									title:    'Intervisibility Points', 
									abstract: 'Two points between the intervisibility will be calculated. Each point should provide attributes about observer and target offset.', 
									dataType: 'Array of GIScene.Coordinate3',  //'Array of THREE.Vector3', //???
									minOccurs: 1,
									maxOccurs: 1,
								},
								{
									identifier: 'GIScene:intervisibility:observerOffsets',
									title:	'Observer Offsets',
									abstract:	'Additional height offsets to the observer points.',
									dataType:	'Array of Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:[]
								},
								{
									identifier: 'GIScene:intervisibility:targetOffsets',
									title:	'Target Offsets',
									abstract:	'Additional height offsets to the target points.',
									dataType:	'Array of Number',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:[]
								},
								{
									identifier: 'GIScene:intervisibility:obstacleLayers',
									title:    'Obstacle Layers',
									abstract: 'Layers with possible obstacles to be reflected in the calculation.',
									dataType  : 'Array(GIScene.Layer)',
									minOccurs: 1,
									maxOccurs: 1 
								}
							],
							outputs:[
								// {
									// identifier: 'GIScene:intervisibility:intervisibilityPoints',
									// title:	'Intervisibility Points',
									// abstract:	'The points used in the calculation (ground?, observer, target). The target point will have a visibility attribute "isVisible" with 0: not visible 1:visible',
									// dataType:	'THREE.Object3D' //???
// 									
								// },
								{
									identifier: 'GIScene:intervisibility:intervisibilityLines',
									title:	'Intervisibility Lines',
									abstract:	'The calculated Lines of Sight between observers and targets.',
									dataType:	'THREE.Object3D' //???
									
								},
								{
									identifier: 'GIScene:intervisibility:intervisibility',
									title:	'Intervisibility',
									abstract:	'The result of the intervisibility calculation.'
												+'<ul>'
												+'<li>"00": Both observer can NOT see their targets.</li>'
												+'<li>"01": The target of the second point is visible to the observer of the first one.</li>'
												+'<li>"10": The target of the first point is visible to the observer of the second one.</li>'
												+'<li>"11": Both observer can see their targets. They are intervisible.</li>'
												+'</ul>'
												,
									dataType:	'String'
								},{
									identifier: 'GIScene:intervisibility:intervisibilityLine',
									title:		'Intervisibility Line',
									abstract:	'One feature (LineString) representing the relation between the two tested points, indicated by it\'s intervisibility attribute',
									dataType:	'GeoJSON'
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 

	
	var lineMatVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0x00ff00)});
	var lineMatNotVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0xff0000)});
	
		
	this.execute = function(onExecute) {
		
		var intervisibilityPointsC3	= this.data.inputs['GIScene:intervisibility:points']; // Array of long geo coords
		var observerOffsets 		= this.data.inputs['GIScene:intervisibility:observerOffsets'];
		var targetOffsets 			= this.data.inputs['GIScene:intervisibility:targetOffsets'];
		var obstacleLayers				= this.data.inputs['GIScene:intervisibility:obstacleLayers'];
		    onExecute = onExecute || function(){};
		var numFinishedProcesses = 0;
		var isTwoLineProcess = ( observerOffsets.length > 0 || targetOffsets.length > 0 );
		
		var intervisibilityPointsV3 = [intervisibilityPointsC3[0].toVector3(), intervisibilityPointsC3[1].toVector3()]; //long graphic coords
		
		var createLine = function(start, end, isVisible) {
			var mat = (isVisible)? lineMatVisible : lineMatNotVisible ;
			var geom = new THREE.Geometry();
			geom.vertices = [start,end];
			var visLine = new THREE.Line(geom, mat);
			var attributes = {"isVisible": isVisible};
			visLine.userData.gisceneAttributes = attributes;
			visLine.name = "Line of Sight";
			return visLine;
		};
		
		var finalize = function() {			
			
			var group = new THREE.Object3D();
			group.userData.gisceneAttributes = {};
			group.name = "Intervisibility";
					
			//toLine
			var toIsVisible = toProcess.getOutput('GIScene:lineOfSight:isVisible');
			var toStart = intervisibilityPointsV3[0].clone().add(new THREE.Vector3(0, observerOffsets[0] || 0,0));
			var toEnd	= intervisibilityPointsV3[1].clone().add(new THREE.Vector3(0,   targetOffsets[1] || 0,0));
			var toLine  = createLine(toStart, toEnd, toIsVisible);
			group.add(toLine);
			
			//fromLine
			if(isTwoLineProcess){
				var fromIsVisible = fromProcess.getOutput('GIScene:lineOfSight:isVisible');
				var fromStart = intervisibilityPointsV3[1].clone().add(new THREE.Vector3(0, observerOffsets[1] || 0,0));
				var fromEnd	  = intervisibilityPointsV3[0].clone().add(new THREE.Vector3(0,   targetOffsets[0] || 0,0));
				var fromLine  = createLine(fromStart, fromEnd, fromIsVisible);
				group.add(fromLine);
			}
			
			var intervisibility = (isTwoLineProcess)? (Number(fromIsVisible)+ "" + Number(toIsVisible)) : (Number(toIsVisible)+ "" + Number(toIsVisible));
			group.userData.gisceneAttributes["intervisibility"] = intervisibility;
			
			this.data.outputs['GIScene:intervisibility:intervisibilityLines'] = group;
			
			// "00", "01", "10", "11"						
			this.data.outputs['GIScene:intervisibility:intervisibility'] = intervisibility;
			
			//GeoJSON Feature
			var geoJSON = {
				"type": "Feature",
		        "geometry": {"type": "LineString", "coordinates": [intervisibilityPointsC3[0].toArray(), intervisibilityPointsC3[1].toArray()]},
		        "properties": {
		        				"intervisibility": intervisibility
		        			  }
			};
			if(scene.config.projection){
				geoJSON["crs"] = {
									"type": "name",
									"properties": {
									"name": scene.config.projection
									}
							};
			}
			this.data.outputs['GIScene:intervisibility:intervisibilityLine'] = JSON.stringify(geoJSON);
			
			/**
			 *@event execute event has a content property referring to the processes data object with inputs and outputs 
			 */
			 
			this.dispatchEvent({type:'execute', content:this.data});
			
			onExecute(this.data);
			
		}.bind(this);
		
		//start processing
		
		var toProcess = new GIScene.Process.LineOfSight_simpleClient();
		
		toProcess.setInput('GIScene:lineOfSight:observerPoint', intervisibilityPointsC3[0]);
		if( !!observerOffsets[0] ){toProcess.setInput('GIScene:lineOfSight:observerOffset', observerOffsets[0]);}
		toProcess.setInput('GIScene:lineOfSight:targetPoint', intervisibilityPointsC3[1]);
		if( !!targetOffsets[1] ){toProcess.setInput('GIScene:lineOfSight:targetOffset', targetOffsets[1]);}
		toProcess.setInput('GIScene:lineOfSight:obstacleLayers', obstacleLayers);
		
		
			
		
		if(isTwoLineProcess){
			//two lines of sight
			var fromProcess = new GIScene.Process.LineOfSight_simpleClient();
			
			fromProcess.setInput('GIScene:lineOfSight:observerPoint', intervisibilityPointsC3[1]);
			if( !!observerOffsets[1] ){fromProcess.setInput('GIScene:lineOfSight:observerOffset', observerOffsets[1]);}
			fromProcess.setInput('GIScene:lineOfSight:targetPoint', intervisibilityPointsC3[0]);
			if( !!targetOffsets[0] ){fromProcess.setInput('GIScene:lineOfSight:targetOffset', targetOffsets[0]);}
			fromProcess.setInput('GIScene:lineOfSight:obstacleLayers', obstacleLayers);
			
			
			
		}
		
		//start first process
		var onExecuteToProcess =  function(data) {
			
			// numFinishedProcesses++;
			
			if(!isTwoLineProcess /*|| numFinishedProcesses == 2*/){
				finalize();
			}else{
				//start second process
				var onExecuteFromProcess = function(data) {
				
				//numFinishedProcesses++;
				
				//if(numFinishedProcesses == 2){
					finalize();
				//}
				}.bind(this);
				
				fromProcess.execute(onExecuteFromProcess);
			}
			
		}.bind(this);
		
		toProcess.execute(onExecuteToProcess);
		
	};
};

//Inherit from GIScene.Layer
GIScene.Process.Intervisibility.prototype = Object.create( GIScene.Process.prototype );/**
 * The Line of Sight Network (all to all) Process calculates the intervisibility between all points in the given dataset (point layer)
 * 
 * @namespace GIScene
 * @class Process.LineOfSightNetwork_allToAll
 * @constructor
 * @extends GIScene.Process 
 * 
 * @author mcauer https://github.com/mcauer
 */
GIScene.Process.LineOfSightNetwork_allToAll = function() {
	
	var config = {
		identifier		: "GIScene:lineOfSight:network:allToall",
		title			: "Line of Sight Network (all to all)",
		abstract		: "Given an input set of point locations with each of them providing an attribute for an observer offset and a target offset, this process will compute the intervisibility between the two locations by computing two lines of sights between each pair of points. Always from the observer offset of one point to the target offset of the other.",
		metadata		: null,
		processVersion	: "1.0",
		description		: {inputs:[
								{
									identifier: 'GIScene:lineOfSight:network:intervisibilityPoints',
									title:    	'Intervisibility Points (layer)', 
									abstract: 	'Layer with points, which will be checked for intervisibility.', 
									dataType:   'GIScene.Layer', //.Points 
									minOccurs: 1,
									maxOccurs: 1,
								},
								{
									identifier: 'GIScene:lineOfSight:network:observerOffsetAttribute',
									title:	'Observer Offset Attribute',
									abstract:	'Attribute with additional height offsets to observer points.',
									dataType:	'String',
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:""
								},
								{	identifier: 'GIScene:lineOfSight:network:targetOffsetAttribute',
									title:    'Tartget Offset Attribute', 
									abstract: 'Attribute with additional height offsets to target points.', 
									dataType:   'String', 
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:""
								},
								{
									identifier: 'GIScene:lineOfSight:obstacleLayers',
									title:    'Obstacle Layers',
									abstract: 'Layers whose objects are possible obstacles to be reflected in the calculation.',
									dataType  : 'Array(GIScene.Layer)',
									minOccurs: 1,
									maxOccurs: 'unbounded' //like in xml
								}
							],
							outputs:[
								{
									identifier: 'GIScene:lineOfSight:network:intervisibilityNetwork',
									title:		'Intervisibility Network',
									abstract:	'A set of calculated Line of Sights between observer and target points.',
									dataType:	'THREE.Object3D' //???
								},
								{
									identifier: 'GIScene:lineOfSight:network:numberOfVisibleTargets',
									title:		'Number of visible targets',
									abstract:	'The number of visible targets or unobstructed individual line of sights.',
									dataType:	'Number' 
								},
								{
									identifier: 'GIScene:lineOfSight:network:numberOfObstructedTargets',
									title:		'Number of obstructed targets',
									abstract:	'The number of not visible targets or obstructed individual line of sights.',
									dataType:	'Number' 
								},
								{
									identifier: 'GIScene:lineOfSight:network:numberOfIntervisiblePairs',
									title:		'Number of intervisible pairs',
									abstract:	'The number of intervisible pairs of input points.',
									dataType:	'Number'
								},
								{
									identifier: 'GIScene:lineOfSight:network:intervisibilityLines',
									title:		'Intervisibility Lines',
									abstract:	'FeatureCollection (LineStrings) representing the relations between the tested pairs of points, indicated by their intervisibility attributes.',
									dataType:	'GeoJSON'
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 

	

	
	/**
	 * run the process with the inputs that have been set before
	 * To get notified when the process is finished add an event listener on the execute event. The event will provide a content propery with a data object with all input and output values of the process 
	 * 
	 * @method execute
	 * @param {Function} [onExecute] callback when process is finished
	 * 
	 * @example
	 * 		var doSomething = function(event){
	 * 			var outputs = event.content.outputs;
	 * 			//do something with the results
	 * 		}
	 * 		process.addEventListener('execute', doSomething);
	 * 		process.execute();
	 */
	
	this.execute = function(onExecute) {
		
			onExecute 			= onExecute || function(){};
		var inPointsLayer		= this.data.inputs['GIScene:lineOfSight:network:intervisibilityPoints'];
		var observerOffsetAttr 	= this.data.inputs['GIScene:lineOfSight:network:observerOffsetAttribute'];
		var targetOffsetAttr 	= this.data.inputs['GIScene:lineOfSight:network:targetOffsetAttribute'];
		var obstacleLayers		= this.data.inputs['GIScene:lineOfSight:obstacleLayers'];
		
		var numFinishedProcesses = 0;
		
		
		var points = []; // short graphic coords
		var observerOffsets = [];
		var targetOffsets = [];
		
		//get points from layer
		inPointsLayer.root.traverse(function(object){
			if(object.geometry){
				var vertex = object.geometry.vertices[0];
				var vertexWorld = object.localToWorld(vertex.clone()); //short graphic coords
				if(inPointsLayer.scene){
					var coordC3 = new GIScene.Coordinate3().fromVector3(vertexWorld).add(inPointsLayer.scene.config.offset); //long geo coords
					points.push(coordC3);
				}
				else {
					console.error("LineOfSightNetwork_allToAll: Layer: " + inPointsLayer.name + " must be added to scene before analysing.");
					return;
					}
				
				observerOffsets.push(object.userData.gisceneAttributes[observerOffsetAttr] || 0);
				targetOffsets.push(object.userData.gisceneAttributes[targetOffsetAttr] || 0);
			}
		}.bind(this));
		
		var numOfProcesses = (points.length-1)*(points.length/2); //number of intervisibility processes to wait for;
		var processQueue = new Array(numOfProcesses);
		
		var group = new THREE.Object3D();
		group.name = "Intervisibility Network";
		group.userData.gisceneAttributes = {};
		
		var numVisTargets = 0;
		var numUnvisTargets = 0;
		var numOfIntervisiblePairs = 0;
		var geoJSONFeatures = [];
		
		//finalize
		var finalize = function() {
			//add stats
			group.userData.gisceneAttributes["numVisTargets"] = numVisTargets;
			group.userData.gisceneAttributes["numUnvisTargets"] = numUnvisTargets;
			group.userData.gisceneAttributes["numIntervisiblePairs"] = numOfIntervisiblePairs;
			
			this.data.outputs['GIScene:lineOfSight:network:intervisibilityNetwork'] = group;
			this.data.outputs['GIScene:lineOfSight:network:numberOfVisibleTargets'] = numVisTargets;
			this.data.outputs['GIScene:lineOfSight:network:numberOfObstructedTargets'] = numUnvisTargets;
			this.data.outputs['GIScene:lineOfSight:network:numberOfIntervisiblePairs'] = numOfIntervisiblePairs;
			
			var geoJSON = {
				"type" : "FeatureCollection",
				"features" : geoJSONFeatures
			};
			if(inPointsLayer.scene.config.projection){
				geoJSON["crs"] = {
									"type": "name",
									"properties": {
									"name": inPointsLayer.scene.config.projection
									}
							};
			}
			this.data.outputs['GIScene:lineOfSight:network:intervisibilityLines'] = JSON.stringify(geoJSON);
			
			/**
			 *@event execute event has a content property referring to the processes data object with inputs and outputs 
			 */	 
			this.dispatchEvent({type:'execute', content:this.data});
			
			onExecute(this.data);
			
		}.bind(this);
		
		//collect async process results
		
		var onExecuteIntervisProcess = function(data) {
			numFinishedProcesses++;
			console.log("onExecuteIntervis",numFinishedProcesses,"of",numOfProcesses);
			console.log(data);
			var intervisLines = data.outputs['GIScene:intervisibility:intervisibilityLines'];
			group.add(intervisLines);
			
			
			var intervis = data.outputs['GIScene:intervisibility:intervisibility'];
			numVisTargets += parseInt(intervis) % 9;
			numUnvisTargets += 2 - parseInt(intervis) % 9;
			numOfIntervisiblePairs += (parseInt(intervis) % 9 == 2)? 1 : 0;
			
			var geoJSONFeature = JSON.parse(data.outputs['GIScene:intervisibility:intervisibilityLine']);
			delete geoJSONFeature.crs;
			geoJSONFeatures.push(geoJSONFeature);
			
			this.dispatchEvent({type:"progress", content:{total:numOfProcesses, finished:numFinishedProcesses}});
			
			if(numFinishedProcesses == numOfProcesses){
				finalize();
			}else{
				//start next process in queue
				processQueue[numFinishedProcesses].execute(onExecuteIntervisProcess);
			}
		}.bind(this);
		
		//start analysing 
		var queueCounter = 0;
		for(var start=0, l=points.length; start<l-1; start++){
  
		  for(var end=start+1;end < l;end++){
		      
		      var intervisProcess = new GIScene.Process.Intervisibility(inPointsLayer.scene);
		      
		      //setInputs
		      var inputs = {
		      	'GIScene:intervisibility:points'			: [points[start], points[end]],
				'GIScene:intervisibility:observerOffsets'	: [observerOffsets[start], observerOffsets[end]],
				'GIScene:intervisibility:targetOffsets'		: [targetOffsets[start], targetOffsets[end]],
				'GIScene:intervisibility:obstacleLayers'	: obstacleLayers
		      };
		      intervisProcess.setInputs(inputs);
		      
		      //execute has to be quesed one after another
		      //intervisProcess.execute(onExecuteIntervisProcess);
		      processQueue[queueCounter++] = intervisProcess;
		      
		  }
		}
		
		//start working down the queue
		//start first process in queue
		processQueue[0].execute(onExecuteIntervisProcess);
		
	};
};

//Inherit from GIScene.Layer
GIScene.Process.LineOfSightNetwork_allToAll.prototype = Object.create( GIScene.Process.prototype );/**
 * File Format Constants to be used with loaders
 * 
 * @namespace GIScene
 * @class Format
 * @static
 *  
 */

GIScene.Format = {
	/**
	 * @property JSON
	 * @type Number
	 * @static
	 * @final 
	 */
	JSON:0,
	/**
	 * @property JSONBinary
	 * @type Number
	 * @static
	 * @final 
	 */
	JSONBinary:1,
	/**
	 * @property OBJ
	 * @type Number
	 * @static
	 * @final 
	 */
	OBJ:2,
	/**
	 * @property Collada
	 * @type Number
	 * @static
	 * @final 
	 */
	Collada:3,
	/**
	 * @property CTM
	 * @type Number
	 * @static
	 * @final 
	 */
	CTM:4,
	/**
	 * @property Scene
	 * @type Number
	 * @static
	 * @final 
	 */
	Scene:5,
	/**
	 * @property GeoJSON
	 * @type Number
	 * @static
	 * @final 
	 */
	GeoJSON:6
	
};
/**
 * The local file loader will load files from the local file system 
 * 
 * @namespace GIScene
 * @class LocalFileLoader
 * @constructor
 * @param {HTMLInputElement} fileInputElement an input element of type="file" used to choose the file to load
 * @param {String} readAs defines the nature of the result. Can be "text", "dataURL", "binaryString" or "arrayBuffer"
 * @param {Function} onSuccess will have an argument containing the fileReader.result, which depends on the readAs property
 * @param {Function} onProgress will have an argument containing the ProgressEvent
 * @param {Fucntion} onError will have an argument containing the DOMError object of fileReader.error
 */

GIScene.LocalFileLoader = function(fileInputElement, readAs, onSuccess, onProgress, onError) {
	
	this.fileReader = new FileReader();
	
	var loadFile = function(event) {
		
		var fileList = event.target.files;
		var file = fileList[0];
		var filename = file.name;
		
		this.fileReader.onload 		= function(event) { if(onSuccess)  onSuccess(this.fileReader.result, filename); }.bind(this);
		this.fileReader.onprogress 	= function(event) { if(onProgress) onProgress(event, filename); };
		this.fileReader.onerror 	= function(event) { if(onError)    onError(this.fileReader.error, filename); }.bind(this);
		
		
		//start loading
		switch (readAs.toUpperCase()){
			case "TEXT": 
					this.fileReader.readAsText(file);
					break;
			case "DATAURL":
					this.fileReader.readAsDataURL(file);
					break;
			case "BINARYSTRING":
					this.fileReader.readAsBinaryString(file);
					break;
			case "ARRAYBUFFER":
					this.fileReader.readAsArrayBuffer(file);
		}
		
	}.bind(this);
	
	fileInputElement.addEventListener('change', loadFile, false);
	
};/**
 *Loads a geojson file. Provides Methods to load and parse GeoJSON Files/Objects
 *
 * Currently no reprojection is supported, geojson-coords have to be in sceneunits.
 * TODO offset support
 * 
 * @namespace GIScene
 * @class GeoJSONLoader
 * @constructor
 * 
 * @author m.auer
 **/

GIScene.GeoJSONLoader = function() {
	
	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};
	
	this.loader = new THREE.XHRLoader( this.manager ); //?? manager??
	
	this.symbol = THREE.ImageUtils.loadTexture( GIScene.LIBRARYPATH + GIScene.RESOURCESPATH.replace(/([^\/])$/, "$1/") +"resources/images/particle_cross.png");
	
};

GIScene.GeoJSONLoader.prototype = {
	
	constructor : GIScene.GeoJSONLoader,
	
	load: function(url, onLoad, onProgress, onError, heightAttribute) {
		
		var loader = this.loader;
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {
			try{
				this.parse( JSON.parse( text ), onLoad, heightAttribute );
			}
			catch(e){
				console.log("GeoJsonLoader");
				console.log(e);
				console.log("ResponseText", text);
				if(onError)onError(e,text);
				// onLoad({ //send empty result (fail silent)
						// scene: new THREE.Scene(),
						// geometries: {},
						// face_materials: {},
						// materials: {},
						// textures: {},
						// objects: {},
						// cameras: {},
						// lights: {},
						// fogs: {},
						// empties: {},
						// groups: {}
						// }
				// );
			}

		}.bind(this) );
	},
	
	setCrossOrigin : function(value) {
		this.crossOrigin = value;
	},
	
	parse: function(json, callback, heightAttribute) {
		
		var result = new THREE.Scene();
		var type = json.type;
		callback = callback || function(){};
		
//define parser functions
		
		var coord2ToVec3 = function(coord2, height) {
			height = height || 0;
			return new THREE.Vector3(coord2[0], height, -coord2[1]);
		};
		
		var coord3ToVec3 = function(coord3) {
			
			return new THREE.Vector3(coord3[0], coord3[2], -coord3[1]);
		};
		
		var parseGeometry = function(geometry, height) {
			var type = geometry.type;
			var geom3;
			var material;
			var object;
			
			switch (type){
				
				case "Point" :
					geom3 = new THREE.Geometry();
					var vertex = (!height && geometry.coordinates.length > 2)? coord3ToVec3(geometry.coordinates) : coord2ToVec3( geometry.coordinates, height ); 
					geom3.vertices.push( coord2ToVec3( geometry.coordinates, height ) );
					material = new THREE.ParticleBasicMaterial({
												color:new THREE.Color( 0xff0000 ),
												sizeAttenuation:false,
												size:32,
												map:this.symbol,
												alphaTest:0.5	
											});
					object = new THREE.ParticleSystem(geom3, material);
					break;
					
				default :
					console.error(type,"Not supported by GeoJSONLoader");
					
			};
			
			return object;
		}.bind(this);
		
		// var parseProperties = function(properties) {
// 			
		// };
		
		var parseFeature = function(feature, heightAttribute) {
			
			var height = parseFloat(feature.properties[heightAttribute]) || null;
			
			var object = parseGeometry(feature.geometry, height);
			object.userData.gisceneAttributes = feature.properties;
			return object;
		};
		
		var parseFeatureCollection = function(featureCollection) {
			
		};
		
		//DO THE PARSING
		switch (type) {
			
			case "Feature": 
					result.add( parseFeature( json, heightAttribute ) );
					break;
					
			case "FeatureCollection":
					var features = json.features;
					for(var i=0,j=features.length; i<j; i++){
						result.add( parseFeature( features[i], heightAttribute ) );
					};
					break;
					
			default: console.log(type, "GeoJson type not supported by GeoJSONLoader");
		}
		
		callback(result);
		return result;
	},
	
	getType : function(geojson) { //FeatureCollection | Feature | Geometry
		return geojson.type;
	},
	
	getExampleValues : function(geojson) {
		
		var type = this.getType(geojson);
		
		switch (type) {
			
			case "Feature" : 
					
					var properties = geojson.properties;
					var exampleValues = [];
					
					
					for (property in properties){
					  exampleValues.push(properties[property]);
					}

					return exampleValues;
		
					break;
			case "FeatureCollection" : 
					var properties = geojson.features[0].properties;
					var exampleValues = [];
					
					
					for (property in properties){
					  exampleValues.push(properties[property]);
					}

					return exampleValues;
		
					break;
			default: 
				if(this.isGeometry(geojson)){ //type is Geometry
					return [];break;
				}
			else{
				alert("GeoJSON seems to be invalid");return [];	
			}
				
		}
	},
	
	getAttributeNames : function(geojson) {
		
		var type = this.getType(geojson);
		
		switch (type) {
			
			case "Feature" : return Object.keys(geojson.properties);break;
			case "FeatureCollection" : return Object.keys(geojson.features[0].properties);break;
			default: 
				if(this.isGeometry(geojson)){ //type is Geometry
					return [];break;
				}
			else{
				alert("GeoJSON seems to be invalid");return [];	
			}
				
		}
	},
	
	isGeometry: function(geojson) {
		return geojson.type == "Point" || "MultiPoint" || "LineString" || "MultiLineString" || "Polygon" || "MultiPolygon" || "GeometryCollection";
	},
	
	
	hasZCoordinates : function(geojson) {	
		
		var type = this.getType(geojson);
		
		var hasZFromCoordinates= function (coordinates){

			if ( typeof (coordinates[0]) == "object") {

				return findFirstCoordinate(coordinates[0]);

			} else {

				return coordinates.length > 2;
			}

		};

		var hasZFromGeometry = function(geojson) {
			if(geojson.type == "GeometryCollection"){
				return hasZFromCoordinates(geojson.geometries[0].coordinates);
			}
			else{
				return hasZFromCoordinates(geojson.coordinates);
			}
		};
		
		var hasZFromFeature = function(geojson) {
			return hasZFromGeometry(geojson.geometry);
		};
		
		switch (type) {
			case "Feature" : return hasZFromFeature(geojson);break;
			
			case "FeatureCollection" : return hasZFromFeature(geojson.features[0]);break;
			default: 
					return hasZFromGeometry(geojson);
			
		}
		
		}
	
};
/**
 * Loader class to load different formats
 * 
 * @namespace GIScene
 * @class ModelLoader
 * @constructor
 * 
 */

GIScene.ModelLoader = function () {
	
	this.url    = null;
	this.format = null;
	var usercallback = null;
	this.loader = null;
	
	var callback = function(geometry, materials){
		
		// console.log("ModelLoader:callback()");
		
		if(this.format == GIScene.Format.Scene){
			var result = geometry.scene; //SceneLoader returns a result object not geometry
		}
		
		else {//callback for other formats than GIScene.Format.Scene

			//Mesh or ParticleSystem?
			var objectType = (geometry.faces.length == 0) ? "ParticleSystem" : "Mesh";		
			
			//if material is defined use it else use default material
			
			if (materials && materials.length != 0 /*no empty array*/) {

				//MeshFaceMaterial 
				if (materials.length >= 2) {
					materials = new THREE.MeshFaceMaterial(materials);
				} else if (!materials[0].map && materials[0].name.toLowerCase() == "default") {
					//if there is only a debug material use a default MeshLambert or ParticleMaterial 
					if (objectType == "Mesh"){
					materials = new THREE.MeshLambertMaterial({
						color : 0xD2B48C, //0xFFFF66(gelb),
						ambient : 0x8B7355, //0x7B7B33,
						emissive : 0x000000,
						shading : THREE.FlatShading
					});
					} else {
						materials = new THREE.ParticleBasicMaterial({color: new THREE.Color(0x0), size:0.2}); //brown 0xD2B48C
					}
				} else if ( objectType == "ParticleSystem" ){
					// if ParticleSystem try to use some of the MeshMaterialProperties
					materials[0].size = 0.2;
					materials[0].vertexColors = THREE.VertexColors;
					materials = new THREE.ParticleBasicMaterial( materials[0] );					
				}else {
					// Material is Mesh Basic, Lambert or Phong Material as specified in file
					materials = materials[0];
				}
				
			} else {
				//no material defined: guess one!
				
				//Meshes
				if (objectType == "Mesh"){
					//Meshes with vertexColors
					if (geometry.faces[0].vertexColors.length > 0) {
						materials = new THREE.MeshLambertMaterial({
							shading : THREE.FlatShading,
							vertexColors : THREE.VertexColors
						});
					} else if (geometry.faces[0].color.getHex() != 0xFFFFFF ) {
						// Meshes with faceColors (white is default so if set it will probably differ)
						materials = new THREE.MeshLambertMaterial({
							shading : THREE.FlatShading,
							vertexColors : THREE.FaceColors
						});
					} else {
						//default fallback material
						materials = new THREE.MeshLambertMaterial({
						color : 0xD2B48C, //0xFFFF66(gelb),
						ambient : 0x8B7355, //0x7B7B33,
						emissive : 0x000000,
						shading : THREE.FlatShading
					});
					}
				}//is Mesh end
				
				//ParticleSystems
				else{
					materials =undefined;//= new THREE.ParticleBasicMaterial({ vertexColors: THREE.VertexColors , size:0.2}); //0xD2B48C brown
				}
			}

			
			
// 			
			// if (!materials || materials.length == 0 || (materials.length == 1 && !materials[0].map && materials[0].name.toLowerCase() == "default")) {
				// //particles
// 
				// if (geometry.faces.length == 0) {
					// alert('particles');
					// materials = new THREE.ParticleBasicMaterial({
						// size : 1
					// });
				// } else
				// //@TODO how to determine Lines?
				// //if geometry has vertexColors other material
				// if (geometry.faces[0].vertexColors.length > 0) {
					// materials = new THREE.MeshLambertMaterial({
						// // color : 0xD2B48C, //0xFFFF66(gelb),
						// // ambient: 0x8B7355, //0x7B7B33,
						// // emissive : 0x000000,
						// shading : THREE.FlatShading,
						// vertexColors : THREE.VertexColors
					// });
				// } else {
					// materials = new THREE.MeshLambertMaterial({
						// color : 0xD2B48C, //0xFFFF66(gelb),
						// ambient : 0x8B7355, //0x7B7B33,
						// emissive : 0x000000,
						// shading : THREE.FlatShading,
						// // vertexColors:THREE.VertexColors
					// });
				// }
			// } else {
				// materials = new THREE.MeshFaceMaterial(materials);
			// }
			
			geometry.dynamic = true;

			var mesh = new THREE[ objectType ](geometry, materials); //Mesh or ParticleSystem

			var result = new THREE.Scene();

			result.add(mesh);
		}
					
			
		/** The load event is triggered after a model/scene has been loaded from an asynchronous XmlHttpRequest.
		 *	The returned event object has a content property with a THREE.Scene() Object containing the model as child.
		 *  @event load 
		 */
		this.dispatchEvent( { type: 'load', content: result } );
		if(usercallback)usercallback(result);
	}.bind(this);
	
	/**
	 * load function to load Models from different formats. 
	 * 
	 * @method load
	 * @param {String} url
	 * @param {Integer} format use constants defined in GIScene.Format
	 * 
	 * 
	 * To get the resulting THREE.Scene() Object add an event listener on 'load':
	 * @example
	 modelLoader.addEventListener('load', onload);
	 modelLoader.load(url, format);
	 * 
	 * 
	 */
	
	this.load = function(url, format, onSuccess, onProgress, onError){
		var retries = 5;
		usercallback = onSuccess;
		/** The load event is triggered before a model/scene will be loaded
		 *
		 *  @event beforeLoad 
		 */
		this.dispatchEvent( { type: 'beforeLoad', content: null } );
		
		this.url = url;
		this.format = format;
		
		switch (format){
			case GIScene.Format.JSON:
				this.loader = new THREE.JSONLoader();
				// loader.withCredentials = true;
				// loader.crossOrigin = 'use-credentials';
				this.loader.load(url, callback);
				break;	
			case GIScene.Format.JSONBinary:
				this.loader = new THREE.BinaryLoader();
				// loader.withCredentials = true;
				// loader.crossOrigin = 'use-credentials';
				this.loader.load(url, callback);
				break;
			case GIScene.Format.CTM:
				this.loader = new THREE.CTMLoader();
				//loader.withCredentials = true;
				// loader.crossOrigin = 'use-credentials';
				this.loader.load(url, callback, {useWorker:true, useBuffers:false});
				break;
			case GIScene.Format.Scene:
				this.loader = new THREE.SceneLoader();
				
				var onSceneError = function(event) {
					retries--;
		            if(retries > 0) {
		                console.log("Retrying...: "+url);
		                setTimeout(function(){this.loader.load(url, callback, onProgress, onSceneError);}.bind(this), 1000);
		            } else {
		                //I tried and I tried, but it just wouldn't work!
		                console.error("Tried 5 times without success: " + url);
		                onError(event);
		            }
					
					
					// this.loader.load(url, callback, onProgress, onError);
				}.bind(this);
				
				// this.loader.loader.request.withCredentials = true; //???
				// this.loader.crossOrigin = 'use-credentials';
				this.loader.load(url, callback, onProgress, onSceneError); //onError
				break;
			default:
				console.log('Unknown Format. - GIScene/ModelLoader.js');			
		};
		// return loader;
	};
	
	/**
	 * abort function to abort a running request
	 * fires an abort event
	 * 
	 * @method abort
	 *  
	 */
	this.abort = function() {
		if(this.loader.loader && this.loader.loader.request){ //Only for Sceneloader at the moment
			this.loader.loader.request.abort();
			/** The abort event is triggered after a model/scene request was aborted
			 *
			 *  @event abort 
			 */
			this.dispatchEvent( { type: 'abort', content: null } );
		}
		else{console.log("abort for this loader not yet implemented.");}
	};
};



//Provide EventDispatcher Functions
GIScene.ModelLoader.prototype = {
	
	constructor : GIScene.ModelLoader,
	
	addEventListener: THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener: THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener: THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent: THREE.EventDispatcher.prototype.dispatchEvent
	
};/**
 * Abstract class for Service interfaces
 * 
 * @namespace GIScene
 * @class Service 
 */

GIScene.Service = function() {};/**
 * Service Interface to load data from a W3DS OGC Discussion Paper Specification Implementation
 * 
 * @namespace GIScene
 * @class Service.W3DS_0_4_0
 * @constructor
 * @extends GIScene.Service
 * @param {Object} config a config object for this class
 * @param {Object} params an object to specify service parameters, e.g. layer, crs, offset
 */

GIScene.Service.W3DS_0_4_0 = function(config, params) {
	
	var defaults = {
		url:null,
		withCredentials :false,
		tileSizes : null
	};
	
	var defaultParams = {
		service : "W3DS",
		version : "0.4.0",
		format  : "model/threejs",
		crs		: null,
		layer	: null,
		offset	: null
	};
	

//Properties
	this.config = GIScene.Utils.mergeObjects(defaults, config);
	this.params = GIScene.Utils.mergeObjects(defaultParams, params);
	
	this.url = this.config.url.trim().replace(/(\/|\?)*$/,"?");
	
	// var xhr = new XMLHttpRequest();

//W3DS Methods

//getCapabilities

//getLayerInfo

//getFeatureInfo

//getScene
	this.getGetSceneUrl = function(gridIndex, grid) {
		var request		= "GetScene";
		var tileSize = gridIndex.tileSize;
		var boundingBox = grid.getBoundingBoxFromIndex(gridIndex);
		var lowerLeft	= new GIScene.Coordinate2().fromVector2(new THREE.Vector2(boundingBox.left, boundingBox.bottom)).add(grid.sceneOffset).toArray().join(","); //???
		var upperRight	= new GIScene.Coordinate2().fromVector2(new THREE.Vector2(boundingBox.right, boundingBox.top)).add(grid.sceneOffset).toArray().join(",");
		
//this.origin.toVector2().clone().sub(GIScene.Utils.vector3ToVector2(_sceneOffset));
		var paramsString = [
							"SERVICE="	+ this.params.service,
							"REQUEST="	+ request,
							"VERSION="	+ this.params.version,	
							"CRS="		+ this.params.crs,
							"BOUNDINGBOX=" + lowerLeft+","+upperRight,
							// "MINHEIGHT="+
							// "MAXHEIGHT="+
							// "SPATIALSELECTION="+"contains_center", //option not supported
							"FORMAT=" 	+ this.params.format,
							"LAYERS="	+ this.params.layer, //layers vs layer??
							// "STYLES="+
							// "LODS="+
							// "LODSELECTION="+
							// "TIME="+
							(this.params.offset) ? "OFFSET=" + this.params.offset : ""
							// "EXCEPTIONS=+"
							// "BACKGROUND="+
							// "LIGHT="+
							// "VIEWPOINTS="+
							].join("&");
		
		return this.url + paramsString;		

	};

	this.getGetTileUrl = function(gridIndex){
		var method = "GET";
		var tileLevel 	= this.config.tileSizes.indexOf(gridIndex.tileSize);
		var tileCol		= gridIndex.x;
		var tileRow		= gridIndex.y;
		var request		= "GetTile";
				
		var paramsString = [
							"SERVICE="	+ this.params.service,
							"REQUEST="	+ request,
							"VERSION="	+ this.params.version,
							"FORMAT=" 	+ this.params.format,
							"CRS="		+ this.params.crs,
							"LAYER="	+ this.params.layer,
							"TILELEVEL="+ tileLevel,
							"TILECOL="	+ tileCol,
							"TILEROW="	+ tileRow	
							].join("&");
		
		return this.url + paramsString;		
	};
	
	 /** getTile Requset to retrieve tiles from a W3DS Service
	 * 
	 * @method getTile
	 * @param {Object} params specify the following properties: {String} layer, {Number} tileLevel, {Number} tileCol, {Number} tileRow
	 * @param {Function} onSuccess will be called with the response when the request was successful
	 * @param {Function} onError will be called when the request failed
	 */
	
	this.getTile = function(gridIndex, onSuccess,  onError){
		
		var url = this.getGetTileUrl(gridIndex);

		onSuccess		= onSuccess || function() {};
		onError			= onError	|| function() {};
		var xhr = new XMLHttpRequest();
		xhr.addEventListener('load' , onSuccess, false);
		xhr.addEventListener('error', onError  , false);
		xhr.addEventListener('error', function(e) {console.log("Error on GIScene.Service.W3DS_0_4_0");console.log(e);}, false);
		xhr.open(method, url, true);
		//xhr.setRequestHeader("Authorization", "Basic " + btoa("mauer:Kangoo.2000"));
		xhr.withCredentials = this.config.withCredentials;
		try {xhr.send(null);}
		catch (e){console.log(e);}
		;
	};
	

};

//Inherit
GIScene.Service.W3DS_0_4_0.prototype = Object.create(GIScene.Service.prototype);
/**
 * Service Interface to load data from a W3DS OGC Discussion Paper Specification Implementation
 * 
 * @namespace GIScene
 * @class Service.W3DS_0_4_1
 * @constructor
 * @extends GIScene.Service
 * @param {Object} config a config object for this class
 * @param {Object} params an object to specify service parameters, e.g. layer, crs, offset
 */

GIScene.Service.W3DS_0_4_1 = function(config, params) {
	
	var defaults = {
		url:null,
		withCredentials :false,
		tileSizes : null
	};
	
	var defaultParams = {
		service : "W3DS",
		version : "0.4.1",
		format  : "model/threejs",
		crs		: null,
		layer	: null,
		offset	: null,
		lods	: null
	};
	

//Properties
	this.config = GIScene.Utils.mergeObjects(defaults, config);
	this.params = GIScene.Utils.mergeObjects(defaultParams, params);
	
	this.url = this.config.url.trim().replace(/(\/|\?)*$/,"?");
	
	// var xhr = new XMLHttpRequest();

//W3DS Methods

//getCapabilities

//getLayerInfo

//getFeatureInfo

//getScene
	this.getGetSceneUrl = function(gridIndex, grid) {
		var request		= "GetScene";
		var tileSize = gridIndex.tileSize;
		var boundingBox = grid.getBoundingBoxFromIndex(gridIndex);
		var lowerLeft	= new GIScene.Coordinate2().fromVector2(new THREE.Vector2(boundingBox.left, boundingBox.bottom)).add(grid.sceneOffset).toArray().join(","); //???
		var upperRight	= new GIScene.Coordinate2().fromVector2(new THREE.Vector2(boundingBox.right, boundingBox.top)).add(grid.sceneOffset).toArray().join(",");
		
//this.origin.toVector2().clone().sub(GIScene.Utils.vector3ToVector2(_sceneOffset));
		var paramsString = [
							"SERVICE="	+ this.params.service,
							"REQUEST="	+ request,
							"VERSION="	+ this.params.version,	
							"CRS="		+ this.params.crs,
							"BOUNDINGBOX=" + lowerLeft+","+upperRight,
							// "MINHEIGHT="+
							// "MAXHEIGHT="+
							// "SPATIALSELECTION="+"contains_center", //option not supported
							"FORMAT=" 	+ this.params.format,
							"LAYERS="	+ this.params.layer, //layers vs layer??
							// "STYLES="+
							(this.params.lods)   ? "LOD="	 + this.params.lods   : "", //should be LODS see OGC Discussion Paper
							// "LODSELECTION="+
							// "TIME="+
							(this.params.offset) ? "OFFSET=" + this.params.offset : ""
							// "EXCEPTIONS=+"
							// "BACKGROUND="+
							// "LIGHT="+
							// "VIEWPOINTS="+
							].join("&");
		
		return this.url + paramsString;		

	};

	this.getGetTileUrl = function(gridIndex){
		var method = "GET";
		var tileLevel 	= this.config.tileSizes.indexOf(gridIndex.tileSize);
		var tileCol		= gridIndex.x;
		var tileRow		= gridIndex.y;
		var request		= "GetTile";
				
		var paramsString = [
							"SERVICE="	+ this.params.service,
							"REQUEST="	+ request,
							"VERSION="	+ this.params.version,
							"FORMAT=" 	+ this.params.format,
							"CRS="		+ this.params.crs,
							"LAYER="	+ this.params.layer,
							"TILELEVEL="+ tileLevel,
							"TILECOL="	+ tileCol,
							"TILEROW="	+ tileRow	
							].join("&");
		
		return this.url + paramsString;		
	};
	
	 /** getTile Requset to retrieve tiles from a W3DS Service
	 * 
	 * @method getTile
	 * @param {Object} params specify the following properties: {String} layer, {Number} tileLevel, {Number} tileCol, {Number} tileRow
	 * @param {Function} onSuccess will be called with the response when the request was successful
	 * @param {Function} onError will be called when the request failed
	 */
	
	this.getTile = function(gridIndex, onSuccess,  onError){
		
		var url = this.getGetTileUrl(gridIndex);

		onSuccess		= onSuccess || function() {};
		onError			= onError	|| function() {};
		var xhr = new XMLHttpRequest();
		xhr.addEventListener('load' , onSuccess, false);
		xhr.addEventListener('error', onError  , false);
		xhr.addEventListener('error', function(e) {console.log("Error on GIScene.Service.W3DS_0_4_0");console.log(e);}, false);
		xhr.open(method, url, true);
		//xhr.setRequestHeader("Authorization", "Basic " + btoa("mauer:Kangoo.2000"));
		xhr.withCredentials = this.config.withCredentials;
		try {xhr.send(null);}
		catch (e){console.log(e);}
		;
	};
	

};

//Inherit
GIScene.Service.W3DS_0_4_0.prototype = Object.create(GIScene.Service.prototype);
/**
 * This class describes a style object with a name, title, material and definitions on which objects of a layer the style should be applied
 * 
 * @namespace GIScene
 * @class Style
 * @constructor
 * @param {Object} config 
 * @example
 * 		var style = new GIScene.Style({
 * 			name  : 	'myStyle1' 						// [optional] should be unique
 * 			title :	'My Style No. 1',					// something nice to display
 * 			material : new THREE.MeshBasicMaterial(),	// the material
 * 			rootObjectKeyAttribute 	: 'geom_id',		// [optional]
 * 			rootObjectKeyValues		: [22, 24, 42, 57],	// [optional]
 * 			recursive : true							// [optional] if all descendants should be styled the same way
 * 		});
 */

GIScene.Style = function(config) {
	
	var defaults = {
		name 	 	: null,
		title	 	: 'unnamed',
		material 	: null,
		// either nothing, direct Object references OR a list of objects specified by keyAttribute values
		rootObjects	: null, //array of objects to be styled
		rootObjectKeyAttribute : null, //unique and not null attribute
		rootObjectKeyValues : [], //List of "ID"s to be found in the rootObjectKeyAttribute 
		
		recursive	: true
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	//set class properties
	for ( property in this.config ){
		this[property] = this.config[property];
	}
	
	this.id		= GIScene.idCounter++;
	this.name	= this.config.name || this.id;
	
};/**
 * Base class used for Layer classes
 * 
 * @namespace GIScene
 * @class Layer
 * @constructor
 * @param {String} name the layer name for display purposes
 * @param {Object} [config] the layer configuration object
 *  
 * @author mcauer https://github.com/mcauer
 */

GIScene.Layer = function (name, config) {
	
	//Layer properties
	var defaults = {
		
		id:null, //@TODO create unique Ids that can be overridden by a user config
		
		//appearance
		visibility : true, 
		
		opacity : 1,		
		overrideMaterial:null, 
		//
		projection : null,
		
		offset: new GIScene.Coordinate3(0,0,0),
		
		listeners	:[],
		
		styles		:[], //container for optional styles (overrideMaterials)
		
		//remoteAttributes vs. localAttributes
		//attributeService:{
			// baseURL,
			// singleObjectSchema: ?layer=abc&q={id} || /{id} etc  (id has to be a field) 
			// pagingSchema: ?layer=abc&pageFrom={pageFrom}&pageTo={pageTo}
		// }
		attributeReader : null, //object with function to fill data into the object attributes
		// {
			// 'geom_id':  function(object){return (object.name.split('_')[1]) || null;},
			// 'attr_id':  function(object){return (object.name.split('_')[2]) || null;},
			// 'nodetype': function(object){return (object.name.split('_')[0]) || null;},
// 		
		// },
		
		properties:{
			fields:[
			//{name:'geom_id', alias:'Geometry ID', type:'int', comment:''}
			//{name:'attr_id', alias:'Attribute ID', type:'int', comment:''}
			//{name:'nodetype', alias:'Node Type', type:'text', comment:''}
			],
			//primaryKey:'geom_id' //is unique and not null
		},
		attributeTable:[
			//{geom_id:13}
		]
		
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	this.id	= this.config.id || GIScene.idCounter++; //  null; //@TODO create unique Ids
	
	this.name = null;
	
	this.offset = null; //GIScene.Coordinate3()
	
	var translateLayer = null; //THREE.Vector3()  will be computed automatically onSetScene
	
	this.root = null; //should be a THREE.Scene() Object
	
	this.scene = null;
	
	this.loader = null;
	
	this.visibility = null;
	
	this.selectControl = null; //set on setScene
	
	this.attributeReader = null;
	
	this.selectionQueryStack = null; //will hold an array of queryObjects to be processed sequentially
	
	var defaultStyle = new GIScene.Style({title: 'default style', material: this.config.overrideMaterial});
	
	this.styles = [defaultStyle];
	Array.prototype.push.apply(this.styles, this.config.styles);
	
	this.init = function(){
		//@TODO create unique Id
		
		this.name = name;
		this.root = new THREE.Scene();
		this.root.name = 'layer' + ((this.name)? "_"+this.name : "");
		this.offset = this.config.offset;
		this.loader = new GIScene.ModelLoader();
		this.attributeReader = this.config.attributeReader;
		
		//@TODO check visibility onload
		this.visibility = this.config.visibility;
		
	};
	
	this.add = function(node, parent){
		parent.add(node);
	};
	
	this.remove = function(node){
		node.parent.remove(node);
	};
	
	this.setScene = function(scene){
		this.scene = scene;
		/**
		 *@event setScene
		 */
		this.dispatchEvent({
			type : 'setScene', content:scene
		});
	};
	

	
	/**
	 * Sets the opacity value for the whole layer
	 * 
	 * @method setOpacity
	 * @param {Number} opacity
	 */
	this.setOpacity = function(opacity) { 
		
		this.root.traverse(function(object) {

			GIScene.Utils.WorkingMaterial.setOpacity(object,opacity);

			// if (object.material && !(object instanceof THREE.Sprite)) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
					// //set flag
					// object.userData.workingMaterialFlags = GIScene.WORKINGMATERIALFLAGS.OPACITY;
				// }
// 				
				// //no wm --> create and set flag and mode
// 					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (opacity == object.userData.originalMaterial.opacity || opacity == 'default'){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.OPACITY;	
				// }
// 								
				// //set property
				// if(opacity == 'default'){
					// object.material.opacity = object.userData.originalMaterial.opacity;
					// object.material.transparent = (object.material.opacity < 1 ) ? true : false;
					// object.material.depthTest = (object.material.opacity < 1 ) ? false : true;
				// }
				// else{
					// object.material.opacity = opacity * object.userData.originalMaterial.opacity;
					// object.material.transparent = (object.material.opacity < 1 ) ? true : false;
					// object.material.depthTest = (object.material.opacity < 1 ) ? false : true;
				// }
// 					
				// //check if wm still in use --> false remove wm and switch to orignal
				// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
				// }
// 				
			// }
		}
		);
	};
	
		/**
	 * add a style to the layers styles list
	 * @method addStyle 
 	 * @param {GIScene.Style} style
	 */
	this.addStyle = function(style) {
		this.styles.push(style);
		/**
		 *@event addStyle 
		 */
		this.dispatchEvent({type:'addStyle' , content:{layer:this, style: style}});
	};
	
	/**
	 * remove an existing style from the layers style list 
 	 * @method removeStyle
 	 * @param {GIScene.Style} style
	 */
	this.removeStyle = function(style){
		for (var i = 0, l = this.styles.length; i<l; i++){
			if (this.styles[i] === style){ 
			
				this.styles.splice(i,1); 
				/**
				 *@event removeStyle 
				 */
				this.dispatchEvent({type:'removeStyle' , content:{layer:this, style: style}});
			}
		}
	};
	
	/**
	 * remove style, its material and textures from memory 
	 * @method disposeStyle
	 * @param {GIScene.Style} style
	 */
	this.disposeStyle = function(style){
		
		this.removeStyle(style);
		
		var materials = [], textures=[];
		//get materials
		if (style.material) {
				if (style.material instanceof THREE.MeshFaceMaterial) {
					style.material.materials.forEach(function(material) {
						if (! GIScene.Utils.arrayContains(materials, material)) {
							materials.push(material);
						};
					});
				} else {

					if (! GIScene.Utils.arrayContains(materials, style.material)) {
						materials.push(style.material);
					};
				}
			}
		
		//get textures
		materials.forEach(function(material) {
			var maps = ["map", "lightMap", "bumpMap", "normalMap", "specularMap", "envMap", "texture"]; //texture exists in RasterOverlayMaterial
			for (var i = 0, j = maps.length; i < j; i++) {
				if (material[maps[i]] && material[maps[i]] != null && ! GIScene.Utils.arrayContains(textures, material[maps[i]])) {
					textures.push(material[maps[i]]);
				};
			};
		}); 
	
		//dispose textures, materials
		textures.forEach(function (texture) {
		  texture.dispose();
		});
		textures = null;
		
		materials.forEach(function (material) {
		  material.dispose();
		});
		materials = null;
		
		delete style.material;
		style = null;	
		
	};
	
	//@TODO destroy function to remove everything from memory --> now implemented Scene.disposeLayer()
	
	//start auto initialization 
	this.init();
	
	// when added to a scene 
	var onSetScene = function(event) {
		var scene = event.content;
		this.offset = this.config.offset;
		translateLayer = (scene) ? this.offset.toVector3().sub(scene.config.offset.toVector3())
								 : new THREE.Vector3();
								 ;
		this.root.position = translateLayer;
		this.root.updateMatrix();
		this.root.updateMatrixWorld();
		console.log("translateLayer: "+translateLayer.toArray());
		
		//configure select control
		if(scene){
			this.selectControl = new GIScene.Control.Select([],scene.camera,{multi:true, selectColor: 0xff8000});
			this.selectControl.selectables = this.root.getDescendants();	
			scene.addControl(this.selectControl);
			
			var onBeforeRemove = function(event) {
				if(event.content === this){
					scene.removeControl(this.selectControl);
					this.selectControl.selectables = [];
					this.selectControl = null;
					scene.removeEventListener('beforeremovelayer', onBeforeRemove);
				}
			}.bind(this);
			scene.addEventListener('beforeremovelayer', onBeforeRemove);
		}
		
		//@TODO implement selectables update according to LayerType (Fixed, Grid)
	}.bind(this);
	this.addEventListener('setScene', onSetScene);
};

//Provide EventDispatcher Functions
GIScene.Layer.prototype = {
	
	constructor : GIScene.Layer,
	
	/**
	 * get Objects by a evaluation function which recursively tries to match the objects of the layer
	 * 
	 * @method getObjectsBy
	 * @param {Function} callback
	 * @return {Array} matches
	 */
	getObjectsBy : function(callback) {
		return GIScene.Utils.getObjectsBy(this.root,callback);
	},
	
	/**
	 * set or modify the current layer selection by attribute query
	 * 
	 * @method selectByAttributes
	 * @param {String} attributeName must be available in object.userData.gisceneAttributes
	 * @param {String} operator defines how to compare the given values with the object attributes
	 * @param {Mixed} value the values for the selection criteria
	 * @param {String} selectMode can be new,add,sub,intersect
	 * 
	 * @example
	 * 	{
	 * 		"attributeName" : "attr_id",
	 * 		"operator"		: "IN", //"==","!=" .... TODO
	 * 		"value"			: [2393,1234],
	 * 		"selectMode"	: "new"
	 * 	}
	 * 
	 */
	
	selectByAttributes : function(queryObjectStack, root, interaction) {
		
		var root = (!root)? this.root : root;
		
		this.selectionQueryStack = (queryObjectStack instanceof Array)? queryObjectStack : [queryObjectStack];
		
		for(var i=0,j=this.selectionQueryStack.length; i<j; i++){
		  	
		  	var queryObject = this.selectionQueryStack[i];
		
			var attr 		= queryObject.attributeName;
			var operator 	= queryObject.operator;
			var value		= queryObject.value;
			var selectMode	= queryObject.selectMode || "new"; //defaults to "new"
			
			var queryResults=[];
			
			//operator functions
			var equals_to = function(object,attr,value) {
				return object.userData.gisceneAttributes[attr] == value;
			}; 
			var contains = function(object,attr,value) { //contains
				var regExp = new RegExp(String(value), "gi");
				return regExp.test(String(object.userData.gisceneAttributes[attr]));
			}; 
	
			
			switch (operator){
				case "EQUALS_TO" || "==":
							queryResults = GIScene.Utils.getObjectsBy(root,function(object){
								return equals_to(object,attr,value);
							});
							break;
				case "IN":
							for(var i=0,j=value.length; i<j; i++){
							    var tempResults = GIScene.Utils.getObjectsBy(root,function(object){
							  	return equals_to(object,attr,value[i]);
							  }); 
							  Array.prototype.push.apply(queryResults, tempResults);
							};
							break;
				case "CONTAINS" || "~":
							queryResults = GIScene.Utils.getObjectsBy(root,function(object){
								return contains(object,attr,value);
							});
							break; 
			}
		   
		   //select
		   switch (selectMode){
		   	case "new": 
		   				root.traverse(function(object){
		   					if(object.userData.isSelected){
		   						this.selectControl.unselect(object,interaction);
		   					}
		   				}.bind(this));
		   				//this.selectControl.unselectAll();
		   				
		   				for(var i=0,j=queryResults.length; i<j; i++){
							 this.selectControl.select( queryResults[i],interaction );
						   };
		   				break;
		   	case "add":
		   				var temp_toggleValue = this.selectControl.config.toggle;
		   				this.selectControl.config.toggle = false;
		   				for(var i=0,j=queryResults.length; i<j; i++){
							this.selectControl.select( queryResults[i],interaction );
						   };
						this.selectControl.config.toggle = temp_toggleValue;
		   				break;
		   }
		};
	},
	
	//@TODO add parameter {Array} ids to apply override Material only to the matched ids for coloring by Attributes
	//@TODO removeOverrideMaterial
	setOverrideMaterial : function(node, overrideMaterial, keepWorkingMaterialProperties) {
		
		var keepWorkingMaterialProperties = keepWorkingMaterialProperties || true;
				
		if(overrideMaterial instanceof THREE.Material || !overrideMaterial){
			//update properties
			this.config.overrideMaterial = overrideMaterial;
			//rescursively apply overrideMaterial
			node.traverse(
				function(obj) {
					if(obj.material){
						/**
						 *@event beforeSetOverrideMaterial
						 */
						this.dispatchEvent({
							type : 'beforeSetOverrideMaterial', content:{object: obj, overrideMaterial: overrideMaterial, layer: this}
						});
						
						//set overrideMaterial
						
						if(overrideMaterial){
							//store original material the first time
							if(!obj.userData.overriddenMaterial){
								obj.userData.overriddenMaterial = obj.material; //@TODO maybe better check for original material, in case material has already been changed by workingMaterial properties
							}
							else
							{
								//dispose overridden material
								if(obj.material.isShared === false){ // === important for not evaluating undefined
									GIScene.Utils.disposeObject(obj, false, true, true);
								 }
							}
							
							//if keep WM props
							//collect props
							if(keepWorkingMaterialProperties) {var workingMaterialProperties = GIScene.Utils.WorkingMaterial.getValues(obj);}
							
							//cleanup
							delete obj.userData.originalMaterial;
							obj.userData.workingMaterialFlags = 0;
							
							//assign new override material
							obj.material = this.config.overrideMaterial;
							
							//if keep WM props
							//reassign WM props
							if(keepWorkingMaterialProperties) {GIScene.Utils.WorkingMaterial.setValues(obj, workingMaterialProperties);}
							
						}
						//remove overrideMaterial
						else{
							if(obj.userData.overriddenMaterial && obj.userData.overriddenMaterial instanceof THREE.Material){
								obj.material = obj.userData.overriddenMaterial;
								delete obj.userData.overriddenMaterial;
							}
							
						}
						
						
						
						/**
						 *@event afterSetOverrideMaterial
						 */
						this.dispatchEvent({
							type : 'afterSetOverrideMaterial', content:{object: obj, overrideMaterial: overrideMaterial, layer: this}
						});
					}
					
					if(this.config.overrideMaterial && this.config.overrideMaterial.shading == THREE.SmoothShading && obj.geometry && (!obj.geometry.normals || obj.geometry.normals.length == 0)){
						obj.geometry.computeVertexNormals();
					}
					
				}.bind(this)
			);
		}
	},
	
	setVisibility : function(visibility){
		this.root.traverse(
			function(obj){
				obj.visible = visibility;
			}
		);
		this.visibility = visibility;
		/**
		 *@event changedvisibility
		 *listener function will get the following event object as argument 
		 *@example
		 * 	eventObject = {
		 * 		content:{
		 * 			layer:{GIScene.Layer}, 
		 * 			visibility:{Boolean}
		 * 		}
		 * 	}			
		 */
		this.dispatchEvent({type:'changedvisibility', content:{layer:this, visibility:this.visibility}});
	},
	
	showAttributeTable : function() {
		//@TODO showAttributeTable
	},
	
	/**
	 * @method getAttributeNames
	 * @return {Array(String)} attributeNames
	 */
	getAttributeNames : function() {
		var attributeNames = [];
		this.root.traverse(function(object){
			if(object.userData.gisceneAttributes && Object.keys(object.userData.gisceneAttributes).length > 0 ){
				return attributeNames = Object.keys(object.userData.gisceneAttributes);
			}
		});
		return attributeNames;
	},
	
	getExampleValues : function() {
		var exampleValues = [];
		this.root.traverse(function(object){
			if(object.userData.gisceneAttributes && Object.keys(object.userData.gisceneAttributes).length > 0 ){
				exampleValues = [];
				for (attr in object.userData.gisceneAttributes){
					exampleValues.push(object.userData.gisceneAttributes[attr]);
				}
				return exampleValues;
			}
		}.bind(this));
		return exampleValues;
	},
	
	/**
	 * apply a style to the layer 
	 * @method setActiveStyle
 	 * @param {GIScene.Style} style
	 */
	setActiveStyle : function(style) {
		
		if( !style ||  (typeof style == 'string' && style.toLowerCase() == "default") ){
			style = this.styles[0];
		}
		
		var recursive = style.recursive; //TODO implement recursive as parameter of setOverrideMaterial
		
		var material = style.material;
		
		var selectionType = (style.rootObjects)? "byObjects" : (style.rootObjectKeyAttribute)? "byAttributes" : "selectAll";
		
		if(selectionType == "selectAll"){
			
			this.setOverrideMaterial(this.root, material);
			
		}
		
		if(selectionType == "byObjects"){
			
			var objects = style.rootObjects;
			
			//first reset all objects to default material
			
			//second style selected objects with other material
			for(var i=0,j=objects.length; i<j; i++){
				
				this.setOverrideMaterial(objects[i], material);
			  
			};
			
		}
		
		if(selectionType == "byAttributes"){
			//@TODO
			console.log("Layer.setActiveStyle(): style objects by attributes not yet implemented");
		
		}
		
		/**
		 *@event setActiveStyle 
		 */
		this.dispatchEvent( { type : 'setActiveStyle', content : { layer:this, style: style } } );
	
	},
	
	addEventListener: THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener: THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener: THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent: THREE.EventDispatcher.prototype.dispatchEvent
	
};/**
 * A Helper Layer has a property isTangible = false.
 * This helps to determine objects which shouldn't be reflected in ray intersections, e.g. during visibility analysis.
 * 
 * @namespace GIScene
 * @class Layer.Helper
 * @constructor
 * @extends GIScene.Layer
 * @param {String} name the layer name for display purposes
 * @param {Object} [config] the layer configuration object
 * 
 */
GIScene.Layer.Helper = function(name, config) {
	
	GIScene.Layer.apply(this, [name,config]);
	
	this.isTangible = false;
	
};

GIScene.Layer.Helper.prototype = Object.create(GIScene.Layer.prototype);
/** GIScene.Layer.Fixed() is a simple layer type that loads a Model or a Scene from a url. 
 *  It doesn't care about BoundingBoxes, Frustums, LODs or geographic grids.
 * 
 * @namespace GIScene
 * @class Layer.Fixed
 * @constructor
 * @extends GIScene.Layer
 * @param {String} name the layer name for display purposes
 * @param {Object} [config] the layer configuration object
 * @example
 * 
 * 	var onload = function(event){// do something when model is loaded};
 * 	var layerconfig = {
 * 		url: "./path/myModel.json",
 * 		format: GIScene.Format.JSON,
 * 		verticalAxis : "Z",
 * 		listeners:[{'load':onload}]
 * 	};
 * 	var layer = new GIScene.Layer.Fixed("My Layer", layerconfig);
 * 	scene.addLayer(layer);
 * 
 */ 

GIScene.Layer.Fixed = function(name, config){
	
	//make this a Layer
	GIScene.Layer.apply(this, [name]);
	
	this.config = GIScene.Utils.mergeObjects(this.config, config);
	
	this.url = null;
	this.format = null;
	this.boundingBox = null;
	this.verticalAxis = null;
	this.listeners = null;
	
	var onload = function(event){
		// console.log("Fixed:onload");
		var result = event.content;
		if(this.verticalAxis.toUpperCase() == "Z"){
			result.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI/2 ) );
		}
		//setOverrideMaterial
		this.setOverrideMaterial(result, this.config.overrideMaterial);

		this.root.add(result);
		
		this.boundingBox = new THREE.Box3().setFromObject(this.root);
		
		//update selectables
		if(this.selectControl){
			this.selectControl.selectables = this.root.getDescendants();
		}
		
		/**
		 * Fires after layer is loaded. 
		 * event.content holds a reference to the layer
		 * @event load 
		 */
		this.dispatchEvent({type:'load', content: this});
	}.bind(this);
	
	this.init = function(){
		this.name = name;
	  if(this.config.url && "format" in this.config){
	  	this.url = this.config.url;
	  	this.format = this.config.format;
	  	this.verticalAxis = this.config.verticalAxis || "Y";
	  	this.boundingBox = new THREE.Box3();
	  	this.listeners = this.config.listeners;
	  	for(var i=0,j=this.listeners.length; i<j; i++){
			for(type in this.listeners[i])
			this.addEventListener(type, this.listeners[i][type]);
		  };
	  	
	  	this.loader.addEventListener('load', onload);
	  	this.loader.load(this.url, this.format);
	  }
	  else {console.error('url or format missing in layer config!');}
	};
	
	//start auto initialization 
	this.init();
};

//Inherit from GIScene.Layer
GIScene.Layer.Fixed.prototype = Object.create( GIScene.Layer.prototype );/**
 * A Grid is defined by an origin and a tile size and provides functions to get indices, boundingBoxes etc.
 * 
 * @namespace GIScene
 * @class Grid
 * @constructor
 * @param {Object} config
 *  
 */

GIScene.Grid = function (config) {
	
	//Layer properties
	var defaults = {
		origin: new GIScene.Coordinate2(0,0) , //new THREE.Vector2(0,0),
		// tileSize:16,
		tileSizes : [16],
		sceneOffset: new GIScene.Coordinate3()
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	this.origin = this.config.origin; //.setY(-this.config.origin.y); //substract offset?
	// this.tileSize = this.config.tileSize;
	this.tileSizes = this.config.tileSizes;
	this.sceneOffset = this.config.sceneOffset;
	
	this._sceneOffset = this.sceneOffset.toVector3(); 
	this._origin = this.origin.toVector2().clone().sub(GIScene.Utils.vector3ToVector2(this._sceneOffset));
		
	
};

/**
 * An object representing a tile in the grid.
 * The x property indexes the tiles from west to east.
 * The y property indexes the tiles from south to north.
 * 
 * @namespace GIScene
 * @class Grid.Index
 * @constructor
 * @param {Integer} x
 * @param {Integer} y
 * @param {Number} tileSize
 */

GIScene.Grid.Index = function(x,y,tileSize) {
	this.x = x;
	this.y = y;
	this.tileSize = tileSize;
};

GIScene.Grid.Index.prototype = {
	//constructor : GIScene.Grid.Index,
	equals		: function(gridIndex) {
						return this.x == gridIndex.x && this.y == gridIndex.y && this.tileSize == gridIndex.tileSize;
				},
	toString	: function() {return this.x+"_"+this.y+"_"+this.tileSize;},
	fromString	: function(gridIndexString) {
						var tokens = gridIndexString.split("_");
						this.x = tokens[0];
						this.y = tokens[1];
						this.tileSize = tokens[2];
						return this;
				},
	getChildNW	: function() {
						var x = this.x * 2;
						var y = this.y * 2 + 1;
						return new GIScene.Grid.Index(x,y,this.tileSize * 0.5 );
				},
	getChildSW	: function() {
						var x = this.x * 2;
						var y = this.y * 2;
						return new GIScene.Grid.Index(x,y,this.tileSize * 0.5 );
				},
	getChildNE	: function() {
						var x = this.x * 2 + 1;
						var y = this.y * 2 + 1;
						return new GIScene.Grid.Index(x,y,this.tileSize * 0.5 );
				},
	getChildSE	: function() {
						var x = this.x * 2 + 1;
						var y = this.y * 2;
						return new GIScene.Grid.Index(x,y,this.tileSize * 0.5 );
				}
};

GIScene.Grid.GridLine = function (start, end) { //GIScene.Grid.Index
			  //check for same tileSize
			  if(start.tileSize != end.tileSize){
			  	alert("GIScene.Grid.GridLine(): start and end tiles have different tileSizes. They must have equal ones!");
			  }
			  this.start = start;
			  this.end   = end;
			};
			
GIScene.Grid.IndexStore = function() {
	this.store = []; //stores stringified GIScene.Grid.Index values
	
	// Index or Array of Index
	this.add = function(indexArray){
		indexArray = ( indexArray instanceof Array )? indexArray : [indexArray];
	    //indexArray.forEach(function (e,i,a){this.store[e.toString()]={index:e};}.bind(this));
	    indexArray.forEach(function(e,i,a){a[i]=a[i].toString();});
	    this.store = this.store.concat(indexArray);
	};

	// Index or Array of Index
	this.remove = function(indexArray){
		indexArray = ( indexArray instanceof Array )? indexArray : [indexArray];
		//indexArray.forEach(function(e,i,a){ delete this.store[e.toString()]; }.bind(this));
		indexArray.forEach(function(e,i,a){a[i] = a[i].toString();});
		var lengthBefore = this.store.length;
		this.store = this.store.filter(function(e,i,a){return( indexArray.indexOf(e) == -1 );});
		if(lengthBefore == this.store.length){return false;}else {return true;}
	};
	
};

GIScene.Grid.TileStore = function(config) {
	var defaults = {
					maxLength:1 //null
					// deleteMaterials: false,
					// deleteTextures: false
					};
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});
	
	this.maxLength = this.config.maxLength;
	// this.deleteMaterials = this.config.deleteMaterials;
	// this.deleteTextures  = this.config.deleteTextures;
	
	this.store = {}; //stores stringified GIScene.Grid.Index values with a reference to a THREE.Object3D
	this.indexStore = new GIScene.Grid.IndexStore();
	this.length = 0;
	var ageCounter = 0;
	// Index or Array of Index
	this.add = function(gridIndex, tileObject){
			
		if(this.maxLength && this.length > this.maxLength){this.removeOldestEntry();}
		
		// console.log("GIScene.Grid.TileStore.length: "+this.length);
		// tileArray = ( tileArray instanceof Array )? tileArray : [tileArray];
	    // tileArray.forEach(function (e,i,a){this.store[e.toString()]={index:e};}.bind(this));
	    // tileArray.forEach(function(e,i,a){a[i]=a[i].toString();});
	    // this.store = this.store.concat(tileArray);
	    if(gridIndex instanceof GIScene.Grid.Index){
	    	this.store[gridIndex.toString()] = {object : tileObject, age:ageCounter++}; 
	    	this.indexStore.add(gridIndex);
	    	this.length++;
	    }else{
	    	console.log("GIScene.Grid.TileStore: First argument is not of type GIScene.Grid.Index");
		// this.length++;
		}
	};

	// Index or Array of Index
	this.remove = function(gridIndex){
		if(this.store[gridIndex.toString()]){
			
			delete this.store[gridIndex.toString()].object;
			delete this.store[gridIndex.toString()].age;
			delete this.store[gridIndex.toString()];
			
			this.indexStore.remove(gridIndex);
			
			this.length--;
			return true;
		}
		else return false;
		
	};
	
	this.getTile = function  (gridIndex) {
		var gridIndexString = gridIndex.toString();
		return (gridIndexString in this.store)? this.store[gridIndexString].object : false;
	};
	
	this.removeOldestEntry = function() {
		var oldest={age:Number.MAX_VALUE};
		var oldestKey;
		for(tile in this.store){
			if(this.store[tile].age < oldest.age){oldest = this.store[tile]; oldestKey = tile;};
		}
		console.log("oldestKey: "+oldestKey);
		
			
			
			//dispose object and it geometry but leave material and textures in case that they are used by multiple objects
			var object = this.store[oldestKey].object;
			// if(object.geometry){
				// object.geometry.dispose();
				// delete object.geometry;
			// }
			// var object = null;
			(object.material && object.material.isShared === false )? //isShared is defined e.g. in OverrideMaterialHandler/WMS.js
				GIScene.Utils.disposeObject(object,true, true, true, true) :  
				GIScene.Utils.disposeObject(object,true, false, false, true)
				;
			
			delete this.store[oldestKey].object;
			delete this.store[oldestKey].age;
			delete this.store[oldestKey];
			this.length--;
	};
};


GIScene.Grid.prototype = {
	
	constructor : GIScene.Grid,
	
	// getIndexFromPoint2d : function ( vector2 ) {
	getIndexFromPoint2d : function ( vector2, tileSize ) {
		
		return new GIScene.Grid.Index( 
			  // Math.floor( vector2.x / this.tileSize ) - Math.floor( this._origin.x / this.tileSize ),
			  Math.floor( vector2.x / tileSize ) - Math.floor( this._origin.x / tileSize ), 
			  //y needs to be negative because z goes negative to north. (0,0) is now in the lower left corner of the grid
			  // -(Math.ceil( vector2.y / this.tileSize ) - Math.floor( this._origin.y / this.tileSize )),
			  -(Math.ceil( vector2.y / tileSize ) - Math.floor( this._origin.y / tileSize )),
			  // (Math.ceil( -vector2.y / this.tileSize ) - Math.floor( -this.origin.y / this.tileSize )),
			  // this.tileSize  
			  tileSize
			  );	
	},
	
	//returns decimal gridcoords with tile center as full numbers
	getGridCoordFromPoint2d :function (vector2, tileSize) { //vector2 in graphics order (x: W->E, y:N->S[neg. value grows to the north]) and sceneoffset subtracted
	  
		return new THREE.Vector2(
			( vector2.x / tileSize ) - ( this._origin.x / tileSize ) - ( 0.5 ),
			-( ( vector2.y / tileSize ) - ( this._origin.y / tileSize )  ) - ( 0.5 )
		);
	  
	},
	
	getCentroidFromIndex: function(index) {
		var x = index.x*index.tileSize + this._origin.x/*index.tileSize*/ + index.tileSize/2;
		var y = -index.y*index.tileSize + this._origin.y/*index.tileSize*/ - index.tileSize/2; 
		// var y = -index.y*index.tileSize + this.origin.y/*index.tileSize*/ - index.tileSize/2; 
		return new THREE.Vector2(x,y);
	},
	
	getBoundingBoxFromIndex: function(index) {
		var centroid2 = this.getCentroidFromIndex(index);//v2
		var halfSize = index.tileSize/2;
		var bbox = {
			left:	centroid2.x - halfSize,
			right:  centroid2.x + halfSize,
			top:	centroid2.y - halfSize,
			bottom:	centroid2.y + halfSize
		};
		return bbox;
	},
	
	getCornerCoordsFromIndex: function(index) {
		var bbox = this.getBoundingBoxFromIndex(index);
		var cornerCoords = [
					{x: bbox.left, y: bbox.bottom}, //sw
					{x: bbox.right, y: bbox.bottom},//se
					{x: bbox.right, y: bbox.top}, //ne
					{x: bbox.left, y: bbox.top} //nw
					]; 
		return cornerCoords;
	},
	
	isDescendantOf: function(descendant, ancestor) { //both GIScene.Grid.Index
		if(!descendant || !ancestor)return false;
		var tileSizeLevelDistance = this.tileSizes.indexOf(descendant.tileSize) - this.tileSizes.indexOf(ancestor.tileSize);
		var levelFactor = tileSizeLevelDistance *2;
		var xAncestorLevel = Math.floor(descendant.x / levelFactor);
		var yAncestorLevel = Math.floor(descendant.y / levelFactor);
		return (xAncestorLevel == ancestor.x && yAncestorLevel == ancestor.y);	//isDescendant ? 
	},
	
	traverseIf_old: function(node, traverseCriteria, callback) {
		if(traverseCriteria(node)){
			if(node.tileSize <= this.tileSizes[0]){ //is leaf
				
				callback(node);
			}
			else {
				this.traverseIf(node.getChildNW(),traverseCriteria, callback);
				this.traverseIf(node.getChildNE(),traverseCriteria, callback);
				this.traverseIf(node.getChildSW(),traverseCriteria, callback);
				this.traverseIf(node.getChildSE(),traverseCriteria, callback);
			}
		}
	},
	
	traverseIf: function(node, traverseCriteria, isLeafNode, callback) {
		if (traverseCriteria(node)){ //is overlapping clipped view port polygon
			if (isLeafNode(node)){
				callback(node);
			} else {
				this.traverseIf(node.getChildNW(),traverseCriteria, isLeafNode, callback);
				this.traverseIf(node.getChildNE(),traverseCriteria, isLeafNode, callback);
				this.traverseIf(node.getChildSW(),traverseCriteria, isLeafNode, callback);
				this.traverseIf(node.getChildSE(),traverseCriteria, isLeafNode, callback);
			}
		}
		
	},
	
	//Bresenham Line
	getTilesFromGridLine : function (gridLine) {
		var tileSize = gridLine.start.tileSize;
	    var tiles = [];
	    // Translate coordinates
	    var x1 = gridLine.start.x; //startCoordinates.left;
	    var y1 = gridLine.start.y; //startCoordinates.top;
	    var x2 = gridLine.end.x;   //endCoordinates.left;
	    var y2 = gridLine.end.y;   //endCoordinates.top;
	    // Define differences and error check
	    var dx = Math.abs(x2 - x1);
	    var dy = Math.abs(y2 - y1);
	    var sx = (x1 < x2) ? 1 : -1;
	    var sy = (y1 < y2) ? 1 : -1;
	    
	    //8-connectedLine Bresenham
	    if(false){
	    var err = dx - dy;
	    // Set first coordinates
	    tiles.push(new GIScene.Grid.Index(x1, y1, tileSize));
	    // Main loop
	    while (!((x1 == x2) && (y1 == y2))) {
	      var e2 = err << 1;
	      if (e2 > -dy) {
	        err -= dy;
	        x1 += sx;
	      }
	      if (e2 < dx) { 
	        err += dx;
	        y1 += sy;
	      }
	      // Set coordinates
	      tiles.push(new GIScene.Grid.Index(x1, y1, tileSize));
	      }
	    }
	    
	      //4-connected line (see http://stackoverflow.com/questions/5186939/algorithm-for-drawing-a-4-connected-line) 
	      var e = 0;
		  for (var i=0; i < dx+dy; i++) {
		      tiles.push(new GIScene.Grid.Index(x1, y1, tileSize));
		      var e1 = e + dy;
		      var e2 = e - dx;
		      if (Math.abs(e1) < Math.abs(e2)) {
		          x1 += sx;
		          e = e1;
		      } else {
		          y1 += sy;
		          e = e2;
		      }
		  }
		  // draw reverse
		  var e = 0;
		  for (var i=0; i < dx+dy; i++) {
		      tiles.push(new GIScene.Grid.Index(x1, y1, tileSize));
		      var e1 = e + dy;
		      var e2 = e - dx;
		      if (Math.abs(e1) < Math.abs(e2)) {
		          x1 += -sx;
		          e = e1;
		      } else {
		          y1 += -sy;
		          e = e2;
		      }
		  }
		  //if start and endpoint are equal return one tile
		  if(dx+dy == 0){
		  	tiles.push(new GIScene.Grid.Index(x1, y1, tileSize));
		  }
	      
	      
	   
	    // Return the result
	    return tiles;
	 },
	 
	 
	 /**
	  * Returns an array of Grid.Index objects which are intersected by a line
	  * 
	  * @method getTilesFromLineIntersection
	  * @param {GIScene.Coordinate2} startCoord2 
	  * @param {GIScene.Coordinate2} endCoord2
	  * @param {Number} tileSize
	  * @return {Array of GIScene.Grid.Index} tiles
	  */
	 getTilesFromLineIntersection : function(startCoord2, endCoord2, tileSize) { //GIScene.Coordinate2
	 //	ctx.rasterLine4 = function(x1o,y1o,x2o,y2o, color, scale) {
		
		var tiles = [];
		var startV2_ = startCoord2.toVector2().clone().sub(GIScene.Utils.vector3ToVector2(this._sceneOffset));
		var endV2_ 	 =   endCoord2.toVector2().clone().sub(GIScene.Utils.vector3ToVector2(this._sceneOffset));
		
		//convert world into grid coord system
		var startGridCoord = this.getGridCoordFromPoint2d( startV2_, tileSize );
		var endGridCoord   = this.getGridCoordFromPoint2d(   endV2_, tileSize );
		
		var x1o = startGridCoord.x;
		var y1o = startGridCoord.y;
		var x2o = endGridCoord.x;
		var y2o = endGridCoord.y;
		
		//original slope (m)
	    var dxo = (x2o - x1o);  
	    var dyo = (y2o - y1o);  
		var   m = dyo/dxo;
		//@TODO horizontal and vertical lines (m==0 bzw. m == Infinity)
		var horizontal = ( dyo == 0 );
		var vertical   = ( dxo == 0 );
		
		//step direction
	    var sx = (x1o < x2o) ? 1 : -1; //step x (positive: line goes from left to right)
	    var sy = (y1o < y2o) ? 1 : -1; //step y (positive: line goes from top to bottom)
	    
	    //const
	    var m_sx = m*sx;
	    var m_sy = (1/m)*sy;
	    
	    //number of steps to draw 
	    var lx1 = Math.abs(Math.round(x2o)-Math.round(x1o)); //in x direction
	    var ly1 = Math.abs(Math.round(y2o)-Math.round(y1o)); //in y direction
	    
	    //start values
	    var x1o_round = Math.round(x1o);
	    var y1o_round = Math.round(y1o);
	    var _delta_x = x1o - x1o_round;
	    var _delta_y = y1o - y1o_round;
	    var x_step = x1o - _delta_y * (1/m);   
	    var y_step  = y1o - _delta_x * m;
	    
	    //end values
	    var x2o_round = Math.round(x2o);
	    var y2o_round = Math.round(y2o);
	    
	    //tile coordinates
	    var _x,_y;
		
		//if slope <= 1 do x steps
	    if( Math.abs(m) <= 1 && !horizontal){
	    	
	    	//1st to penultimate point
	    	for ( var i = 0; i < lx1; i++ ){
	    		 _x = x1o_round + i*sx;
		    	 _y = (y_step + i*m_sx);    	
		    	
		    	var x_round = Math.round(_x);
		    	var y_round = (i!=0)? Math.round(_y) : y1o_round; //draw first point where it is, all others with y according to middle of tile
		    	
		    	// ctx.drawPoint(x_round,y_round,color,scale);
		    	tiles.push(new GIScene.Grid.Index(x_round,y_round,tileSize));
		    	
		    	//need for filling point?
		    	var change = (Math.round(y_step + (i+1)*m_sx) - y_round);// != 0);
		    	if(i == lx1-1){
		    		//last change
		    		change = y2o_round - y_round; // != 0;
		    	}
		    	if(change != 0){
		    		//fill left or right
		    		
		    		var y_cutNext = (y_step + (m_sx*(i+0.5)));
		    		var left_side = Math.round(y_cutNext) == y_round;
		    		//if passing exactly in the middle draw both for touching is true
		    		//be tolerant to floating point errors
		    		var both = ((Math.floor((Math.abs(y_cutNext)%1) * 10000))/10000 == 0.5); 
		    		
	    			if(left_side || both){
		    			
		    			// ctx.drawPoint(x_round+sx,y_round,"green",scale);	
		    			tiles.push(new GIScene.Grid.Index(x_round+sx,y_round,tileSize));	
		    		}
		    		
		    		if(!left_side || both){
		    			
		    			// ctx.drawPoint(x_round,y_round+sy,"blue",scale);
		    			tiles.push(new GIScene.Grid.Index(x_round,y_round+sy,tileSize));
		    		}
		    		
		    		if( Math.abs(change) > 1){
		    			
		    			// ctx.drawPoint(x_round+sx,y_round+sy,"aqua",scale);
		    			tiles.push(new GIScene.Grid.Index(x_round+sx,y_round+sy,tileSize));
		    		
		    		}
		    		
		    	}
		    } //end for
		    
		    // lastpoint 
		    // ctx.drawPoint(Math.round(x2o),Math.round(y2o),"yellow",scale);
		    tiles.push(new GIScene.Grid.Index(Math.round(x2o),Math.round(y2o),tileSize));
	   } 
	
		//if slope > 1 do y steps
	    if( Math.abs(m) > 1 && !vertical){
	    		    	
	    //1st to penultimate point
	    	for ( var i = 0; i < ly1; i++ ){
	    		 _y = y1o_round + i*sy;
		    	 _x = (x_step + i*m_sy);    	
		    	
		    	var y_round = Math.round(_y);
		    	var x_round = (i!=0)? Math.round(_x) : x1o_round; //draw first point where it is, all others with y according to middle of tile
		    	
		    	// ctx.drawPoint(x_round,y_round,color,scale);
		    	tiles.push(new GIScene.Grid.Index(x_round,y_round,tileSize));
		    	
		    	//need for filling point
		    	var change = (Math.round(x_step + (i+1)*m_sy) - x_round );//!= 0); 0:no change; 1 or 2?
		    	if(i == ly1-1){
		    		//last change
		    		change = x2o_round - x_round;// != 0;
		    	}
		    	if(change !=0 ){
		    		//fill left or right
		    		
		    		var x_cutNext = (x_step + (m_sy*(i+0.5)));
		    		var left_side = Math.round(x_cutNext) == x_round;
		    		//if passing exactly in the middle draw both for touching is true
		    		//be tolerant to floating point errors
		    		var both = ((Math.floor((Math.abs(x_cutNext)%1) * 10000))/10000 == 0.5);
		    		 
	    			if(!left_side || both){
		    			
		    			// ctx.drawPoint(x_round+sx,y_round,"green",scale);
		    			tiles.push(new GIScene.Grid.Index(x_round+sx,y_round,tileSize));	
		    			
		    		}
		    		
		    		if(left_side || both){
		    			
		    			// ctx.drawPoint(x_round,y_round+sy,"blue",scale);
		    			tiles.push(new GIScene.Grid.Index(x_round,y_round+sy,tileSize));
		    		}
		    		
		    		if( Math.abs(change) > 1){
		    			
		    			// ctx.drawPoint(x_round+sx,y_round+sy,"aqua",scale);
		    			tiles.push(new GIScene.Grid.Index(x_round+sx,y_round+sy,tileSize));
		    		
		    		}
		    	}
		    } //end for
		    
		    //lastpoint
		     // ctx.drawPoint(x2o_round,y2o_round,"yellow",scale);
		     tiles.push(new GIScene.Grid.Index(x2o_round,y2o_round,tileSize));
	    }
	    
	    
	    
	    //if slope Infinity draw vetical line
	    if( vertical ){
	    	for(var i=0;i<=ly1;i++){
	    		// ctx.drawPoint(x1o_round,y1o_round + i,color,scale);
	    		tiles.push(new GIScene.Grid.Index(x1o_round,y1o_round + i,tileSize));
	    		//be tolerant to floating point errors
	    		if( Math.floor( ( Math.abs(x1o)%1 )*10000 )/10000 == 0.5 ){ 
	    			// ctx.drawPoint(x1o_round-1,y1o_round + i,"green",scale);
	    			tiles.push(new GIScene.Grid.Index(x1o_round-1,y1o_round + i,tileSize));
	    		}
	    	}
	    }
	    
	    if( horizontal ){
	    	for(var i=0;i<=lx1;i++){
	    		// ctx.drawPoint(x1o_round+i,y1o_round,color,scale);
	    		tiles.push(new GIScene.Grid.Index(x1o_round+i,y1o_round,tileSize));
	    		//be tolerant to floating point errors
	    		if( Math.floor( ( Math.abs(y1o)%1 )*10000 )/10000 == 0.5 ){ 
	    			// ctx.drawPoint(x1o_round +i,y1o_round - 1,"green",scale);
	    			tiles.push(new GIScene.Grid.Index(x1o_round +i,y1o_round - 1,tileSize));
	    		}
	    	}
	    }
	    
	    return tiles;
//};	
	 },
	
	addEventListener: THREE.EventDispatcher.prototype.addEventListener,
	hasEventListener: THREE.EventDispatcher.prototype.hasEventListener,
	removeEventListener: THREE.EventDispatcher.prototype.removeEventListener,
	dispatchEvent: THREE.EventDispatcher.prototype.dispatchEvent
	
};/** GIScene.Layer.Grid() is a layer type that loads Tiles from a url based on a Grid. 
 * 
 * @namespace GIScene
 * @class Layer.Grid
 * @constructor
 * @extends GIScene.Layer
 * @param {String} name the layer name for display purposes
 * @param {Object} [config] the layer configuration object
 */ 

GIScene.Layer.Grid = function(name, config){
	
	//make this a Layer
	GIScene.Layer.apply(this,[name, config]);
	
	var defaults = {
		//grid : new GIScene.Grid({origin: new GIScene.Coordinate2(0,0),tileSize: 1024}), //origin, tilesize
		origin: new GIScene.Coordinate2(0,0),
		tileSizes: [1024], 
		
		terrainHeight:71,
		maxNumTiles:25,
		maxDistance:10000,
		computeTileIndicesHandler:'default', //function to determine the tiles to be loaded, can differ from default for analysis reasons
		service:null,
		maxExtent:null, //
		lodDistanceFactor: 1,
		overrideMaterialHandler : null, //will be called for each object after assigning the overrideMaterial with an event.content object as parameter: {object:{Object3D}, material:{THREE.Material}, layer: GIScene.Layer}
		//@TODO sharedOverrideMaterial if only attached to single objects like in wmsoverlay textures and materials could be disposed when deleting tiles, if one mateial is schared by all tiles then material must be kept when deleting tiles
		// hasSharedOverrideMaterial : true, //set to false to make the tilecache delete materials and textures from tiles when deleted
		virtualSelectionAccessor : null 
	};
	
	this.config = GIScene.Utils.mergeObjects(defaults, this.config);
	
	this.url = null;
	this.format = null;
	this.boundingBox = null; //?? will change frequently
	this.verticalAxis = null;
	
	this.origin			= this.config.origin;
	this.tileSizes		= this.config.tileSizes.sort(function(a,b){return b-a;}); //sort descending
	this.grid 			= null;// will be set onSetScene //her could be gridset instead of grid  // this.config.grid;
	this.terrainHeight 	= this.config.terrainHeight;
	var _terrainHeight	= null; //will initialized in init() and adapted to the scene offset onSetScene
	this.maxNumTiles 	= this.config.maxNumTiles; 
	this.maxDistance	= this.config.maxDistance;
	this.maxExtent		= this.config.maxExtent;
	var _maxExtent		= null; //will initialized in init() and adapted to the scene offset onSetScene
	this.lodDistanceFactor = this.config.lodDistanceFactor;
	this.distanceReferencePoint = null; // will be calulated in getNewTiles
	this.computeTileIndicesHandler = null; // set in init()
	this.overrideMaterialHandler = null;
	this.virtualSelection = [];
	this.virtualSelectionAccessor = this.config.virtualSelectionAccessor;
	// this.hasSharedOverrideMaterial = this.config.hasSharedOverrideMaterial;
	
	var doAutoUpdate	= false;
	var autoUpdateIntervalId;
	
	//tileHandling
	this.load = []; //tiles to load
	this.remove = []; //tiles to remove
	
	this.loading = new GIScene.Grid.TileStore(); //holds the xhr request while loading //new GIScene.Grid.IndexStore();
	this.loaded  = new GIScene.Grid.TileStore(); //tiles already loaded
	this.cache	 = new GIScene.Grid.TileStore({
												maxLength:200
												// deleteMaterials: !this.hasSharedOverrideMaterial ,
												// deleteTextures:	 !this.hasSharedOverrideMaterial 
												});
	 	
	this.init = function(){
		this.name = name;
	  	this.url = this.config.url;
	  	this.format = this.config.format;
	  	this.verticalAxis = this.config.verticalAxis || "Y"; 
	  	this.boundingBox = new THREE.Box3();
	  	
	  	this.setTerrainHeight(this.terrainHeight);
	  	this.setMaxExtent(this.maxExtent);
	  	
	  	this.setComputeTileIndicesHandler(this.config.computeTileIndicesHandler);
	  	
	};
	
	var autoUpdate = function() { 
		if(doAutoUpdate){
			doAutoUpdate=false;
			this.update();
			doAutoUpdate=true;
		}
	}.bind(this);
	
	/**
	 * Starts the automatic loading and removing of tiles dependant on the camera perspective
	 * 
	 * @method startUpdate 
	 */
	this.startUpdate = function() { doAutoUpdate = true; autoUpdateIntervalId = window.setInterval(autoUpdate,500);console.log("Layer.Grid():startUpdate()");};
	
	/**
	 * Stops the automatic loading and removing of tiles dependent on the camera perspective
	 * 
	 * @method stopUpdate 
	 */
	this.stopUpdate = function() { window.clearInterval(autoUpdateIntervalId); doAutoUpdate = false;};
	
	this.setComputeTileIndicesHandler = function(handler) {
		this.computeTileIndicesHandler = ( handler == 'default')? this.getNewTilesFromQuadtree : handler;
	};
	
	var errorMaterial = new THREE.MeshBasicMaterial({color:0x55FF55, opacity:0.5, wireframe:false});
	this.getErrorTile = function(gridIndex) {
		
		// var material = new THREE.MeshBasicMaterial({color:0x55FF55, opacity:0.5, wireframe:false});
		var errorTile = new THREE.Mesh(new THREE.CubeGeometry(gridIndex.tileSize, 4, gridIndex.tileSize), errorMaterial);	
		errorTile.name = "errorTile_"+gridIndex.toString();
		//var centroid = GIScene.Grid.prototype.getCentroidFromIndex(gridIndex);//this.grid.getCentroidFromIndex(gridIndex);
		var centroid = this.grid.getCentroidFromIndex(gridIndex);//this.grid.getCentroidFromIndex(gridIndex);
		errorTile.position.set(centroid.x, (this.terrainHeight - this.offset.z), centroid.y);
		return errorTile;
	};
	
	/**
	 * Loads a tile by specifiying a GIScene.Grid.Index
	 * 
	 * @method loadTile
	 * @param {GIScene.Grid.Index} gridIndex
	 */	
	this.loadTile = function(gridIndex, generalize, specialize) {  //GIScene.Grid.Index
		if(!gridIndex)return;
		// console.log("loadTile",gridIndex);
		//get from cache
		var tileFromCache = this.cache.getTile(gridIndex); //object3d or false
		
		if(tileFromCache){
			
			//check material 
			
			var material = null;
			tileFromCache.traverse(function(object){
				if(!material){
					if(object.material){material = object.material;}
				}
			});
			
			var hasUnsharedWmsTextureLoaded = false;
			if(material && material.waitForTexture){
				hasUnsharedWmsTextureLoaded = material.unsharedWmsTextureLoaded;
			}
			// console.log("hasUnsharedWmsTextureLoaded", hasUnsharedWmsTextureLoaded)
			//if part of specialize keep in cache until all are loaded
			
			
			
			
			// var descendants = specialize[gridIndex.toString()];
			// var isPartOfSpecialize = false;
			// if(descendants){
				// isPartOfSpecialize = descendants.some(function(e,i,a){return gridIndex.equals(e);});
				// alert("Hallo");
				// console.log("isPartOfSpecialize", isPartOfSpecialize);
				// var allLoaded = descendants.every(function(e,i,a){
									// return this.cache.getTile(e) !== false;		//später in cache schauen statt loaded
								// });
				// if(allLoaded){
						// this.removeTile(gridIndex);
						// isPartOfSpecialize = false;
					// }
			// }
			//else add immediately
			// if(! isPartOfSpecialize){
			if(hasUnsharedWmsTextureLoaded || !material || !material.waitForTexture){
			// this.loading.remove(gridIndex);//mca2
			this.root.add(tileFromCache);
			
			this.cache.remove(gridIndex);
			this.loaded.add(gridIndex, tileFromCache);
			
			//update selectables
			if(this.selectControl){
				this.selectControl.selectables = this.root.getDescendants();
			}
			
			//ontileadd event
			/**
			 *Fires after a tile is added to the scene. A reference to the tile can be found at event.content.tile 
			 *
			 *@event tileadd
			 *  
			 */
			this.dispatchEvent({type:'tileadd', content:{tile:tileFromCache}});
			
			//add to oldTiles because all have been removed before (loaded and loading). Keep oldTiles updated.
			this.oldTiles.push(gridIndex);
			}
			//remove Tiles from generalize
			//test this.removeTiles(generalize[gridIndex.toString()]);
			
			
			
			//remove Tile from spezialize if all are loaded
			// var descendants = specialize[gridIndex.toString()];
			// if(descendants){
				// var allLoaded = descendants.every(function(e,i,a){
									// return this.loaded.getTile(e) !== false;		//später in cache schauen statt loaded
								// });
				// if(allLoaded){this.removeTile(gridIndex);}
			// }
			
		}else{
			//load tile and push to cache
		
			var onSuccess = function(result) {
				
				//handle errors, when server gives a 200 result but not a model,e.g. hmtl error website
				var errorTile = false;
				if(!(result instanceof THREE.Object3D)){
					result = this.getErrorTile(gridIndex);
				    errorTile = true;
				}
				
				//rotate model if z is up
				if(this.verticalAxis.toUpperCase() == "Z" && !errorTile){
					result.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI/2 ) );
				}
				
				
				this.loading.remove(gridIndex); //mca2
			
			//mca	this.loaded.add(gridIndex,result);
				this.cache.add(gridIndex,result);
				
				//setOverrideMaterial
				if(!errorTile)this.setOverrideMaterial(result, this.config.overrideMaterial);
				
				
				//onload event
				/**
				 *Fires after a tile is loaded. A reference to the tile can be found at event.content.tile 
				 *
				 *@event tileload
				 *  
				 */
				this.dispatchEvent({type:'tileload', content:{tile:result}});
				
				//add to layer when texture is loaded
				// var material = null;
				// result.traverse(function(object){
					// if(!material){
						// if(object.material){material = object.material;}
					// }
				// });
// 				
				// if(material){
					// var onSetTexture = function(event){
						// this.loadTile(gridIndex);
						// material.removeEventListener("settexture", onSetTexture);
					// }.bind(this);
// 					
					// material.addEventListener("settexture", onSetTexture);
				// }
				
				//add to layer
				// mca this.root.add(result);
				//remove Tiles from generalize
				// console.log("removeTiles", gridIndex.toString(), generalize);
				// this.removeTiles(generalize[gridIndex.toString()]);
				
			}.bind(this);
			
			var onError = function(e) {
				
				var result = this.getErrorTile(gridIndex);
				
				this.loading.remove(gridIndex); 
			
				this.cache.add(gridIndex,result);
			}.bind(this);
			
			if(this.loading.getTile(gridIndex) === false){
			
				var requestUrl = this.config.service.getGetSceneUrl(gridIndex, this.grid);
				
				var loader = new GIScene.ModelLoader(); //need a loader for every parallel request
				loader.load(requestUrl, this.format, onSuccess, null, onError);
				
				this.loading.add(gridIndex, loader);
				//?????mca3
				// this.oldTiles.push(gridIndex);
			}
			
			
		// var object = this.getErrorTile(gridIndex);
		// this.loaded[gridIndex.toString()] = object; //@TODO remove reference before layer is disposed
		// this.root.add(object);
		}
	};
	
	/**
	 * loads several tiles by specifying an array of GIScene.Grid.Index objects
	 * @method loadTiles
	 * @param {Array of GIScene.Grid.Index} tileArray 
	 */
	this.loadTiles = function(tileArray, generalize, specialize) { 
		if(!tileArray)return;
		for(var i=0,j=tileArray.length; i<j; i++){
		  this.loadTile(tileArray[i], generalize, specialize);
		};	
	};
	
	/**
	 * Removes a tile or aborts its loading by specifiying a GIScene.Grid.Index
	 * 
	 * @method removeTile
	 * @param {GIScene.Grid.Index} gridIndex
	 */	
	this.removeTile = function(gridIndex, generalize){
		if(!gridIndex)return;
		// console.log("removeTile", gridIndex);
		
		// abort while still loading but not further needed
		var xhrIsLoading = this.loading.getTile(gridIndex);
		if(xhrIsLoading) {
			/*console.log(xhrIsLoading);*/
			xhrIsLoading.abort(); 
			this.loading.remove(gridIndex); 
			// if(generalize && gridIndex.toString() in generalize){console.log("removeTile:abortGeneralize");this.oldTiles.push.apply(this.oldTiles,generalize[gridIndex.toString()])};
			return;
		}
				
		var object = this.loaded.getTile(gridIndex);
		
		if(object instanceof THREE.Object3D){
			this.root.remove(object);
			this.loaded.remove(gridIndex);
			this.cache.add(gridIndex, object);
			//ontileremove event
			/**
			 *Fires after a tile is removed from the scene. A reference to the tile can be found at event.content.tile 
			 *
			 *@event tileremove
			 *  
			 */
			this.dispatchEvent({type:'tileremove', content:{tile:object}});
		}
		
	};
	
	/**
	 * removes or aborts the loading of several tiles by specifying an array of GIScene.Grid.Index objects
	 * @method removeTiles
	 * @param {Array of GIScene.Grid.Index} tileArray 
	 */
	this.removeTiles = function(tileArray, generalize) {
		if(!tileArray)return;
		for(var i=0,j=tileArray.length; i<j; i++){
		  this.removeTile(tileArray[i], generalize);
		};
	};
	
	/**
	 * computes the visible tiles of the current camera view 
	 * 
	 * @method getNewTilesFromQuadtree
	 * @return {Array of GIScene.Grid.Index} newTiles
	 */
	this.getNewTilesFromQuadtree = function() {
		// console.log("Layer.Grid():getNewTiles()");
		// console.log(this);
		
		/*
		 *returns Array of THREE.Vector2() while first and last index values (points) are identical  
		 */
		var intersectFrustrumAtTerrainHeight = function(terrainHeight){		//getCuttingPolygon
			// console.log("Layer.Grid():getNewTiles():intersectFrustrumAtTerrainHeight()");
			// console.log(this);
				//topology of frustum  hierarchy: points (n|f)_(t|b)_(l|r)
				var points = {
					//near
					"n_t_l" : new THREE.Vector3(-1, 1,-1),
					"n_t_r" : new THREE.Vector3( 1, 1,-1),
					"n_b_r" : new THREE.Vector3( 1,-1,-1),
					"n_b_l" : new THREE.Vector3(-1,-1,-1),
					//far
					"f_t_r" : new THREE.Vector3( 1, 1, 1),
					"f_t_l" : new THREE.Vector3(-1, 1, 1),
					"f_b_l" : new THREE.Vector3(-1,-1, 1),
					"f_b_r" : new THREE.Vector3( 1,-1, 1)
				};
				
				var lines = {
					//near counterclockwise
					"n_t":{	geometry: new THREE.Line3(points.n_t_r, points.n_t_l) },
					"n_r":{ geometry: new THREE.Line3(points.n_b_r, points.n_t_r) },
					"n_b":{ geometry: new THREE.Line3(points.n_b_l, points.n_b_r) },
					"n_l":{ geometry: new THREE.Line3(points.n_t_l, points.n_b_l) },
					
					//far ccw
					"f_t":{ geometry: new THREE.Line3(points.f_t_l, points.f_t_r) },
					"f_r":{ geometry: new THREE.Line3(points.f_t_r, points.f_b_r) },
					"f_b":{ geometry: new THREE.Line3(points.f_b_r, points.f_b_l) },
					"f_l":{ geometry: new THREE.Line3(points.f_b_l, points.f_t_l) },
					
					//sides from near to far
					"t_l":{ geometry: new THREE.Line3(points.n_t_l, points.f_t_l) },
					"b_l":{ geometry: new THREE.Line3(points.n_b_l, points.f_b_l) },
					"b_r":{ geometry: new THREE.Line3(points.n_b_r, points.f_b_r) },
					"t_r":{ geometry: new THREE.Line3(points.n_t_r, points.f_t_r) }
				};
				 
				var cells = {
					"near"	:[lines.n_l, lines.n_t, lines.n_r, lines.n_b],
					"far" 	:[lines.f_r, lines.f_b, lines.f_l, lines.f_t],
					"left"	:[lines.n_l, lines.t_l, lines.f_l, lines.b_l],
					"top"	:[lines.n_t, lines.t_r, lines.f_t, lines.t_l],
					"right"	:[lines.n_r, lines.b_r, lines.f_r, lines.t_r],
					"bottom":[lines.n_b, lines.b_l, lines.f_b, lines.b_r]
				};
				
				lines.n_t.left = cells.near;
				lines.n_t.right= cells.top;
				
				lines.n_r.left = cells.near;
				lines.n_r.right= cells.right;
				
				lines.n_b.left = cells.near;
				lines.n_b.right= cells.bottom;
				
				lines.n_l.left = cells.near;
				lines.n_l.right= cells.left;
				
				lines.f_t.left = cells.far;
				lines.f_t.right= cells.top;
				
				lines.f_r.left = cells.far;
				lines.f_r.right= cells.right;
				
				lines.f_b.left = cells.far;
				lines.f_b.right= cells.bottom;
				
				lines.f_l.left = cells.far;
				lines.f_l.right= cells.left;
				
				lines.t_l.left = cells.left;
				lines.t_l.right= cells.top;
				
				lines.b_l.left = cells.bottom;
				lines.b_l.right= cells.left;
				
				lines.b_r.left = cells.right;
				lines.b_r.right= cells.bottom;
				
				lines.t_r.left = cells.top;
				lines.t_r.right= cells.right;
				
				var projector = new THREE.Projector();
				
				//project points to world Coordinates
				for (point in points){
					projector.unprojectVector(points[point], this.scene.camera);
					//console.log(point+ ": " + points[point].toArray());
				}
				
				// var terrainHeight = 0; //has to be set dynamically
				var plane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0), new THREE.Vector3(0,terrainHeight,0));
				
				var  polygonPoints=[],firstCell, firstLine;
				//iterate through lines
				
				//find first cell with cutted lines	
				var setFirstCellAndPoint = function() {
					for (cell in cells) {
						//console.log('Cell: '+ cell);
						//find first point
						for (var i=0;i<4;i++) { //lines in cell
							var point = plane.intersectLine(cells[cell][i].geometry);
							//console.log("intersect check: " +i + " "+ point);
							if (point) {
								//console.log("1.PolygonPoint: " + point.toArray().toString() +" Cell: "+cell + " Line: "+ i);
								polygonPoints.push(point);
								firstCell = cells[cell];
								firstLine = cells[cell][i];
								return;
							}
						}
					}
				}; 
		
				var getRestOfPoints = function(cell, firstLine) {
					for(var i=0;i<4;i++){ //line in cell
						if(cell[i] !== firstLine){
							var point = plane.intersectLine(cell[i].geometry);
							if (point) {
								//console.log("PolygonPoint: " + point.toArray().toString()+ " Cell: "+ cell + " Line: "+i);
								polygonPoints.push(point);
								if(!(polygonPoints[0].equals(polygonPoints[polygonPoints.length-1]))){
									var nextCell = (cell[i].left === cell)? cell[i].right : cell[i].left;
									// (cell[i].left === cell)?console.log('nextCell: rightCell'):console.log('nextCell: leftCell') ;
									getRestOfPoints(nextCell, cell[i]);
								}
							}
						}
					}
				};
				
				// start algorithm
				
				setFirstCellAndPoint();
				if(firstCell)getRestOfPoints(firstCell, firstLine);
				//console.log('Polygon: '+polygonPoints.length);
				
				//flatten polygon to 2D
				for(var i=0,j=polygonPoints.length; i<j; i++){
				  polygonPoints[i] = GIScene.Utils.vector3ToVector2(polygonPoints[i]);
				};
				
			return polygonPoints; //Array of THREE.Vector2
			}.bind(this);
		
		var addBufferToPolygon = function(polygon, bufferDistance) {
			if ( polygon.length < 4 ){return polygon;}; // at least a triangle
			var isCCW = function(poylgon) { // convex polygon only
				var firstDirVector2  = new GIScene.Line2().fromPoints(polygon[0], polygon[1]).directionVector;
				var secondDirVector2 = new GIScene.Line2().fromPoints(polygon[1], polygon[2]).directionVector;
				var firstDirVector3 = new THREE.Vector3(firstDirVector2.x,firstDirVector2.y, 0);
				var secondDirVector3 = new THREE.Vector3(secondDirVector2.x,secondDirVector2.y, 0);
				var normal = THREE.Vector3.prototype.crossVectors(firstDirVector3, secondDirVector3);
				return (normal.z < 0)? true : false ;
			};
			// console.log("addBufferToPolygon", polygon.length, bufferDistance);
			// console.log(new GIScene.Line2().fromPoints(polygon[polygon.length-2], polygon[polygon.length-1]));
			
			if(!isCCW(polygon)){polygon.reverse();}
			 
			var bufferedPolygon = [];
			
			//first intersection
			bufferedPolygon.push(
						new GIScene.Line2().fromPoints(polygon[polygon.length-2], polygon[polygon.length-1])
						.moveRight(bufferDistance)
						.intersect(
							new GIScene.Line2().fromPoints(polygon[0], polygon[1])
							.moveRight(bufferDistance)
						)
					);
			// console.log(bufferedPolygon[0]);
			//rest of intersections
			for (var i=0; i < polygon.length-2; i++){
					
					bufferedPolygon.push(
						new GIScene.Line2().fromPoints(polygon[i], polygon[i+1])
						.moveRight(bufferDistance)
						.intersect(
							new GIScene.Line2().fromPoints(polygon[i+1], polygon[i+2])
							.moveRight(bufferDistance)
						)
					);
					// console.log(i);
			}
			
			bufferedPolygon.push(new THREE.Vector2(bufferedPolygon[0].x, bufferedPolygon[0].y) );
			// console.log(bufferedPolygon.length);
			// console.log(polygon[0]);
			// console.log(bufferedPolygon[0]);
			return bufferedPolygon;
		};
		
		var clipCuttingPolygonByMaxDistance = function(polygon, radius) {
			// console.log("Layer.Grid():getNewTiles():clipCuttingPolygonByMaxDistance()");
			// console.log(this);
			var isCCW = function(vertices) {
				var polygonArea = function() {
					var area = 0;
					for (var i = 0; i < vertices.length; i++) {
						j = (i + 1) % vertices.length;
						area += vertices[i][0] * vertices[j][1];
						area -= vertices[j][0] * vertices[i][1];
					}
					return area / 2;
				};
				
				var clockwise = polygonArea() > 0;
				return !clockwise;
			}; 

			var createCirclePolygon = function(origin, radius){
				// console.log("Layer.Grid():getNewTiles():clipCuttingPolygonByMaxDistance():createCirclePolygon()");
				// console.log(this);
				var sides = 24;
				var angle = Math.PI * ((1/sides) - (1/2));
				var rotatedAngle, x, y;
				var points = [];
				for(var i=0; i<sides; ++i) {
					rotatedAngle = angle + (i * 2 * Math.PI / sides); //orig angle -
					x = origin.x + (radius * Math.cos(rotatedAngle));
					y = origin.y + (radius * Math.sin(rotatedAngle));
					//points.push(new THREE.Vector2(x, y));
					points.push([x,y]);
				}
				return points;
			};
			
			//Sutherland-Hodgman-Algorithm for Polygon Clipping with a convex clipPolygon
			//Adapted from http://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping#JavaScript
			var clip = function(subjectPolygon, clipPolygon) {
				// console.log("Layer.Grid():getNewTiles():clipCuttingPolygonByMaxDistance():clip()");
				// console.log(this);
				// subjectPolygon.pop();
				// subjectPolygon.forEach(function(e,i,a){a[i]= e.toArray();});
				//console.log(subjectPolygon.length);
				//clipPolygon.pop();
				// clipPolygon.forEach(function(e,i,a){a[i]= e.toArray();});
				//console.log(clipPolygon);

	            var clip1, clip2, the_s, the_e;
	            var inside = function (the_p) {
	                return (clip2[0]-clip1[0])*(the_p[1]-clip1[1]) > (clip2[1]-clip1[1])*(the_p[0]-clip1[0]);
	            };
	            var intersection = function () {
	                var dc = [ clip1[0] - clip2[0], clip1[1] - clip2[1] ],
	                    dp = [ the_s[0] - the_e[0], the_s[1] - the_e[1] ],
	                    n1 = clip1[0] * clip2[1] - clip1[1] * clip2[0],
	                    n2 = the_s[0] * the_e[1] - the_s[1] * the_e[0],
	                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);
	                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];
	            };
	            var outputList = subjectPolygon;
	            clip1 = clipPolygon[clipPolygon.length-1];
	            // for (j in clipPolygon) {
	            for (var j=0,ln_j=clipPolygon.length;j<ln_j;j++) {
	                /*var*/ clip2 = clipPolygon[j];
	                var inputList = outputList;
	                outputList = [];
	                the_s = inputList[inputList.length - 1]; //last on the input list
	                // for (i in inputList) {
	                for (var i=0,ln=inputList.length; i < ln; i++) {
	                    var the_e = inputList[i];
	                    if (inside(the_e)) {
	                        if (!inside(the_s)) {
	                            outputList.push(intersection());
	                        }
	                        outputList.push(the_e);
	                    }
	                    else if (inside(the_s)) {
	                        outputList.push(intersection());
	                    }
	                    the_s = the_e;
	                }
	                clip1 = clip2;
	            }
	            //console.log("outputList: " +outputList);
	           // outputList.forEach(function(e,i,a){a[i]=new THREE.Vector2().fromArray(e);});
	           	// outputList.push(outputList[0]);
	           	return outputList;
	       }.bind(this);
	        
	        //start algorithm
	        
	        var extentPolygon = (_maxExtent)? _maxExtent.toPolygonV2() : null;
	        // console.log('clipcuttingpolybyextent._maxExtent', _maxExtent.max, this.distanceReferencePoint);
			if(extentPolygon) {
								extentPolygon.forEach(function (e,i,a){ a[i] = e.toVector2().toArray(); });
								extentPolygon.reverse();
							}
	        
	        // console.log("CCW extent: "+ isCCW(extentPolygon));
	        var subjPoly = createCirclePolygon(this.distanceReferencePoint, radius); //Array of Arrays
 	        // console.log("CCW circle: "+ isCCW(subjPoly));
 	        //console.log(polygon);
 	        polygon.pop();
 	        polygon.forEach(function(e,i,a){a[i]= e.toArray();});
 	        if(isCCW(polygon)){polygon.reverse();}
 	        // console.log("CCW frustum cut: "+ isCCW(polygon));
	        var clippedPoly = clip(subjPoly, polygon);//clip(polygon, subjPoly );//
	        //@TODO if maxExtent clip by its bbox rectangle
			// console.log(polygon);
			// console.log(subjPoly);
			// console.log(clippedPoly); //before clipped with maxExtent
			// console.log(extentPolygon);
// 			
			// console.log("CCW clippedPoly: "+ isCCW(clippedPoly));
			if (extentPolygon){
				clippedWithExtent = clip(extentPolygon,clippedPoly);
				//clippedWithExtent = clip(clippedPoly,extentPolygon);
				clippedPoly = clippedWithExtent;
			}
			
			//add first point as last
			if(clippedPoly.length > 0){ 
				clippedPoly.push(clippedPoly[0]);
				// console.log(clippedPoly);
				clippedPoly.forEach(function(e,i,a){a[i]=new THREE.Vector2().fromArray(e);});
				}
			// console.log('clippedPoly',clippedPoly.length);
	        return clippedPoly;
	        
		}.bind(this);
		
		/*
		 * restrict Polygon by angle and distance to camera
		 * 
		 * 5 degress could be a housenumber
		 */
		var restrictPolygonByAngleAndDistance = function(polygon, camera, minAngleDeg, maxDistance) {
			
			var minAngleDeg = minAngleDeg || 5;
			var minAngleRad = THREE.Math.degToRad(minAngleDeg);
			var tanMinAngle = Math.tan(minAngleRad);
			// var camerapos = camera.position.clone();
			// var PI_2 = Math.PI/2;
			//reduce by angle
			//check n-1 points of polygon nth point same as first of they undergo minAngleDeg
			//
			var angleToCam = function(point) {
				var camSubPoint = camera.position.clone().sub(point);
				var camSubPointOnPlane = camSubPoint.clone().setY(0);
				var angleToCamera = camSubPoint.angleTo(camSubPointOnPlane);
				return angleToCamera;
			};
			
			for(var i=0,j=polygon.length; i<j; i++){
				var camSubPoint = camera.position.clone().sub(polygon[i]);
				var camSubPointOnPlane = camSubPoint.clone().setY(0);
				var angleToCamera = camSubPoint.angleTo(camSubPointOnPlane);
				// var angleToCamera = angleToCam(polygon[i]);
				// console.log("angleToCamera: " + THREE.Math.radToDeg(angleToCamera) );
				if (angleToCamera < minAngleRad){
					//move point towards camera to meet angle restrictions
					// console.log("height: " + camSubPoint.clone().sub(camSubPointOnPlane).length()  );
					var distCamSubPointOnPlaneToTarget = camSubPoint.clone().sub(camSubPointOnPlane).length() / tanMinAngle;
					// console.log("distCamSubPointOnPlaneToTarget: " + distCamSubPointOnPlaneToTarget);
					var target = polygon[i].clone().sub(camSubPointOnPlane).normalize().multiplyScalar(distCamSubPointOnPlaneToTarget);
					// console.log("new deg: "+ THREE.Math.radToDeg(angleToCam(target)));
					
					polygon[i] = target;
				}
			};
			return polygon;
		};
		
		/**
		 * @method getOutlineTiles
		 * @private
 		 * @param {Array of THREE.Vector3} polygon
		 */
		var getOutlineTiles = function(polygon, tileSize) {
			// console.log("Layer.Grid():update():getNewTiles():getOutlineTiles()");
			// console.log(this);
			var outlineTiles=[];
			var gridLines2d =[];
			
			// var getV2fromV3 = function(v3) {
				// var v2 = new THREE.Vector2(v3.x, v3.z);
				// return v2;
			// };
			
			//get 2D Lines from Polygon and convert coordinates to grid index coords
			for(var i=0,j=polygon.length-1; i<j; i++){
			  var line = new GIScene.Grid.GridLine(this.grid.getIndexFromPoint2d( polygon[i], tileSize ) , this.grid.getIndexFromPoint2d( polygon[i+1], tileSize ));
			  // console.log(line.start.x +" "+ line.start.y);
			  gridLines2d.push(line);
			};
			
			//getTilesFromLines 
			
			
			
			for(var i=0,j=gridLines2d.length; i<j; i++){
			  outlineTiles = outlineTiles.concat(this.grid.getTilesFromGridLine(gridLines2d[i])); 
			};
			
			//get unique tiles!!, remove duplicates
			return GIScene.Utils.removeDuplicatesFromArray(outlineTiles);
		}.bind(this);
		
		
		var getFillTiles = function(outlineTiles){
			// console.log("Layer.Grid():update():getNewTiles():getFillTiles()");
			// console.log(this);
			
			//scanline
			
			//sort by y
			ySortedOutlineTiles={};
			for(var i=0,j=outlineTiles.length; i<j; i++){
				(outlineTiles[i].y.toString() in ySortedOutlineTiles)? ySortedOutlineTiles[outlineTiles[i].y.toString()].push(outlineTiles[i].x) : ySortedOutlineTiles[outlineTiles[i].y.toString()] = [outlineTiles[i].x]; 
			};
			// console.log(ySortedOutlineTiles);
			//only fill if scanline hits 2 x values
			var fillTiles = [];
			for(scanline in ySortedOutlineTiles){
				var xValues = ySortedOutlineTiles[scanline].sort(function(a,b){return a-b;}); //x always from l to r
				//console.log(xValues);
				if (xValues.length > 1){
					var y = parseInt(scanline);
					// console.log(y);
					var number=0, startX=0;
					// if (xValues.length == 2){
						// number = xValues[1] - xValues[0] - 1;
						// startX = xValues[0];	
					// }
					// else //4 or more xvalues
					// {
					for(var i=1,j=xValues.length; i<j; i++){
					  //find start
					  if(xValues[i] - xValues[i-1] != 1){
					  	number = xValues[i] - xValues[i-1] -1;
					  	startX = i-1;//xValues[i-1];
					  }
					 }
					 // console.log("number: " + number);
					 // console.log("startX: " + startX);
					 // console.log("xValues: "+ xValues);
					//}
					//fillTiles
					for(var i=0,j=number; i<j; i++){
						//console.log("xValues[i+startX]"+parseInt(xValues[startX]+i+1));
					  fillTiles.push(new GIScene.Grid.Index(xValues[startX]+i+1,y,this.grid.tileSize));
					};
				}
			}
			return fillTiles;
		}.bind(this);
		
		/////
		//+ Jonas Raoni Soares Silva
		//@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]
		//@param poly {Array of Objects with x and y property. Last element equals the first element.}
		//@param pt {Object with x and y propery}
		// adapted by M.Auer
		//
		var isPointInPoly = function (poly, pt){
		    for(var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)
		        ((poly[i].y <= pt.y && pt.y < poly[j].y) || (poly[j].y <= pt.y && pt.y < poly[i].y))
		        && (pt.x < (poly[j].x - poly[i].x) * (pt.y - poly[i].y) / (poly[j].y - poly[i].y) + poly[i].x)
		        && (c = !c);
		    return c;
		};
		
		//tile intersects polygon
		var tileIntersectsPolygon = function(tile, polygon) {
			// console.log("tileIntersectsPolygon");

				// from http://www.java-gaming.org/index.php?topic=22590.0
			   function linesIntersect( x1,  y1,  x2,  y2,  x3,  y3,  x4,  y4){
			      // Return false if either of the lines have zero length
			      if (x1 == x2 && y1 == y2 ||
			            x3 == x4 && y3 == y4){
			         return false;
			      }
			      // Fastest method, based on Franklin Antonio's "Faster Line Segment Intersection" topic "in Graphics Gems III" book (http://www.graphicsgems.org/)
			      var ax = x2-x1;
			      var ay = y2-y1;
			      var bx = x3-x4;
			      var by = y3-y4;
			      var cx = x1-x3;
			      var cy = y1-y3;
			
			      var alphaNumerator = by*cx - bx*cy;
			      var commonDenominator = ay*bx - ax*by;
			      if (commonDenominator > 0){
			         if (alphaNumerator < 0 || alphaNumerator > commonDenominator){
			            return false;
			         }
			      }else if (commonDenominator < 0){
			         if (alphaNumerator > 0 || alphaNumerator < commonDenominator){
			            return false;
			         }
			      }
			      var betaNumerator = ax*cy - ay*cx;
			      if (commonDenominator > 0){
			         if (betaNumerator < 0 || betaNumerator > commonDenominator){
			            return false;
			         }
			      }else if (commonDenominator < 0){
			         if (betaNumerator > 0 || betaNumerator < commonDenominator){
			            return false;
			         }
			      }
			      if (commonDenominator == 0){
			         // This code wasn't in Franklin Antonio's method. It was added by Keith Woodward.
			         // The lines are parallel.
			         // Check if they're collinear.
			         var y3LessY1 = y3-y1;
			         var collinearityTestForP3 = x1*(y2-y3) + x2*(y3LessY1) + x3*(y1-y2);   // see http://mathworld.wolfram.com/Collinear.html
			         // If p3 is collinear with p1 and p2 then p4 will also be collinear, since p1-p2 is parallel with p3-p4
			         if (collinearityTestForP3 == 0){
			            // The lines are collinear. Now check if they overlap.
			            if (x1 >= x3 && x1 <= x4 || x1 <= x3 && x1 >= x4 ||
			                  x2 >= x3 && x2 <= x4 || x2 <= x3 && x2 >= x4 ||
			                  x3 >= x1 && x3 <= x2 || x3 <= x1 && x3 >= x2){
			               if (y1 >= y3 && y1 <= y4 || y1 <= y3 && y1 >= y4 ||
			                     y2 >= y3 && y2 <= y4 || y2 <= y3 && y2 >= y4 ||
			                     y3 >= y1 && y3 <= y2 || y3 <= y1 && y3 >= y2){
			                  return true;
			               }
			            }
			         }
			         return false;
			      }
			      return true;
			   }
			
			var tileCorners = this.grid.getCornerCoordsFromIndex(tile);
			for(var i=0,j=polygon.length-1; i<j; i++){
				//iterate segments
				var tileIntersects =		linesIntersect(tileCorners[0].x,tileCorners[0].y, tileCorners[1].x,tileCorners[1].y, polygon[i].x, polygon[i].y, polygon[i+1].x, polygon[i+1].y )
										||	linesIntersect(tileCorners[1].x,tileCorners[1].y, tileCorners[2].x,tileCorners[2].y, polygon[i].x, polygon[i].y, polygon[i+1].x, polygon[i+1].y )
										||	linesIntersect(tileCorners[2].x,tileCorners[2].y, tileCorners[3].x,tileCorners[3].y, polygon[i].x, polygon[i].y, polygon[i+1].x, polygon[i+1].y )
										||	linesIntersect(tileCorners[3].x,tileCorners[3].y, tileCorners[0].x,tileCorners[0].y, polygon[i].x, polygon[i].y, polygon[i+1].x, polygon[i+1].y )
										;  
				if(tileIntersects)return true;  
			}
			return false;
			;
		}.bind(this);
			
		
		
		//reduce to maxNumTiles
		var workingVector = new THREE.Vector3();
		var distToCam = function (elementA, elementB) {
			var cameraPosition = this.scene.camera.position.clone();
			var centroidA = this.grid.getCentroidFromIndex(elementA);
			workingVector.set(centroidA.x, this.terrainHeight, centroidA.y);
			var distA = cameraPosition.distanceTo(workingVector);
			var centroidB = this.grid.getCentroidFromIndex(elementB);
			workingVector.set(centroidB.x, this.terrainHeight, centroidB.y);
			var distB = cameraPosition.distanceTo(workingVector);
			return distA - distB;
		}.bind(this);
		
		//area of 2D Polygon
		var getPolygonArea = function(polygon) {
	        var area = 0.0;
	        if ( polygon.length > 2 ) {
	            var sum = 0.0;
	            for (var i=0, len=polygon.length; i < len-1; i++) {
	                var b = polygon[i];
	                var c = polygon[i+1];
	                sum += (b.x + c.x) * (c.y - b.y);
	            }
	            area = - sum / 2.0;
	        }
	        return Math.abs(area);
	   };

		// calculates the point projected from the bottom center of the viewport on the plane at terrainHeight
		var getCenterBottomPoint = function() {
			var nearB = new THREE.Vector3(0,-1,1);
			var farB  = new THREE.Vector3(0,-1,-1);
			var nearT = new THREE.Vector3(0,1,1);
			var farT  = new THREE.Vector3(0,1,-1);
			
			var projector = new THREE.Projector();
			var nearBWorld = projector.unprojectVector(nearB, this.scene.camera);
			var farBWorld = projector.unprojectVector(farB, this.scene.camera);
			var nearTWorld = projector.unprojectVector(nearT, this.scene.camera);
			var farTWorld = projector.unprojectVector(farT, this.scene.camera);
			var checkLineB = new THREE.Line3(nearB, farB);
			var checkLineT = new THREE.Line3(nearT, farT);
			var checkPlane = new THREE.Plane().setFromNormalAndCoplanarPoint(new THREE.Vector3(0,1,0), new THREE.Vector3(0,_terrainHeight,0));
			var centerBottomPoint = checkPlane.intersectLine(checkLineB);
			var centerTopPoint = checkPlane.intersectLine(checkLineT);
			var distanceReferencePoint = (centerBottomPoint)? centerBottomPoint : centerTopPoint;
			var centerBottomPoint2d = (distanceReferencePoint)?new THREE.Vector2(distanceReferencePoint.x, distanceReferencePoint.z) : null;
			return centerBottomPoint2d;
		}.bind(this);
		
		//============================================================
		//start algorithm
		//============================================================
		
		//get Height from existing tiles average or sample??
		
		var polygonPoints = intersectFrustrumAtTerrainHeight(_terrainHeight);//getHeight automatically
		// var polygonPointsFrustrumCut = polygonPoints.length;
		//add buffer around polygon
		//console.log(this.name+" intersectFrustrum", polygonPoints.length, getPolygonArea(polygonPoints), _terrainHeight);
		polygonPoints = addBufferToPolygon(polygonPoints, this.tileSizes[this.tileSizes.length-1]);
		
		
		// var poly3d=[];
		// for(var i=0,j=polygonPoints.length; i<j; i++){
			// poly3d.push(GIScene.Utils.vector2ToVector3(polygonPoints[i],_terrainHeight)); 
		// };
		// var line_geom = new THREE.Geometry();
		// line_geom.vertices = poly3d;
		// _polygon = new THREE.Line(line_geom);
		// this.scene.root.add(_polygon);
		
		//get centerbottom point of viewport on terrainHeight plane as reference for maxDistance calculations		
		var oldDistanceReferencePoint = this.distanceReferencePoint;
		this.distanceReferencePoint = getCenterBottomPoint() || oldDistanceReferencePoint;
		if(!this.distanceReferencePoint){return [];}
		

		//get clipped polygon
		polygonPoints = clipCuttingPolygonByMaxDistance(polygonPoints, this.maxDistance);
		//console.log(this.name+" clipCuttingPolygonByMaxDistance", polygonPoints.length);
		// poly3d = [];
		// for(var i=0,j=polygonPoints.length; i<j; i++){
		  // poly3d.push(GIScene.Utils.vector2ToVector3(polygonPoints[i],_terrainHeight)); 
		// };
		// var line_geom = new THREE.Geometry();
		// line_geom.vertices = poly3d;
		// _polygon = new THREE.Line(line_geom);
		// this.scene.root.add(_polygon);
		
		
		if(false){
		//Bresenham way
		console.time('bresenham');
		var outlineTiles = getOutlineTiles(polygonPoints); //Bresenham Lines
		//console.log("outlineTiles: "+outlineTiles.length);
		//console.log("tileSize: "+this.grid.tileSize);
		//console.log("terrainHeight: "+this.terrainHeight);
		
		var fillTiles = getFillTiles(outlineTiles); //scanline algorithm
		
		var allTiles = outlineTiles.concat(fillTiles);
		// console.log("numAllTiles: "+allTiles.length);
		
		
		
		//reduce
		// allTiles.sort(distToCam);
		// allTiles.length = this.maxNumTiles;
		
		// console.timeEnd('bresenham');
		//Bresenham way End
		}
		
		// allTiles=[];
		//Quadtree way
		if(true){
		// console.time('quadtree');
		// var origTileSize = this.grid.tileSize;  //@TODO use smallest TileSize this.tileSizes Math.min.apply(null,this.tileSizes);
		var smallestTileSize = Math.min.apply(null,this.tileSizes);
		var biggestTileSize  = Math.max.apply(null,this.tileSizes);
		var area = getPolygonArea(polygonPoints);
		//console.log(this.name+" area", area);
		var estNumberOfAllTiles = area/Math.pow(biggestTileSize,2);
		// var tileSizeFactor = Math.pow(2, Math.round(Math.log(Math.sqrt(area)/this.grid.tileSize)/Math.LN2));//nearest power of 2 on log scale (wikipedia)
		var tileSizeFactor = Math.pow(2, Math.round(Math.log(Math.sqrt(area)/smallestTileSize)/Math.LN2));//nearest power of 2 on log scale (wikipedia)
		
		// var tempTileSize= origTileSize*tileSizeFactor;
		var tempTileSize= smallestTileSize*tileSizeFactor;
		
		// console.log("Quadtree");
		/*console.log("origTileSize: "+origTileSize);
		console.log("area: "+area);
		console.log("estNumberOfAllTiles: "+estNumberOfAllTiles);
		console.log("tileSizeFactor: "+tileSizeFactor);
		console.log("tempTileSize: "+tempTileSize);
		*/
		if (estNumberOfAllTiles > 10000){
			var confirmed = confirm("estNumberOfAllTiles: "+Math.round(estNumberOfAllTiles)+". Stop calculating?");
			if(confirmed)return [];
		}
		
		var rootNodes;
		if(tileSizeFactor > 1){
			//this.grid.tileSize=tempTileSize;
			rootNodes = getOutlineTiles(polygonPoints, tempTileSize);
		}
		else {
			rootNodes = getOutlineTiles(polygonPoints, smallestTileSize);
		}
		// this.grid.tileSize=origTileSize;
		
		var traverseCriteria = function(node) {
			//tile is overlapping clipped viewport polygon
			var centroid2 = this.grid.getCentroidFromIndex(node);//v2
			var tileCorners = this.grid.getCornerCoordsFromIndex(node);
			
			var isTileOverlappingPolygon =		
												isPointInPoly(polygonPoints, tileCorners[0])
											||	isPointInPoly(polygonPoints, tileCorners[1])
											||	isPointInPoly(polygonPoints, tileCorners[2])
											||	isPointInPoly(polygonPoints, tileCorners[3])
											||	isPointInPoly(polygonPoints, centroid2)
											||	tileIntersectsPolygon(node, polygonPoints)
											;
			
			return isTileOverlappingPolygon;
			
			
		}.bind(this);
		
		var isLeafNode = function(node) {
			var isLeaf = false;
			
				
				
				if(node.tileSize <= this.tileSizes[0] && node.tileSize > this.tileSizes[this.tileSizes.length-1]){ //all tileSizes exept the smallest one
					var nodeCentroid = this.grid.getCentroidFromIndex(node);
					
					//is in distance of distanceReferencePoint
					// if(this.distanceReferencePoint.distanceTo(nodeCentroid) > node.tileSize * this.lodDistanceFactor){
						// isLeaf = true;
					// }
					//is in distance of camera
					//var camPos = new THREE.Vector2(this.scene.camera.position.x, this.scene.camera.position.z);
					var nodeCentroid3d = new THREE.Vector3(nodeCentroid.x, _terrainHeight, nodeCentroid.y);
					if(this.scene.camera.position.distanceTo(nodeCentroid3d) > node.tileSize * this.lodDistanceFactor){
						isLeaf = true;
					}
					
				}else if(node.tileSize == this.tileSizes[this.tileSizes.length-1]){
					isLeaf = true;
				}
				
				
			
			
			return isLeaf;
		}.bind(this);
		
		var onTileIsLeaf = function(node) {
				//@TODO better check for 3d distance OR checkfor distance to point on ground projected from centerbottom of viewport
				//var camera2d = new THREE.Vector2(this.scene.camera.position.x,this.scene.camera.position.z);
				
				
				// var nodeCentroid = this.grid.getCentroidFromIndex(node);
				// if(this.distanceReferencePoint.distanceTo(nodeCentroid)<= this.maxDistance)
					allTiles.push(node);
		}.bind(this);
		
		var allTiles = [];
		for(var i=0,j=rootNodes.length; i<j; i++){
		  this.grid.traverseIf(rootNodes[i],traverseCriteria,isLeafNode,onTileIsLeaf);
		};
		// console.timeEnd("quadtree");
		}
		//Quadtree way end
		
		// log2 = document.getElementById('log2');
		// log2.innerHTML = "PolyPts: "+ polygonPoints.length
		// +" PolyFrutrumCutPts: "+ polygonPointsFrustrumCut;
						// +"RootNodes: "+ rootNodes.length
						// +" TempTS: "+ tempTileSize
						// +" DRPt: "+ this.distanceReferencePoint.toArray();
						
		
		return allTiles;
	};
	
	/**
	 * updates the current tiles, loads new tiles and removes old ones
	 * @method update
	 */
	var oldTilesString=[];
	this.oldTiles=[];
	this.update = function() {
		// console.log("Layer.Grid():update()");
		// console.log(this);
		//console.time("update");
		var  newTiles, remove, keep, load;
		
		newTiles = this.computeTileIndicesHandler();
		
		// console.time('string');
		// var newTilesString = new Array(newTiles.length);
// 		
		// newTiles.forEach(function(item){
								// newTilesString.push(JSON.stringify(item));
		// });
// 		
		// var remove = oldTilesString.filter(function (item, index, array) {
		                       // return newTilesString.indexOf(item) == -1;
		                      // });
		// var keep = oldTilesString.filter(function (item, index, array) {
		                       // return newTilesString.indexOf(item) != -1;
		                       // });                       
// 		                       
		// var load = newTilesString.filter(function (item, index,array){
		                        // return  oldTilesString.indexOf(item) == -1;
		                   // });
		// console.timeEnd('string');
		
		// console.time('obj');
		
		
		
		
		this.remove = this.oldTiles.filter(function(v,ix,a){
			return !(newTiles.some(function(v_){
				return (v_.equals(v));
			}));
		});
		
		//just for error checking, not needed in production
		// var keep_ = this.oldTiles.filter(function(v,ix,a){
			// return (newTiles.some(function(v_){
				// return (v_.equals(v));
			// }));
		// });
		
		this.load = newTiles.filter(function (v,ix,a){
			return !(this.oldTiles.some(function(v_){
				return (v_.equals(v));
			}));
		}.bind(this));
		
		
		
		
		//remove load items from newTiles(oldTiles in next iteration), add loaded later but not in loading
		this.oldTiles = newTiles.filter(function(v,ix,a){
			return !(this.load.some(function(v_){
				return (v_.equals(v));
			}));
		}.bind(this));
		// this.oldTiles = newTiles;
		
		
		
		// console.log("generalize", generalize);
		
		// gehe alle remove durch und checke ob desendantOf load
		
		//which are parents to be removed by a number of children. Load x and remove parent
		// load has parent in remove?
		var specialize = {}; // {"parent":[descendants]}
		//gehe alle load durch und checke ob sie abstammende sind von einem remove
		
		//SPECIALIZE
		this.load.forEach(function(el, il, al){
			
			this.remove.forEach(function (er, ir, ar){
				if(this.grid.isDescendantOf(el, er)){
					// if(!specialize[er.toString()]) {specialize[er.toString()] = [];};
					// specialize[er.toString()].push(el);
					
					// if(this.specialize.getTile(er) === false){
						// this.specialize.add(er,[el]);
					// }
					// else{
						// this.specialize.object.push(el);
					// }
					// console.log("specialize", this.specialize);
					//not yet removed 
					this.oldTiles.push(ar[ir]); //keep in oldTiles for next iteration check
					ar[ir] = null; //do not remove
				}
			}.bind(this));
		}.bind(this) );
// 		
		// //check for specialize remove. Remove parent if all children are in loaded
		// for(parent in this.specialize.store){
			// var descendants = this.specialize.store[parent].object;
			// var allLoaded = descendants.every(function(e,i,a){
				// return this.loaded.getTile(e);
			// }.bind(this));
			// if(allLoaded){
// 				
				// this.specialize.remove(new GIScene.Grid.Index().fromString(parent));
				// this.remove.push(new GIScene.Grid.Index().fromString(parent));
			// }else{
				// // auto update specialize???
				// this.specialize.remove(new GIScene.Grid.Index().fromString(parent));
				// newTiles.push(new GIScene.Grid.Index().fromString(parent));
			// }
		// }
		//
		
		
		//find out which of the new ones replace children. Load one remove all descendants
		// load has children in remove?
		// generalize
		var generalize = {};
		
		this.load.forEach(function(el,il,al){
			this.remove.forEach(function(er, ir, ar){
				if(this.grid.isDescendantOf(er, el)){
					// if(!generalize[el.toString()]) {generalize[el.toString()] = [];};
					//add remove index to generalize for later removement
					// console.log("generalizePush", er);
					// generalize[el.toString()].push(er);
					// console.log("generalize", generalize);
					//remove generalize descentands from immediately remove array
					// this.remove = this.remove.filter(function(e,i,a){
						// return e.toString() != er.toString();
					// });
					//not yet removed 
					this.oldTiles.push(ar[ir]); //keep in oldTiles for next iteration check
					ar[ir] = null; //do not remove
					
				}
			}.bind(this)); 
		}.bind(this));
		//______
		// else{
			//find out which ones to remove immediately
			// remove rest immediately
		// }
		
		
		


		// console.timeEnd('obj');
		
		// console.log(remove.length);
		// console.log(keep.length);
		// console.log(load.length);
		// console.log(this.remove.length);
		// console.log(keep_.length);
		// console.log(this.load.length);
		                   
		//removeTiles(remove); //cancelTiles in Loading queue
		//keepInCacheTiles
		//deleteTiles
			
		//sort load by distance to camera
		// this.removeTiles(this.abort, generalize);
		
		this.loadTiles(this.load, generalize, specialize);
		this.removeTiles(this.remove, generalize);
		
		//check loading tiles for abortion
		this.abort = 
		this.loading.indexStore.store.filter(function(v,ix,a){
			return !(this.load.some(function(v_){
				return (v_.equals(new GIScene.Grid.Index().fromString(v)));
			}));
		}.bind(this));
		//console.log("abort", this.abort.length);
		this.removeTiles(this.abort, generalize);
		
		// this.oldTiles = newTiles;
		// oldTilesString = newTilesString;
		// console.timeEnd("update");
	};
	
	/**
	 * set an approximate terrain height at which the view frustrum will be cut horizontally to determine the visible tiles to be loaded
	 * @method setTerrainHeight
	 * @param {Number} height the terrain height in coordinate reference system (CRS) units (e.g. meters)
	 */
	this.setTerrainHeight = function(height) {
		this.terrainHeight = height;
		_terrainHeight = (this.scene)? this.terrainHeight - this.scene.config.offset.z : this.terrainHeight;
		// console.log(_terrainHeight);
	};
	
	/**
	 * set the max extent of the layer to restrict loading of tiles to a rectangle/bounding box
	 * @method setMaxExtent
	 * @param {GIScene.Extent2} maxExtent2 a 2D bounding box in coordinate reference system (CRS) units 
	 */
	this.setMaxExtent = function(maxExtent2) {
		if(maxExtent2){
			if(this.scene){
				var offset2 = new GIScene.Coordinate2(this.scene.config.offset.x, this.scene.config.offset.y); 
				var min = maxExtent2.min.clone().sub(offset2);
				var max = maxExtent2.max.clone().sub(offset2);
				_maxExtent = new GIScene.Extent2(new GIScene.Coordinate2(min.x, min.y), new GIScene.Coordinate2(max.x, max.y));
				
			}
			else{
				_maxExtent = this.maxExtent;
			}
			
			// console.log(this.name+ ' _maxExtent', _maxExtent);
		}
	};
	
	/**
	 * switches the visibility of the layer on or off
	 * @method setVisibility
	 * @param {Boolean} visibility 
	 */
	this.setVisibility = function(visibility) {
		(visibility)?this.startUpdate():this.stopUpdate();
		GIScene.Layer.Grid.prototype.setVisibility.call(this, visibility);
	};
	
	//start auto initialization 
	this.init();
	
	// when added to a scene 
	var onSetScene = function(event) {
		console.log('Grid.onSetScene ' + this.name);
		var scene = event.content;
		
		this.grid = (scene) ? new GIScene.Grid({origin:this.origin, tileSizes:this.tileSizes, sceneOffset:scene.config.offset})
								 : null
								 ;
		//_terrainHeight = this.terrainHeight - scene.config.offset.z;
		this.setTerrainHeight(this.terrainHeight);
		
		//this.maxExtent = (this.maxExtent)? this.maxExtent[0].toVector3(). : null;
		this.setMaxExtent(this.maxExtent);
		
		(scene) ? this.startUpdate() : this.stopUpdate();
	}.bind(this);
	this.addEventListener('setScene', onSetScene);
	
	
	if(this.config.overrideMaterialHandler){
		//this.addEventListener('afterSetOverrideMaterial', this.config.overrideMaterialHandler);
		this.setOverrideMaterialHandler(this.config.overrideMaterialHandler);
	}
	
	if(this.attributeReader){
		
		var setAttributes = function(event) {
			
			var root = (!!event)? event.content.tile : this.root;
			
			root.traverse(function(object){
				if( ! ("gisceneAttributes" in object.userData) ){object.userData.gisceneAttributes = {}; }
				for (attr in this.attributeReader){
					object.userData.gisceneAttributes[attr] = this.attributeReader[attr](object);
				}
			}.bind(this) );
		}.bind(this);
		
		//check for already loaded objects
		setAttributes();
		//check all new loaded objects on load event
		this.addEventListener('tileload', setAttributes);
	}
	
	//if(this.virtualSelectionAccessor){
	
		
		// var selectVirtualSelection = function(event) {
// 			
			// var root = (!!event)? event.content.tile : this.root;
			// var matches = [];
			// for (var i=0,l=this.virtualSelection.length; i < l ; i++){
				// var match = GIScene.Utils.getObjectsBy(root, function(object){
					// return this.virtualSelectionAccessor(object) == this.virtualSelection[i];
				// }.bind(this));
				// //Array.prototype.push.apply( matches, match);
				// if(match.length > 0){
					// this.selectControl.select(match[i]);
					// this.virtualSelection.splice(i,1);
				// }		
			// }	 
		// }.bind(this);
// 		
		// var restoreVirtualSelection = function(event) {
			// var tile = event.content.tile;
// 			
			// tile.traverse(function(object){
				// if(object.userData.isSelected){
					// this.virtualSelection.push(this.virtualSelectionAccessor(object));
					// this.selectControl.unselect(object);
				// }
			// }.bind(this));
// 			
		// }.bind(this);
		
	var selectSelectionQueryStack = function(event) {
		if(this.selectionQueryStack){
			this.selectByAttributes(this.selectionQueryStack,event.content.tile);
		}
		
	}.bind(this);
	
	var unselectAllOnTileRemove = function(event) {
		var tile = event.content.tile;
		
		tile.traverse(function(object){
				if(object.userData.isSelected){
					this.selectControl.unselect(object);
				}
			}.bind(this)
		);
		
	}.bind(this);
	
	//check already loaded
	//selectVirtualSelection();
	if(this.selectionQueryStack)this.selectByAttributes(this.selectionQueryStack);
	
	//check future added tiles
	this.addEventListener('tileadd', selectSelectionQueryStack);
	
	//unselect all on tile remove
	this.addEventListener('tileremove',unselectAllOnTileRemove);
		
	
};

//Inherit from GIScene.Layer
GIScene.Layer.Grid.prototype = Object.create( GIScene.Layer.prototype );


//Prototype Methods

GIScene.Layer.Grid.prototype.setOverrideMaterial = function(node, overrideMaterial) {
	
	//set material to loaded tiles
	GIScene.Layer.prototype.setOverrideMaterial.apply(this, [node, overrideMaterial]);
	
	//set material to cached tiles
	var tileStore = this.cache.store;
	for(tile in tileStore){
		var object = tileStore[tile].object;
		GIScene.Layer.prototype.setOverrideMaterial.apply(this, [object, overrideMaterial]);
	}
	
};

GIScene.Layer.Grid.prototype.setOverrideMaterialHandler = function(overrideMaterialHandler) {
	if(overrideMaterialHandler){
		//remove the old
		if(this.overrideMaterialHandler){
			this.removeEventListener('afterSetOverrideMaterial', this.overrideMaterialHandler);
		}
		//set the new
		this.overrideMaterialHandler = overrideMaterialHandler;
		this.addEventListener('afterSetOverrideMaterial', this.overrideMaterialHandler);
	}
	else{
		if(this.overrideMaterialHandler){
			this.removeEventListener('afterSetOverrideMaterial', this.overrideMaterialHandler);
		}
	}
	
};

GIScene.Layer.Grid.prototype.setActiveStyle = function(style){
	
	if( !style ||  (typeof style == 'string' && style.toLowerCase() == "default") ){
			style = this.styles[0];
		}
	
	//is layer grid?
	// var isGridLayer = layer instanceof GIScene.Layer.Grid;				
	// console.log("isGridLayer", isGridLayer);
	
	var recursive = style.recursive; //TODO implement recursive as parameter of setOverrideMaterial
	var material = style.material;
	var selectionType = (style.rootObjects)? "byObjects" : (style.rootObjectKeyAttribute)? "byAttributes" : "selectAll";
	
	//isMaterrial RasterOverlay or WMSOvwerlay
	var isWMSOverlayMaterial = material instanceof GIScene.WMSOverlayMaterial;
	console.log("isWMSOverlayMaterial",isWMSOverlayMaterial);
	
	if(/*isGridLayer && */ isWMSOverlayMaterial){
		this.setOverrideMaterialHandler(GIScene.OverrideMaterialHandler.WMS);
		
	}else{
		this.setOverrideMaterialHandler(null);
		
	}
	
	GIScene.Layer.prototype.setActiveStyle.apply(this, [style]); //@TODO instead of using super class method, implement event driven updates onTileAdd similar to selection queryStack 
	
};
/**
 * Tiled multi LOD grid layer using the W3DS v0.4.0 OGC Discussion Paper Specification to load georeferenced 3D data
 * inherits from GIScene.Layer.Grid
 * 
 * @namespace GIScene
 * @class Layer.W3DS_0_4_0
 * @constructor
 * @extends GIScene.Layer.Grid
 * @param {String} name the layer name 
 * @param {Object} [config] a configuration object
 * @example
 * 			var layerconfig = {
				 url:"http://www.example.org/w3ds", 
				 // withCredentials:true,
				 layer:"DEM",
				 crs:"EPSG:32616", 
				 origin:new GIScene.Coordinate2(264495.0,1639108.0),
				 offset:new GIScene.Coordinate3(264495.0,1639108.0,600), //w3ds GetScene offset param from this
				 tileSizes:[1024,512,256,128], 
				 terrainHeight:600,
				 maxExtent: new GIScene.Extent2(new GIScene.Coordinate2(264495.0, 1639108.0), new GIScene.Coordinate2(274495.0, 1649108.0)),
				 maxDistance: 10000,
				 lodDistanceFactor :1.5,
				 format:GIScene.Format.Scene,
				 overrideMaterial : wmsOverlayMaterial,
				 overrideMaterialHandler : GIScene.OverrideMaterialHandler.WMS //only together with GIScene.WMSOverlayMaterial
				 // overrideMaterial : new THREE.MeshBasicMaterial({wireframe:true})
			};
			var layer = new GIScene.Layer.W3DS_0_4_0("w3ds",layerconfig);
			scene.addLayer(layer);
 * 
 */

GIScene.Layer.W3DS_0_4_0 = function(name, config) {
	
	GIScene.Layer.Grid.apply(this, [name, config]);
	
	var defaults = {
		layer	: null,
		crs		: null,
		tileSizes : [1024,512,256,128]
	};
	
	// this.config = GIScene.Utils.mergeObjects(this.config, defaults);
	this.config = GIScene.Utils.mergeObjects(defaults, this.config);
	
	var w3dsConfig = {
		url: this.url,
		withCredentials : this.config.withCredentials,
		tileSizes : this.config.tileSizes
	};
	
	var w3dsParams = {
		crs: this.config.crs,
		layer : this.config.layer,
		offset : null
	};
	
	this.config.service = new GIScene.Service.W3DS_0_4_0(w3dsConfig, w3dsParams);
	
	var onSetScene = function(event) {
		console.log("w3ds onSetScene");
		var scene = event.content;
		this.config.service.params.offset = (scene) ? this.grid.sceneOffset.toArray().join(",") : null;
	}.bind(this);
	this.addEventListener('setScene', onSetScene);
};

GIScene.Layer.W3DS_0_4_0.prototype = Object.create(GIScene.Layer.Grid.prototype);
/**
 * Tiled multi LOD grid layer using the W3DS v0.4.1 OGC Discussion Paper Specification to load georeferenced 3D data
 * inherits from GIScene.Layer.Grid
 * 
 * @namespace GIScene
 * @class Layer.W3DS_0_4_1
 * @constructor
 * @extends GIScene.Layer.Grid
 * @param {String} name the layer name 
 * @param {Object} [config] a configuration object
 * @example
 * 			var layerconfig = {
				 url:"http://www.example.org/w3ds", 
				 // withCredentials:true,
				 layer:"DEM",
				 crs:"EPSG:32616", 
				 origin:new GIScene.Coordinate2(264495.0,1639108.0),
				 offset:new GIScene.Coordinate3(264495.0,1639108.0,600), //w3ds GetScene offset param from this
				 tileSizes:[1024,512,256,128], 
				 terrainHeight:600,
				 maxExtent: new GIScene.Extent2(new GIScene.Coordinate2(264495.0, 1639108.0), new GIScene.Coordinate2(274495.0, 1649108.0)),
				 maxDistance: 10000,
				 lodDistanceFactor :1.5,
				 format:GIScene.Format.Scene,
				 overrideMaterial : wmsOverlayMaterial,
				 overrideMaterialHandler : GIScene.OverrideMaterialHandler.WMS //only together with GIScene.WMSOverlayMaterial
				 // overrideMaterial : new THREE.MeshBasicMaterial({wireframe:true})
			};
			var layer = new GIScene.Layer.W3DS_0_4_1("w3ds",layerconfig);
			scene.addLayer(layer);
 * 
 */

GIScene.Layer.W3DS_0_4_1 = function(name, config) {
	
	GIScene.Layer.Grid.apply(this, [name, config]);
	
	var defaults = {
		layer	: null,
		crs		: null,
		tileSizes : [1024,512,256,128],
		lods	: null
	};
	
	// this.config = GIScene.Utils.mergeObjects(this.config, defaults);
	this.config = GIScene.Utils.mergeObjects(defaults, this.config);
	
	var w3dsConfig = {
		url: this.url,
		withCredentials : this.config.withCredentials,
		tileSizes : this.config.tileSizes
	};
	
	var w3dsParams = {
		crs		: this.config.crs,
		layer 	: this.config.layer,
		offset 	: null,
		lods	: this.config.lods,
	};
	
	this.config.service = new GIScene.Service.W3DS_0_4_1(w3dsConfig, w3dsParams);
	
	var onSetScene = function(event) {
		console.log("w3ds onSetScene " + this.name);
		var scene = event.content;
		this.config.service.params.offset = (scene) ? this.grid.sceneOffset.toArray().join(",") : null;
	}.bind(this);
	this.addEventListener('setScene', onSetScene);
};

GIScene.Layer.W3DS_0_4_1.prototype = Object.create(GIScene.Layer.Grid.prototype);
/**
 * The Scene Object
 *
 * @namespace GIScene
 * @class Scene
 * @constructor
 * @extends THREE.EventDispatcher
 * @param {String} containerDivId The id of an HTMLDivElement which will be used as container for the webgl canvas.
 * @param {Object} [config] Allowed
 * values for config are:
 *
 * 	cameratype:	'perspective'|'ortho'
 *  near: {Number}
 *  far:  {Numver}
 *  fov:  {Number}
 * 
 *  width:	{Integer}
 *  height: {Integer}
 * 
 *  animate:{Boolean}
 *  
 *  center: 				{THREE.Vector3}
 *  positionFromCenter: 	{THREE.Vector3}
 *  projection: 			{String}
 *  units:					{String}
 *  offset:					{GIScene.Coordinate3}
 *  skyColor:				{THREE.Color}
 *  fog:					{THREE.Fog}
 */

GIScene.Scene = function(containerDivId, config) {

	/**
	 * The default config which is used when no config object is provided.
	 *
	 * @private
	 * @property defaults
	 * @type Object
	 **/
	var defaults = {

		//canvas options
		width : null,
		height : null,

		//render options
		animate : true, 
		fog : null,

		//scene options
		center : new THREE.Vector3(0, 0, 0),
		projection : 'EPSG:32616', //not yet used UTM16N???-->EPSG:32616
		units : 'm', //not yet used
		offset : new GIScene.Coordinate3(0,0,0), 
		//new THREE.Vector3(0,0,0), //new THREE.Vector3(269500, 550, -1641500), //not yet used offset is used to keep coordinates short.
		skyColor : new THREE.Color().setStyle('lightskyblue').getHex(),

		//camera options
		cameratype : 'perspective',
		near : 0.1,
		far : 1000,
		fov : 45, //for perspective camera only
		positionFromCenter : new THREE.Vector3(0, 0, 10),

		//data options
		// url : null,
		// format : null,
		// verticalAxis : "Y"

	};

	/**
	 * The config which is used to initialize the Scene. Merged from defaults and passed config Object.
	 *
	 * @property config
	 * @type Object
	 */
	this.config = GIScene.Utils.mergeObjects(defaults, config || {});


	//make this class an EventDispatcher
	//THREE.EventDispatcher.call( this );

	//canvas properties
	this.containerDiv = document.getElementById(containerDivId);
	this.canvas = null;
	//get size from config else from containerDiv-CSS Style else use default 500x500 px
	var width = null;
	width = (this.config.width) ? this.config.width :  this.containerDiv.clientWidth ;
	
	var height = null;
	height = (this.config.height) ?  this.config.height : (this.containerDiv.clientHeight > 0) ?  this.containerDiv.clientHeight :  500;

	//render properties
	var animationFrameId;

	//scene properties
	/**
	 * The scenegraph root node. Add {THREE.Object3D}-objects to this node. See THREE.js docs for further information
	 * @property root
	 * @type {THREE.Scene}
	 */
	this.root = null;
	/**
	 * The active camera. {THREE.CombinedCamera} can be switched from perspective to orthographic and vice versa
	 * @property camera
	 * @type {THREE.CombinedCamera}
	 */
	this.camera = null;
	//Camera gets a target object later in initScene()
	
	//THREE.Scene and THREE.Orthocamera to render Sprites in screen coordinate space
	this.spriteRoot = null;
	this.spriteCamera = null;
	
	this.lights = [];
	this.renderer = null;
	this.effectComposer = null;
	this.fog = null;
	this.layers = [];
	//Layers should add {THREE.Scene} objects to this.root
	this.center = new THREE.Vector3(0, 0, 0);

	//controls
	this.controls = [];

	//clock to be independent of framerates
	this.clock = new THREE.Clock();
	this.delta = null; //global, automatically updated in startAnimation() every frame

	this.init = function() {

		//initCanvas
		this.initCanvas();

		//initScene
		this.initScene();

		//animate: start renderLoop or render once
		(this.config.animate) ? this.startAnimation() : this.renderer.render(this.root, this.camera);

	};

	this.initCanvas = function() {
		//create canvas in div use div use size from config else from div element else
		this.canvas = document.createElement('canvas');
		this.canvas.className = "giscene_canvas";
		//remove line height from canvas containterDiv to fit the canvas exactly to its wrapper div
		this.containerDiv.style.lineHeight = 0;
		
		
		
		// this.canvas.style.width  = "100%";//width + "px";//
		// this.canvas.style.height = "100%";//height + "px";//
		this.containerDiv.appendChild(this.canvas);
		// this.containerDiv.style.width  = width + "px";
		// this.containerDiv.style.height = height + "px";
	};

	this.initScene = function(config) {
		//create THREE.Scene
		this.root = new THREE.Scene();
		this.root.name = 'root';
		
		//optionally add fog
		if(this.config.fog){this.root.fog = this.fog = this.config.fog.clone();}
		
		//initCamera
		//this.camera = (this.config.cameratype == 'ortho') ? new THREE.OrthographicCamera(width / -2, width / 2, height / 2, height / -2, this.config.near, this.config.far) : new THREE.PerspectiveCamera(this.config.fov, width / height, this.config.near, this.config.far);
		this.camera = new THREE.CombinedCamera(width, height, this.config.fov, this.config.near, this.config.far, this.config.near, this.config.far );
		this.camera.name = 'THREE.CombinedCamera';
		this.camera.target = new THREE.Object3D();
		this.camera.target.name = "Camera target";
		this.camera.add(this.camera.target);
		if(this.config.cameratype == 'ortho'){this.camera.toOrthographic();}

		/**
		 * Fires whenever camera position changes
		 *
		 * @event cameraChange
		 */
		var oldCamPos = new THREE.Vector3(0, 0, 0);
		var oldCamRot = new THREE.Vector3(0, 0, 0);
		var cameraHasChanged = function() {
			if (!oldCamPos.equals(this.camera.position) || !oldCamRot.equals(this.camera.rotation)) {
				
				this.dispatchEvent({type : 'cameraChange'});
				oldCamPos = this.camera.position.clone();
				oldCamRot = this.camera.rotation.clone();
			};
			
		}.bind(this);
		this.addEventListener('afterRender', cameraHasChanged);
		//this.addEventListener('beforeRender', cameraHasChanged);
		
		//init sprite scene and camera
		this.spriteRoot = new THREE.Scene();
		// this.spriteCamera = new THREE.OrthographicCamera(0,width,0,height,-100,100 ); //l,r,t,b,near,far
		var width1_2 = width/2;
		var heigh1_2 = height/2;
		this.spriteCamera = new THREE.OrthographicCamera(-width1_2,width1_2,heigh1_2,-heigh1_2,-100,100 ); //l,r,t,b,near,far
		// this.spriteRoot.add(this.spriteCamera);
		// this.camera.add(this.spriteCamera);
		
		//initLights
		this.directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);//new THREE.DirectionalLight(0xffffff, 0.5);
		this.directionalLight.name = "THREE.DirectionalLight";
		//color, intensity //position will be set by Control.CameraLight
		this.ambientLight = new THREE.AmbientLight(0xcccccc); //cc ^= 0.8   new THREE.AmbientLight(0xffffff);
		this.ambientLight.name = "THREE.AmbientLight";

		//experimental spot light
		this.headLight = new THREE.SpotLight(0xffffff,0.3,0,Math.PI/2,20);
		this.camera.add(this.headLight);
		this.headLight.target.position.setZ(-1000);
		this.camera.target.add(this.headLight.target);

		//initRenderer
		this.renderer = new THREE.WebGLRenderer({
			antialias : true,
			precision : "highp",
			canvas : this.canvas,
			devicePixelRatio: 1, //when browser is in zoom mode this ratio is changed and renderer.setSize uses it 
		});
		
		this.renderer.setSize(width, height);
		this.renderer.setClearColor(this.config.skyColor);
		this.renderer.autoClear = false;
		
		// init effectComposer
		this.effectComposer = new THREE.EffectComposer(this.renderer);
		this.effectComposer.setSize(width, height);
		
		// add objects to the scene
		this.root.add(this.camera);
		this.root.add(this.ambientLight);
		this.root.add(this.directionalLight);

		//setCenter
		// this.camera.position.add(this.config.positionFromCenter);
		// this.camera.target.position.setZ(-this.config.positionFromCenter.length());
		this.setCenter(this.config.center, this.config.positionFromCenter);
		
		//add Logo
		var gisceneLogoTexture = new THREE.Texture(null);
		var gisceneLogoImage = new Image();
		gisceneLogoImage.onload = function(e) {
			gisceneLogoTexture.image = gisceneLogoImage;
			gisceneLogoTexture.needsUpdate = true;
		};
		// dataURL from poweredbygiscenegiscience.png
		// gisceneLogoImage.src = "data:image/png;base64,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";	
		// dataURL from poweredbygiscenegiscience2.png
		gisceneLogoImage.src = "data:image/png;base64,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";
		var gisceneLogoMaterial = new THREE.SpriteMaterial({ map : gisceneLogoTexture, opacity:1  });
		var gisceneLogo = new THREE.Sprite(gisceneLogoMaterial);
		gisceneLogo.scale.set( 158, 20, 1 );
		gisceneLogo.position.set((this.canvas.width/2)-79,(-this.canvas.height/2)+10,0);
		this.spriteRoot.add(gisceneLogo);
		//will be called in this.onResize
		this.logoOnResize = function() {
			gisceneLogo.position.set((this.canvas.width/2)-79,(-this.canvas.height/2)+10,0);
		}.bind(this);
		

	};

	/**
	 * Start animation frame and render loop
	 *
	 * @method startAnimation
	 */
	this.startAnimation = function() {
		animationFrameId = requestAnimationFrame(this.startAnimation.bind(this));
		
		this.delta = this.clock.getDelta();
		
		TWEEN.update();
		
		this.renderer.clear(true,true,true); //color, depth, stencil; autoclear is false to render sprites on top of scene
		/**
		 * beforeRender Event will be executed directly before the render call in the render loop
		 * @event beforeRender
		 */
		this.dispatchEvent({
			type : 'beforeRender'
		});
		/**
		 * beforeRender2 Event will be executed directly before the render call in the render loop
		 * @event beforeRender
		 */
		this.dispatchEvent({
			type : 'beforeRender2'
		});
		
		//mcaTWEEN.update();	
		
		if(this.effectComposer.passes.length>0){
			this.effectComposer.render();
		}else{
			this.renderer.render(this.root, this.camera);
		}
		
		this.renderer.clear(false,true,false); //render sprites always on top, therefore clear depth buffer
		this.renderer.render(this.spriteRoot, this.spriteCamera);
		
		this.dispatchEvent({
			type : 'afterRender'
		});
	};

	/**
	 * Stop animation frame and render loop
	 *
	 * @method stopAnimation
	 */
	this.stopAnimation = function() {
		cancelAnimationFrame(animationFrameId);
	};

	this.setCenter_old = function(vector, positionFromCenter) {
		var translation = vector.clone().sub(this.center);
		//
		// //keep light direction but translate light.target
		// var lightWorld 		 = this.directionalLight.parent.localToWorld(this.directionalLight.position.clone());
		// var lightTargetWorld = this.directionalLight.target.parent.localToWorld(this.directionalLight.target.position.clone());
		// var lightWorldNew 	 = lightWorld.add(translation);
		// this.directionalLight.position = this.directionalLight.parent.worldToLocal(lightWorldNew);
		//
		// this.directionalLight.target.position = vector.clone();

		//scene center
		this.center = vector.clone();
		//focus camera on center
		if (positionFromCenter) {
			//translate and focus camera on center
			// console.log(positionFromCenter.length());
			this.camera.position = vector.clone().add(positionFromCenter);
			this.camera.lookAt(this.center);
			this.camera.target.position.setZ(-positionFromCenter.length());
			
		} else {
			//just translate
			this.camera.position.add(translation);
		}

		// var positionFromCenter = positionFromCenter || this.camera.position.clone().sub(this.camera.target.parent.localToWorld(this.camera.target.position.clone())); //new THREE.Vector3(0,0,0);
		// this.camera.position = vector.clone().add(positionFromCenter);
		// this.camera.target.position = positionFromCenter.clone().multiplyScalar(-1);
		//this.camera.lookAt(this.center);
		// //this.camera.target.position = this.camera.target.parent.worldToLocal(vector.clone());
		this.dispatchEvent({
			type : 'center',
			content : {
				center : vector.clone(),
				translation : translation,
				positionFromCenter : positionFromCenter
			}
		});
	};
	
	
	/**
	 * Jump to another place in the scene.
	 * 
	 * @method setCenter
	 * @param {THREE.Vector3} vector vector in scene coordinates
	 * @param {THREE.Vector3} positionFromCenter vector to place the camera at some distance from the point of interest (vector)
	 * @param {Number} duration duration in milliseconds. if undefined or > 0 an animation is perforemed from the current to the specified new center. Set this to 0 to jump immediately to the new location.
	 */
	var _setCenterActive=false;
	var _setCenterTween = null;
	this.setCenter = function(vector, positionFromCenter, duration) {
		// stop exisitng tween when a new one comes during animation time
		if(_setCenterActive && _setCenterTween){_setCenterTween.stop();_setCenterActive=false;}
		
		if(!_setCenterActive){
				_setCenterActive = true;
		//var active = "false"; // avoid multiple calls at a time
		var duration = (duration == null)?1000:duration;
		var oldCamTargetPos	= this.center;//this.camera.localToWorld(this.camera.target.position.clone());
		var newCamTargetPos	= vector.clone();
		var positionFromCenter = positionFromCenter || this.camera.position.clone().sub( oldCamTargetPos );
		var oldCamPos		= this.camera.position.clone();
		var newCamPos 		= vector.clone().add(positionFromCenter);
		var lookAtVector	= new THREE.Vector3();
		var numDecimals = 3;
		
		var tweenValues = {
			tx: oldCamTargetPos.x,
			ty: oldCamTargetPos.y,
			tz: oldCamTargetPos.z,
			cx: oldCamPos.x,
			cy: oldCamPos.y,
			cz: oldCamPos.z
		};
		var targetValues = {
			tx: newCamTargetPos.x,
			ty: newCamTargetPos.y,
			tz: newCamTargetPos.z,
			cx: newCamPos.x,
			cy: newCamPos.y,
			cz: newCamPos.z
		};
		//scene center
		this.center = vector.clone();
		// console.log("Scene.setCenter():duration: "+duration);
		if(duration == 0){
			this.camera.position.set(parseFloat(targetValues.cx.toFixed(numDecimals)), parseFloat(targetValues.cy.toFixed(numDecimals)), parseFloat(targetValues.cz.toFixed(numDecimals)));
			this.camera.lookAt(lookAtVector.set(parseFloat(targetValues.tx.toFixed(numDecimals)),parseFloat(targetValues.ty.toFixed(numDecimals)),parseFloat(targetValues.tz.toFixed(numDecimals))));
			this.camera.target.position.setZ(-positionFromCenter.length());
			/**
			 * Fires after setCenter() completed
			 * @event center
			 */
			this.dispatchEvent({
				type : 'center',
				content : {
					center : vector.clone(),
					translation : oldCamTargetPos.clone().sub(newCamTargetPos),
					positionFromCenter : positionFromCenter
				}
			});
			_setCenterActive = false;
		}
		else {
			
				//tween camera target position and camera position
				_setCenterTween = new TWEEN.Tween(tweenValues)
											.to(targetValues,duration)
											.easing( TWEEN.Easing.Quartic.Out )
											.onUpdate(function(){
												this.camera.position.set(parseFloat(tweenValues.cx.toFixed(numDecimals)), parseFloat(tweenValues.cy.toFixed(numDecimals)), parseFloat(tweenValues.cz.toFixed(numDecimals)));
												this.camera.lookAt(lookAtVector.set(parseFloat(tweenValues.tx.toFixed(numDecimals)),parseFloat(tweenValues.ty.toFixed(numDecimals)),parseFloat(tweenValues.tz.toFixed(numDecimals))));
											}.bind(this))
											.onComplete(function(){
												this.camera.target.position.setZ(-positionFromCenter.length());
												/**
												 * Fires after setCenter() completed
												 * @event center
												 */
												this.dispatchEvent({
													type : 'center',
													content : {
														center : vector.clone(),
														translation : oldCamTargetPos.clone().sub(newCamTargetPos),
														positionFromCenter : positionFromCenter
													}
												});
												
												_setCenterActive = false;
												
												}.bind(this))
											.start();		
				
			}
		

		//this is done every frame update by OrbitZoomPan-Control
		// if (this.camera.inOrthographicMode) {
			// this.camera.toOrthographic();
		// }
		
		}	
	};
	
	/**
	 * Function to move camera to predefined relative positions from Scene.center
	 * 
	 * @method viewFrom
	 * @param {String} relativePosition allowed values are 'left','right','front','back','top','bottom'
	 */
	this.viewFrom = function(relativePosition) {
		var distanceToCenter = this.camera.position.clone().sub( this.center ).length();
		var direction = new THREE.Vector3(0,0,1); //default 'front'
		switch (relativePosition) {
			case 'left': 
				direction = new THREE.Vector3(-1,0,0);
				break;
			case 'right':
				direction = new THREE.Vector3(1,0,0);
				break;
			case 'front':
				direction = new THREE.Vector3(0,0,1);
				break;
			case 'back':
				direction = new THREE.Vector3(0,0,-1);
				break;
			case 'top':
				direction = new THREE.Vector3(0,1,0.01);
				break;	
			case 'bottom':
				direction = new THREE.Vector3(0,-1,0.01);
				break;	
			default:
				console.error('Value "' + relativePosition + '" not supported!');	
		}
		
		this.setCenter(this.center, direction.clone().multiplyScalar(distanceToCenter));
	};

	/**
	 * Adds a control to the scene
	 *
	 * @method addControl
	 */
	this.addControl = function(control) {
		// add Control to controls array
		this.controls.push(control);
		control.setScene(this);

	};

	/**
	 * Removes a control from the scene
	 *
	 * @method removeControl
	 */
	this.removeControl = function(control) {
		control.deactivate();
		var x = 0;
		while (x < this.controls.length) {
			if (control === this.controls[x]) {
				this.controls.splice(x, 1);
			}
			x++;
		}
		control.setScene(null);
	};

	/**
	 * Adds a layer to the scene
	 *
	 * @method addLayer
	 */
	this.addLayer = function(layer) {
		this.layers.push(layer);
		layer.setScene(this);
		this.root.add(layer.root);
		/**
		 * @event addlayer 
		 */
		this.dispatchEvent({ type: 'addlayer', content: layer });
	};

	/**
	 * Removes a layer from the scene
	 *
	 * @method removeLayer
	 */
	this.removeLayer = function(layer) {
		/**
		 * @event removelayer 
		 */
		this.dispatchEvent({ type: 'beforeremovelayer', content: layer });
		this.root.remove(layer.root);
		var x = 0;
		while (x < this.layers.length) {
			if (layer === this.layers[x]) {
				this.layers.splice(x, 1);
			}
			x++;
		}
		layer.setScene(null);
		/**
		 * @event removelayer 
		 */
		this.dispatchEvent({ type: 'removelayer', content: layer });
	};
	
	/**
	 * Deletes all layer objects and the layer from memory
	 * 
	 * @method disposeLayer
	 * @param {GIScene.Layer} layer
	 * 
	 *  @TODO remove all working materials first
	 *  @TODO removeEventListeners
	 */
	this.disposeLayer = function(layer) {
		this.removeLayer(layer);
		
		var objects = layer.root.getDescendants(); 
		objects.push(layer.root);
		//get all geoms, materials, textures
		var materials = [], textures = [];
		
		objects.forEach(function(object){
			//@TODO Docs fire event to clear references in other objects, eg. selectables in Control.Select
			this.dispatchEvent( { type: 'beforeDisposeObject', content: object } );
			
			if(object.geometry){
				object.geometry.dispose();
				delete object.geometry;
			}
			
			//get materials
			if (object.material) {
				if (object.material instanceof THREE.MeshFaceMaterial) {
					object.material.materials.forEach(function(material) {
						if (! GIScene.Utils.arrayContains(materials, material)) {
							materials.push(material);
						};
					});
				} else {

					if (! GIScene.Utils.arrayContains(materials, object.material)) {
						materials.push(object.material);
					};
				}
			}
			delete object.material;
			
			
			// // get textures
			// materials.forEach(function(material) {
				// var maps = ["map", "lightMap", "bumpMap", "normalMap", "specularMap", "envMap"];
				// for (var i = 0, j = maps.length; i < j; i++) {
					// if (material[maps[i]] && material[maps[i]] != null && ! GIScene.Utils.arrayContains(textures, material[maps[i]])) {
						// textures.push(material[maps[i]]);
					// };
				// };
			// }); 
			
			//dispose objects
			if(object.dispose)object.dispose();
			object = null;
		}.bind(this)
		);
		
		//get further materials from styles
		layer.styles.forEach(function(style){
			if (style.material) {
				if (style.material instanceof THREE.MeshFaceMaterial) {
					style.material.materials.forEach(function(material) {
						if (! GIScene.Utils.arrayContains(materials, material)) {
							materials.push(material);
						};
					});
				} else {

					if (! GIScene.Utils.arrayContains(materials, style.material)) {
						materials.push(style.material);
					};
				}
			}
			
		});
		
		// get textures
			materials.forEach(function(material) {
				var maps = ["map", "lightMap", "bumpMap", "normalMap", "specularMap", "envMap", "texture"]; //texture exists in RasterOverlayMaterial
				for (var i = 0, j = maps.length; i < j; i++) {
					if (material[maps[i]] && material[maps[i]] != null && ! GIScene.Utils.arrayContains(textures, material[maps[i]])) {
						textures.push(material[maps[i]]);
					};
				};
			}); 
		
		//dispose textures, materials
		textures.forEach(function (texture) {
		  texture.dispose();
		});
		textures = null;
		
		materials.forEach(function (material) {
		  material.dispose();
		});
		materials = null;
		
		objects = null;
		
		//remove THREE.EventDispatcher listeners
		for (type in layer._listeners){
			delete layer._listeners[type];
		}
		for (type in layer.loader._listeners){
			delete layer.loader._listeners[type];
		}
		
		layer = null;
	};
	
	/**
	 * Set the wireframe property for the whole scene
	 * @method setWireframe
	 * @param {Mixed} wireframeMode can be {String} 'default' | {boolean} true | {boolean} false
	 */
	
	this.setWireframe = function(wireframeMode) {
		this.root.traverse(function(object) {
			
			GIScene.Utils.WorkingMaterial.setWireframe(object,wireframeMode);
			
			// if (object.material) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
				// }
				// if(object.userData.workingMaterialFlags && (object.userData.workingMaterialFlags & GIScene.WORKINGMATERIALFLAGS.WIRE) != 0){
					// //if wire flag exist remove and check if workingmaterial is still in use, and change state or material
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.WIRE;
					// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
					// }
					// else{
						// // set original state
// 						
						// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// a[i].wireframe = isTrue;
								// }
							// );
						// }
// 						
						// // for single material objects
						// else {
							// object.material.wireframe = isTrue;
						// }
					// }
				// }
				// else{
					// //set wireflag and change wireframe state
					// //set wire flag
					// object.userData.workingMaterialFlags = ("workingMaterialFlags" in object.userData)? object.userData.workingMaterialFlags ^ GIScene.WORKINGMATERIALFLAGS.WIRE : GIScene.WORKINGMATERIALFLAGS.WIRE ;
					// //change wireframe state
// 					
					// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// a[i].wireframe = isTrue;
								// }
							// );
						// }
// 						
						// // for single material objects
						// else {
							// object.material.wireframe = isTrue;
						// }
				// }
// 				
			// }
		});
	}; 

	/**
	 * Sets texturing of on or off for the whole scene
	 * @method setTexturing
	 * @param {Mixed} texturingMode can be: {String} 'default' | {boolean} true | {boolean} false
	 */
	this.setTexturing = function(texturingMode) {
		this.root.traverse(function(object) {
			
			GIScene.Utils.WorkingMaterial.setTexturing(object, texturingMode);
			
			// if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
				// }
				// if(object.userData.workingMaterialFlags && (object.userData.workingMaterialFlags & GIScene.WORKINGMATERIALFLAGS.MAP) != 0){
					// //if texture flag exist remove and check if workingmaterial is still in use, and change state or material
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.MAP;
					// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
					// }
					// else{
						// // set original state
// 						
						// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// a[i].map = (object.userData.originalMaterial.materials[i].map && object.userData.originalMaterial.materials[i].map != null)? object.userData.originalMaterial.materials[i].map.clone() : null;
									// if(a[i].map != null)a[i].map.needsUpdate = true;
									// a[i].needsUpdate = true;
								// }
							// );
						// }
// 						
						// // for single material objects
						// else{
							// object.material.map = (object.userData.originalMaterial.map && object.userData.originalMaterial.map != null)? object.userData.originalMaterial.map.clone() : null;
							// if(object.material.map != null)object.material.map.needsUpdate = true;
							// object.material.needsUpdate = true;
						// }
// 						
					// }
				// }
				// else{
					// //set mapflag and change map state
					// //set map flag
					// object.userData.workingMaterialFlags = ("workingMaterialFlags" in object.userData)? object.userData.workingMaterialFlags ^ GIScene.WORKINGMATERIALFLAGS.MAP : GIScene.WORKINGMATERIALFLAGS.MAP ;
// 					
					// //change map state
// 					
					// //for multimaterial objects
					// if("materials" in object.material){
						// object.material.materials.forEach(
							// function (e,i,a){
								// a[i].map = null;
								// a[i].needsUpdate = true;
							// }
						// );
					// }
// 					
					// // for single material objects
					// else{
						// object.material.map = null;
						// object.material.needsUpdate =true;
					// }
				// }
			// }
		});
	};
	
	/**
	 * Sets the face culling mode for the whole scene
	 * 
	 * @method setFaceCulling
	 * @param {THREE.FrontSide || THREE.BackSide || THREE.DoubleSide || 'default'} faceCullingMode
	 */
	
	this.setFaceCulling = function(faceCullingMode) { //use THREE.FrontSide || THREE.BackSide || THREE.DoubleSide || 'default'
		this.root.traverse(function(object) {
			
			GIScene.Utils.WorkingMaterial.setFaceCulling(object,faceCullingMode);
			
			// if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
					// //set flag
					// object.userData.workingMaterialFlags = GIScene.WORKINGMATERIALFLAGS.SIDE;
				// }
// 				
				// //no wm --> create and set flag and mode
// 					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (faceCullingMode == object.userData.originalMaterial.side || faceCullingMode == 'default'){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.SIDE;	
				// }
// 				
				// //set property
// 				
				// function setFC(material, faceCullingMode){
					// material.side = faceCullingMode;
					// material.needsUpdate = true;
				// }
// 				
				// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// if(faceCullingMode == 'default'){
										// var FCValue = object.userData.originalMaterial.materials[i].side;
										// // a[i].side = object.userData.originalMaterial.materials[i].side;
										// // a[i].needsUpdate = true;
									// }
									// else{
										// var FCValue = faceCullingMode;
										// // a[i].side = faceCullingMode;
										// // a[i].needsUpdate = true;
									// }
									// setFC(a[i],FCValue);
								// }
							// );
						// }
// 						
						// // for single material objects
						// else {
							// if(faceCullingMode == 'default'){
								// var FCValue = object.userData.originalMaterial.side;
								// // object.material.side = object.userData.originalMaterial.side;
								// // object.material.needsUpdate = true;
							// }
							// else{
								// var FCValue = faceCullingMode;
								// // object.material.side = faceCullingMode;
								// // object.material.needsUpdate = true;
							// }
							// setFC(object.material, FCValue);
						// }
// 				
				// //check if wm still in use --> false remove wm and switch to orignal
				// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
				// }
// 				
			// }
		}
		);
	};
	
	/**
	 * Sets the vertex color mode for the whole scene
	 * 
	 * @method setVertexColors
	 * @param {THREE.NoColors || THREE.FaceColors || THREE.VertexColors || 'default'} vertexColorMode
	 */
	
	this.setVertexColors = function(vertexColorMode) { 
		this.root.traverse(function(object) {
			
			GIScene.Utils.WorkingMaterial.setVertexColors(object,vertexColorMode);
			
			// console.log('VC',object.userData.workingMaterialFlags);
			// if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
					// //set flag
					// // console.log("set workingmaterial vertexColors");
					// object.userData.workingMaterialFlags = 0;//GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
					// // console.log(object.userData.workingMaterialFlags);
				// }
// 				
				// //no wm --> create and set flag and mode
// 					
				// //else wm exists --> check if new mode == original
				// // /*else*/ if (vertexColorMode == object.userData.originalMaterial.vertexColors || vertexColorMode == 'default'){
// 					
// 							 
							 // //if default clear flag: object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
							 // if (vertexColorMode == 'default'){ object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
							 // //else
							 // else{
								 // //if multi
								 // if ("materials" in object.material){
								 	// //check isHomogenous
								 	// var isHomogenous = null;
								 	// for (var i=1; i < object.userData.originalMaterial.materials.length; i++){
								 		// isHomogenous = (object.userData.originalMaterial.materials[0].vertexColors == object.userData.originalMaterial.materials[i].vertexColors);
								 		// if(!isHomogenous){break;}
								 	// }
								 	// //if isHomogenous
								 	// if(isHomogenous){
								 		// //if newVC != object.userData.originalMaterial.materials[0].vertexColors : set flag |=
								 		// if(vertexColorMode != object.userData.originalMaterial.materials[0].vertexColors){ object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
								 		// //else clear flag &= ~
								 		// else{object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;}
								 	// }
								 	// //else (not homogenous)
								 	// else{	
								 		// //set flag: set flag |=
								 		// object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
								 	// }
								 // }
								 // //else (single)
								 // else{
								 	// //if newVC != object.userData.originalMaterial.vertexColors : set flag |=
								 	// if(vertexColorMode != object.userData.originalMaterial.vertexColors){ object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS; }
							 		// //else clear flag &= ~
							 		// else{object.userData.workingMaterialFlags &= ~GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;}
								 // }
							 // }
// 							 
// 							 
							 // //check multiIsHomogenous
							 // //if multiIsHomogenous == false: setMask : object.userData.workingMaterialFlags |= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;
							 // //else 
							 // //if newVCMode != 
// 							 
							 // // var newVCMode = (vertexColorMode == 'default')? object.userData.originalMaterial.vertexColors : vertexColorMode;
					// // /*else*/ if (newVCMode != object.userData.originalMaterial.vertexColors || vertexColorMode == 'default'){
					// //remove (toggle) flag
					// // console.log("remove workingmaterial vertexColors");
					// // object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.VERTEXCOLORS;	
					// // console.log(object.userData.workingMaterialFlags);
				// // }
				// //set property
// 				
				// //for multimaterial objects
				// if("materials" in object.material){
					// object.material.materials.forEach(
								// function (e,i,a){
									// if(vertexColorMode == 'default'){
										// a[i].vertexColors = object.userData.originalMaterial.materials[i].vertexColors;
										// a[i].color = object.userData.originalMaterial.materials[i].color;
										// a[i].ambient = object.userData.originalMaterial.materials[i].ambient;
										// a[i].needsUpdate = true;
									// }
									// else{
										// if (object.geometry.faces[0].vertexColors.length > 0) {
// 											
											// a[i].vertexColors = vertexColorMode;
// 											
											// if(vertexColorMode == THREE.NoColors){
												// a[i].color = new THREE.Color(0xFFFFFF);
												// a[i].ambient = new THREE.Color(0x999999);
											// }else
											// {
												// a[i].color = new THREE.Color(0xFFFFFF);
												// a[i].ambient = new THREE.Color(0xFFFFFF);
											// }
// 											
											// a[i].needsUpdate = true;
// 											
										// }
									// }
								// }
					// )
				// }
				// else {
					// //for single material models
					// if(vertexColorMode == 'default'){
						// object.material.vertexColors = object.userData.originalMaterial.vertexColors;
						// object.material.color = object.userData.originalMaterial.color;
						// object.material.ambient = object.userData.originalMaterial.ambient;
						// object.material.needsUpdate = true;
					// }
					// else{
						// if (object.geometry.faces[0].vertexColors.length > 0) {
// 							
							// object.material.vertexColors = vertexColorMode;
// 							
							// if(vertexColorMode == THREE.NoColors){
								// object.material.color = new THREE.Color(0xFFFFFF);
								// object.material.ambient = new THREE.Color(0x999999);
							// }else
							// {
								// object.material.color = new THREE.Color(0xFFFFFF);
								// object.material.ambient = new THREE.Color(0xFFFFFF);
							// }
// 							
							// object.material.needsUpdate = true;
// 							
						// }
					// }
				// }
// 				
				// //check if wm still in use --> false remove wm and switch to orignal
				// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
				// }
			// }
		}
		);
	};
	
	/**
	 * Sets the shading mode for the whole scene
	 * 
	 * @method setShading
	 * @param { THREE.FlatShading || THREE.SmoothShading || 'default' } shadingMode
	 */
	this.setShading = function(shadingMode) { //use THREE.FlatShading || THREE.SmoothShading || 'default'
		this.root.traverse(function(object) {
			
			GIScene.Utils.WorkingMaterial.setShading(object,shadingMode);
			
			// if (object.material && !((object instanceof THREE.Sprite)||(object instanceof THREE.ParticleSystem))) {
				// if(!object.userData.originalMaterial){
					// // if no working material exists create one 
					// object.userData.originalMaterial = object.material;
					// object.material = object.userData.originalMaterial.clone();
					// //set flag
					// object.userData.workingMaterialFlags = GIScene.WORKINGMATERIALFLAGS.SHADING;
				// }
// 				
				// //no wm --> create and set flag and mode
// 					
				// //else wm exists --> check if new mode == original
				// /*else*/ if (shadingMode == object.userData.originalMaterial.shading || shadingMode == 'default'){
					// //remove (toggle) flag
					// object.userData.workingMaterialFlags ^= GIScene.WORKINGMATERIALFLAGS.SHADING;	
				// }
// 				
				// //store originalVertexNormals the first time we are changing this property
				// if(!("originalVertexNormals" in object.userData) ) {
					// // console.log('store originalVertexNormals');
					// object.userData.originalVertexNormals = [];
					// for (var i=0,l=object.geometry.faces.length; i<l ;i++){
						// // object.userData.originalVertexNormals.push(object.geometry.faces[i].vertexNormals);
						// if(object.geometry.faces[i].vertexNormals.length != 0){
							// object.userData.originalVertexNormals[object.geometry.faces[i].a] = object.geometry.faces[i].vertexNormals[0].clone();
							// object.userData.originalVertexNormals[object.geometry.faces[i].b] = object.geometry.faces[i].vertexNormals[1].clone();
							// object.userData.originalVertexNormals[object.geometry.faces[i].c] = object.geometry.faces[i].vertexNormals[2].clone();	
						// }
					// }
				// }
// 				
				// //set property
				// if(shadingMode == 'default'){
					// //restore originalVertexNormals
					// for (var i=0,l=object.geometry.faces.length; i<l ;i++){
						// if(object.userData.originalVertexNormals[object.geometry.faces[i].a] == undefined){
							// object.geometry.faces[i].vertexNormals = [];
						// }
						// else{
							// object.geometry.faces[i].vertexNormals[0] = object.userData.originalVertexNormals[object.geometry.faces[i].a];
							// object.geometry.faces[i].vertexNormals[1] = object.userData.originalVertexNormals[object.geometry.faces[i].b];
							// object.geometry.faces[i].vertexNormals[2] = object.userData.originalVertexNormals[object.geometry.faces[i].c];	
						// }	
					// }
					// // console.log('deleting originalVertexNormals');
					// object.geometry.__tmpVertices = undefined; //has been set by Geometry.computeVertexNormals()
					// delete object.userData.originalVertexNormals;
// 					
						// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// a[i].shading = object.userData.originalMaterial.materials[i].shading;
									// object.geometry.normalsNeedUpdate = true;
									// a[i].needsUpdate = true;
								// }
							// )
						// }
// 						
						// //for single materials
						// else{
							// object.material.shading = object.userData.originalMaterial.shading;
							// object.geometry.normalsNeedUpdate = true;
							// object.material.needsUpdate = true;
						// }
				// }
// 				
				// // other than 'default'
				// else{
					// if( object.geometry.faces[0].vertexNormals.length == 0 ){
						// object.geometry.computeVertexNormals();
					// }
// 					
					// //for multimaterial objects
						// if("materials" in object.material){
							// object.material.materials.forEach(
								// function (e,i,a){
									// a[i].shading = shadingMode;
									// object.geometry.normalsNeedUpdate = true;
									// a[i].needsUpdate = true;
								// }
							// )
						// }
// 						
						// //for single materials
						// else{
							// object.material.shading = shadingMode;
							// object.geometry.normalsNeedUpdate = true;
							// object.material.needsUpdate = true;
						// }
				// }
// 					
				// //check if wm still in use --> false remove wm and switch to orignal
				// if(object.userData.workingMaterialFlags == 0){
						// //change back to original material
						// object.material = object.userData.originalMaterial;
						// object.userData.originalMaterial = null;
						// delete object.userData.originalMaterial;
				// }
// 				
			// }
		}
		);
	};
	
	/**
	 * get all descendants of the layers. Optionally the layers can be filtered by an array filter function.
	 * 
	 * @method getLayerDescendants
	 * @param {Function} filter An array filter function that is applied to each layer object of the scene. Should return true or false. 
	 * @example
	 * 	//get only descendants of layers that are not Helper Layers
	 * 	scene.getLayerDescendants(function(e,i,a){
	 * 		return !(e instanceof GIScene.Layer.Helper);
	 * 		}
	 *	);
	 *  
	 */
	this.getLayerDescendants = function(filter){
		var layerDescendants = [];
		var layers = this.layers;
		
		if(typeof filter == 'function'){
			layers = layers.filter(filter);
		}
		
		for(var i=0,j=layers.length; i<j; i++){
		  layers[i].root.getDescendants(layerDescendants);
		};
		
		return layerDescendants;
	};
	
	/**
	 * @method getLayerById
	 * @param {String} id
	 * @return {GIScene.Layer} result returns the layer found by id or null
	 */
	this.getLayerById = function(id) {
		var result = null;
		for (var i=0,j=this.layers.length;i<j;i++){
			if(this.layers[i].id.toString() === id.toString()) return this.layers[i];
		}
		return result;
	};
	
	/* experimental function */
	this.sortFacesFromCamera = function() {
		//sorting function to sort face arrays according to the distance from the camera to minimize opacity rendering problems
		var sortingFunction = function (elementA, elementB){
		    var distA = this.camera.position.distanceTo(elementA);
		    var distB = this.camera.position.distanceTo(elementB);
		    // return distA - distB;
		    return distB - distA; //sort from far to near
		}.bind(this);
		
		//merge all geoms
		var mergedGeom = new THREE.Geometry();
		this.root.traverse(function(object) {
			if (object.geometry && object instanceof THREE.Mesh){
				THREE.GeometryUtils.merge(mergedGeom, object.geometry);
			}
		}.bind(this));
		
		//sort triangles
		mergedGeom.faces.sort(sortingFunction);
		// this.root.traverse(function(object) {
			// if (object.geometry && object instanceof THREE.Mesh){
				// object.geometry.faces.sort(sortingFunction);
			// }
		// });
		mergedMat = new THREE.MeshLambertMaterial({
			color : 0xD2B48C, //0xFFFF66(gelb),
			ambient : 0x8B7355, //0x7B7B33,
			emissive : 0x000000,
			depthTest: false,
			depthWrite: true,
			opacity:0.5,
			transparent:true
		});
		
		mergedMesh = new THREE.Mesh(mergedGeom, mergedMat);
		
		mergedLayer = new GIScene.Layer();
		mergedLayer.root.add(mergedMesh);
		this.disposeLayer(this.layers[0]);
		this.addLayer(mergedLayer);
		
		
	};

	var debugView = false;
	this.toggleDebugView = function() {
		if(debugView){
			debugView = false;
			this.camera.target.remove(this.camera.target.children[1]);
		}
		else{
			debugView = true;
			var sphereGeom1 = new THREE.SphereGeometry(0.1,8,8);
			var camTargetDummy = new THREE.Mesh(sphereGeom1);
			this.camera.target.add(camTargetDummy);
			
			var sphereGeom2 = new THREE.SphereGeometry(0.2,10,10);
			var pivotLightDummy = new THREE.Mesh(sphereGeom2);
			cameraLightControl.pivotLight.add(pivotLightDummy);
		}
	};
	
	//start auto initialization
	this.init();
	
	//set viewport on resize
	this.onResize = function(event) {
		var w = this.containerDiv.clientWidth;
		var h = this.containerDiv.clientHeight;
		this.renderer.setSize( w, h );
		this.effectComposer.setSize( w, h );
		this.camera.setSize( w, h );
		this.camera.updateProjectionMatrix();
		
		this.spriteCamera.left = -w/2;
		this.spriteCamera.right = w/2;
		this.spriteCamera.top = h/2;
		this.spriteCamera.bottom = -h/2;
		this.spriteCamera.updateProjectionMatrix();
		
		//update logo position
		this.logoOnResize();
	}.bind(this);
	window.addEventListener('resize', this.onResize, false);
	
	this.onUnload = function(event) {
		//@TODO free memory before reload
		
		this.stopAnimation();
		
		//deactivate all controls to removeEventListeners on canvas etc
		for(var i=0,j=this.controls.length; i<j; i++){
		  if(this.controls[i].isActive)this.controls[i].deactivate();
		};
		
		//dispose all layers
		for(var i=0,j=this.layers.length; i<j; i++){
		  this.disposeLayer(this.layers[i]); 
		};
		
		this.containerDiv.innerHTML = "";
		
		for (props in this){
			delete this[props];
		}
		
		
		
	}.bind(this);
	window.addEventListener('unload', this.onUnload, false);
};

//Provide EventDispatcher Functions
GIScene.Scene.prototype = {

	constructor : GIScene.Scene,
	
	/**
	 * get Objects by a evaluation function which recursively tries to match the objects of the scene
	 * 
	 * @method getObjectsBy
	 * @param {Function} callback
	 * @return {Array} matches
	 */
	getObjectsBy : function(callback) {
		return GIScene.Utils.getObjectsBy(this.root,callback);
	},

	/**
	 * inherited from THREE.EventDispatcher
	 *
	 * @method addEventListener
	 * @param {String} eventType
	 * @param {Function} listener function, to be called when the event is dispatched
	 */
	addEventListener : THREE.EventDispatcher.prototype.addEventListener,
	
	/**
	 * inherited from THREE.EventDispatcher
	 *
	 * @method hasEventListener
	 * @param {String} eventType
	 * @param {Function} listener function, to be removed from the event
	 */
	hasEventListener : THREE.EventDispatcher.prototype.hasEventListener,
	
	/**
	 * inherited from THREE.EventDispatcher
	 *
	 * @method removeEventListener
	 * @param {String} eventType
	 * @param {Function} listener function, to be removed from the event
	 */
	removeEventListener : THREE.EventDispatcher.prototype.removeEventListener,
	
	/**
	 * inherited from THREE.EventDispatcher
	 *
	 * @method dispatchEvent
	 * @param {Object} event
	 * @example this.dispatchEvent( { type: 'beforeRender', content: anythingToBePassedToTheListeners } );
	 *
	 */
	dispatchEvent : THREE.EventDispatcher.prototype.dispatchEvent

};
