<!DOCTYPE html>
<html lang="es-ES">

<head>
    <meta charset="UTF-8">
    <title>Log Replay</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>

<body>
    <script src="js/jquery.js"></script>
    <script src="js/three.js"></script>
    <script src="js/renderDetector.js"></script>


    <script id="Three.JS Render">
		///////////
		// SCENE //
		///////////
		var scene = new THREE.Scene();

		////////////////////
		// SCENE ELEMENTS //
		////////////////////

        // Plano del suelo
            var plane = new THREE.PlaneGeometry( 20, 20 );
		    var material = new THREE.MeshBasicMaterial({ color: '#0100ff' , wireframe: true });
            var ground = new THREE.Mesh( plane, material );
		ground.rotation.x = Math.PI/2;
		scene.add( ground );

		// Cubos en el suelo (para orientación)
		    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
                // Para cambiar el material de la superficie y que reaccione con la luz:
                var material = new THREE.MeshPhysicalMaterial( {
                    map: null,
                    color: '#42f459',
                    metalness: 0.01,
                    roughness: 50,
                    opacity: 100
                } );
		    var cube = new THREE.Mesh( geometry, material );
                // Usando BasicMaterial:
		        var material = new THREE.MeshBasicMaterial({ color: '#0100ff' , wireframe: true });
            var cube2 = new THREE.Mesh( geometry, material );
		cube.position.set( 5, 0.5, 0 );
		cube2.position.set( -5, 0.5, 5);
		scene.add( cube );
		scene.add( cube2 );

		// Añadir luz a la escena
            var pointLight1 = new THREE.PointLight( 0xfffff );
            pointLight1.castShadow = false;
		pointLight1.position.set( 10, 10, 15 );
		pointLight1.lookAt( ground.position );
        scene.add( pointLight1 );


        // Y añadimos unos ejes de coordenadas para referencia
        // X (rojo), Y (verde), Z (azul)
		    var axes = new THREE.AxisHelper(100);
        scene.add( axes );


		////////////
		// CAMERA //
		////////////
		    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    // Configuración de cámara con los parámetros: ( field of view (ángulo), aspect ratio (ancho/alto), mínima distancia, máxima distancia )
		scene.add( camera );
		camera.position.set( 5, 10, 15 );
		camera.lookAt( ground.position );


		//////////////
		// RENDERER //
		//////////////
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight, false );
		// If you wish to keep the size of your app but render it at a lower resolution, you can do so by calling setSize with false as updateStyle (the third argument). For example, setSize(window.innerWidth/2, window.innerHeight/2, false) will render your app at half resolution, given that your <canvas> has 100% width and height.
		document.body.appendChild( renderer.domElement );

		// Dentro de la función render creamos un algoritmo para validar que el dato representado corresponde al último instante con log.
		var a = 0,
		    j = 0,
		    t0 = bla.AHR2(j).UStime; // tomamos el tiempo inicial del log como referencia 'cero'

		function render() {
			requestAnimationFrame( render );
			cube.rotation.y += 0.01;
			cube2.rotation.y += -0.02;

			if (a == 0){ THREE.Clock ; a = 1 } // primer frame del renderizado, comienza el reloj

			for (i = j; i < bla.AHR2.lenght ; i++) {


				if ( (bla.AHR2(i).UStime - t0) - Clock.elapsedTime > 0 ) {
					j = i;
                }

				if (j not= i) {
					;
					break
				}
            }

			camera.position.x = bla.AHR2(j).Lng;
			camera.position.y = bla.AHR2(j).Lat;
			camera.position.x = bla.AHR2(j).Alt;

			camera.lookAt( ground.position );

			/*
			if (a == 0) {
				camera.position.x += 0.05;
                if (camera.position.x > 9.95) {
                	a = 1;
                }
            } else if ( a == 1 ) {
				camera.position.x += -0.01;
				if (camera.position.x < -0.95) {
					a = 0;
				}
            }
            */

			// console.log(cube2.rotation.x);
			renderer.render( scene, camera );
        }
        // Bucle sin terminar!!

		// Inicializamos el renderer. Con un IF-ELSE y el detector.js determinamos si se correrá con WebGL o el CanvasRenderer (menos avanzado).
		if (Detector.webgl) {
			// init();
			render();
		} else {
			var warning = Detector.getWebGLErrorMessage();
			document.getElementById('container').appendChild(warning);
		}

    </script>

</body>

</html>