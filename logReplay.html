<!DOCTYPE html>
<html lang="es-ES">

<head>
    <meta charset="UTF-8">
    <title>Log Replay</title>
    <meta name="renderScreen" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #000;
            color: #000;
            margin: 0px;
            overflow: hidden;
        }
        canvas {
            width: 100%;
            height: 100% }
    </style>
</head>

<body>
    <!-- <script src="js/usedLibraries/jquery.js"></script> -->
    <script src="js/usedLibraries/three.js"></script>
    <script src="js/complements.js"></script>

    <!-- Este script abre el fichero del log y genera un vector que usaremos para representar el vuelo. -->
    <script>
		var flightLog = $.getJSON( "data/AHR2.json", function(data) {
			mydata = data;
			var timeStamp = new ArrayBuffer(mydata.AHR2.lenght),
				cuentaDesorden = 0,
				posicionesDesordenadas;

			for (j=0 ; j < mydata.AHR2.length ; j++ ){
				timeStamp[j] = mydata.AHR2[j].TimeUS;

				for ( i=0 ; i < j ; i++ ){
					if ( timeStamp[i] > timeStamp[j] ) {
						console.log("timeStamp["+i+"] = "+timeStamp[i]+"es mayor que timeStamp["+j+"] = " + timeStamp[j]);
						posicionesDesordenadas[a] = [ j, i ]; // Luego se intercambiarán la posición i y j.
						cuentaDesorden++;
					}
				}
			}
			console.log("Se ha completado el escaneo.");
			console.log("Hay un total de "+cuentaDesorden+" posiciones desordenadas.");
		})
    </script>

    <script id="Three.JS Render">

		///////////
		// SCENE //
		///////////
		var scene = new THREE.Scene();

		////////////////////
		// SCENE ELEMENTS //
		////////////////////

        // Plano del suelo
            var plane = new THREE.PlaneGeometry( 20, 20 );
		    var material = new THREE.MeshBasicMaterial({ color: '#0100ff' , wireframe: true });
            var ground = new THREE.Mesh( plane, material );
		ground.rotation.x = Math.PI/2;
		ground.position.y = 0;
		scene.add( ground );

		// Cubo en el suelo
		    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
                // Para cambiar el material de la superficie y que reaccione con la luz:
            var material = new THREE.MeshPhysicalMaterial( {
                map: null,
                color: '#42f459',
                metalness: 0.01,
                roughness: 50,
                opacity: 100
            });
		    var cube = new THREE.Mesh( geometry, material );
		// Esfera en el suelo
            var geometry = new THREE.SphereGeometry( 2, 20, 20 );
		    var loader = new THREE.TextureLoader();
		    var texture = loader.load("data/Imagen.png");
            var material = new THREE.MeshPhongMaterial({
                color: '#0100ff',
                specular: '#333333',
                shininess: 15,
                wireframe: true,
                texture: texture
            });
            var sphere = new THREE.Mesh( geometry, material );
		cube.position.set( 5, 0.5, 0 );
		sphere.position.set( -5, 0.5, 5);
		scene.add( cube );
		scene.add( sphere );

		// Añadir luz a la escena
            var pointLight1 = new THREE.PointLight( 0xfffff );
            pointLight1.castShadow = false;
		pointLight1.position.set( 10, 10, 15 );
		pointLight1.lookAt( ground.position );
        scene.add( pointLight1 );


        // Y añadimos unos ejes de coordenadas para referencia
        // X (rojo), Y (verde), Z (azul)
		    var axes = new THREE.AxisHelper(100);
        scene.add( axes );


		////////////
		// CAMERA //
		////////////
		    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    // Configuración de cámara con los parámetros: ( field of view (ángulo), aspect ratio (ancho/alto), mínima distancia, máxima distancia )
		scene.add( camera );
		camera.position.set( 5, 10, 15 );
		camera.lookAt( ground.position );


		//////////////
		// RENDERER //
		//////////////
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight, false );
		// If you wish to keep the size of your app but render it at a lower resolution, you can do so by calling setSize with false as updateStyle (the third argument). For example, setSize(window.innerWidth/2, window.innerHeight/2, false) will render your app at half resolution, given that your <canvas> has 100% width and height.
		document.body.appendChild( renderer.domElement );


		////////////////////////////////////////////////////////////////
        // Estructura de representación en función de Array de datos. //
        ////////////////////////////////////////////////////////////////
		var a = 0, j = 0, renderTimeNow, renderTimeNext,
            bla = new Array, fakeTime = new Array,
            t0 = 0; // = bla.AHR2(j).UStime; - tomamos el tiempo inicial del log como referencia 'cero'

        for (i = 0; i < 10000; i++) {
        	bla[i] = i/10; // va de 0 a 10 (unidades de distancia)
        	fakeTime[i] = i/100; // va de 0 a 100 (s)
        }

        /////////////////////////////
        // Script de renderización //
        /////////////////////////////
		function render() {
			requestAnimationFrame( render );
			cube.rotation.y += 0.01;
			sphere.rotation.y += -0.02;

            // Dentro de la función render creamos un algoritmo para validar que el dato representado corresponde al último instante con log.
			if (a == 0){
				var currTime = new Date();
				renderStartTime = currTime.getTime();
				a = 1;
			} // primer frame del renderizado, comienza el reloj
			var currTime = new Date();
			renderCurrentTime = currTime.getTime();
			reloj = (renderCurrentTime-renderStartTime)/1000 ; // (ms)

            // Hacemos un algoritmo para garantizar que el tiempo transcurrido de renderizado coincide con el del log.
            renderTimeNow = fakeTime[j]-t0;
            renderTimeNext = fakeTime[j+1]-t0;
            if ( renderTimeNow - reloj < 0 ) { // Casos A y B
                if ( renderTimeNext - reloj < 0 ) { // Caso B
                    while ( renderTimeNext - reloj < 0) {
                        j++;
                        renderTimeNext = fakeTime[j]-t0;
                    }
                }
			} else { // Caso C
                while ( renderTimeNow - reloj > 0 ){
                    j--;
                    renderTimeNow = fakeTime[j]-t0;
                }
            }
            console.log("¡Todo está bien!");
            console.log('j = ' + j);
            console.log("TimeNow = " + renderTimeNow);
            console.log("Reloj = " + reloj);
            console.log("TimeNext = " + renderTimeNext);
            console.log("Cam.Position.X = " + camera.position.x);
            console.log("Bla(j) = " + bla[j]);

            camera.position.x = bla[j];
			camera.position.y += bla[j]/1000;
            camera.lookAt( ground.position );

			renderer.render( scene, camera );
        }


		// Inicializamos el renderer. Con un IF-ELSE y el detector.js determinamos si se correrá con WebGL o el CanvasRenderer (menos avanzado).
		if (Detector.webgl) {
			// init();
			render();
		} else {
			var warning = Detector.getWebGLErrorMessage();
			document.getElementById('container').appendChild(warning);
		}

    </script>

</body>

</html>