<!DOCTYPE html>
<html lang="es-ES">

<head>
    <meta charset="UTF-8">
    <title>Log Replay</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100% }
    </style>
</head>

<body>
    <script src="js/jquery.js"></script>
    <script src="js/three.js"></script>
    <script src="js/renderDetector.js"></script>


    <script id="Three.JS Render">
		///////////
		// SCENE //
		///////////
		var scene = new THREE.Scene();

		////////////////////
		// SCENE ELEMENTS //
		////////////////////

        // Plano del suelo
            var plane = new THREE.PlaneGeometry( 20, 20 );
		    var material = new THREE.MeshBasicMaterial({ color: '#0100ff' , wireframe: true });
            var ground = new THREE.Mesh( plane, material );
		ground.rotation.x = Math.PI/2;
		scene.add( ground );

		// Cubos en el suelo (para orientación)
		    var geometry = new THREE.BoxGeometry( 1, 1, 1 );
                // Para cambiar el material de la superficie y que reaccione con la luz:
                var material = new THREE.MeshPhysicalMaterial( {
                    map: null,
                    color: '#42f459',
                    metalness: 0.01,
                    roughness: 50,
                    opacity: 100
                } );
		    var cube = new THREE.Mesh( geometry, material );
                // Usando BasicMaterial:
		        var material = new THREE.MeshBasicMaterial({ color: '#0100ff' , wireframe: true });
            var cube2 = new THREE.Mesh( geometry, material );
		cube.position.set( 5, 0.5, 0 );
		cube2.position.set( -5, 0.5, 5);
		scene.add( cube );
		scene.add( cube2 );

		// Añadir luz a la escena
            var pointLight1 = new THREE.PointLight( 0xfffff );
            pointLight1.castShadow = false;
		pointLight1.position.set( 10, 10, 15 );
		pointLight1.lookAt( ground.position );
        scene.add( pointLight1 );


        // Y añadimos unos ejes de coordenadas para referencia
        // X (rojo), Y (verde), Z (azul)
		    var axes = new THREE.AxisHelper(100);
        scene.add( axes );


		////////////
		// CAMERA //
		////////////
		    var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
		    // Configuración de cámara con los parámetros: ( field of view (ángulo), aspect ratio (ancho/alto), mínima distancia, máxima distancia )
		scene.add( camera );
		camera.position.set( 5, 10, 15 );
		camera.lookAt( ground.position );


		//////////////
		// RENDERER //
		//////////////
		var renderer = new THREE.WebGLRenderer();
		renderer.setSize( window.innerWidth, window.innerHeight, false );
		// If you wish to keep the size of your app but render it at a lower resolution, you can do so by calling setSize with false as updateStyle (the third argument). For example, setSize(window.innerWidth/2, window.innerHeight/2, false) will render your app at half resolution, given that your <canvas> has 100% width and height.
		document.body.appendChild( renderer.domElement );


		////////////////////////////////////////////////////////////////
        // Estructura de representación en función de Array de datos. //
        ////////////////////////////////////////////////////////////////
		var a = 0, j = 0, renderTimeNow, renderTimeNext,
            bla = new Array, time = new Array,
            t0 = 0; // = bla.AHR2(j).UStime; - tomamos el tiempo inicial del log como referencia 'cero'

        for (i = 0; i < 10000; i++) {
        	bla[i] = i/1000; // va de 0 a 10 (unidades de distancia)
        	time[i] = i/100; // va de 0 a 100 (s)
        }

        /////////////////////////////
        // Script de renderización //
        /////////////////////////////
		function render() {
			requestAnimationFrame( render );
			cube.rotation.y += 0.01;
			cube2.rotation.y += -0.02;

            // Dentro de la función render creamos un algoritmo para validar que el dato representado corresponde al último instante con log.
			if (a == 0){
				var currTime = new Date();
				renderStartTime = currTime.getTime();
				a = 1;
			} // primer frame del renderizado, comienza el reloj
			var currTime = new Date();
			renderCurrentTime = currTime.getTime();
			reloj = (renderCurrentTime-renderStartTime)/1000 ; // (ms)

            // Hacemos un algoritmo para garantizar que el tiempo transcurrido de renderizado coincide con el del log.
            renderTimeNow = time[j]-t0;
            renderTimeNext = time[j+1]-t0;
            if ( renderTimeNow - reloj < 0 ) { // Casos A y B
                if ( renderTimeNext - reloj < 0 ) { // Caso B
                    while ( renderTimeNext - reloj < 0) {
                        j++;
                        renderTimeNext = time[j]-t0;
                    }
                }
			} else { // Caso C
                while ( renderTimeNow - reloj > 0 ){
                    j--;
                    renderTimeNow = time[j]-t0;
                }
            }
            console.log("¡Todo está bien!");
            console.log('j = ' + j);
            console.log("TimeNow = " + renderTimeNow);
            console.log("Reloj = " + reloj);
            console.log("TimeNext = " + renderTimeNext);

            camera.position.x = bla[j];
			/*camera.position.x = bla(j).Lng;
			camera.position.y = bla(j).Lat;
			camera.position.x = bla(j).Alt;*/

			/*
			if (a == 0) {
				camera.position.x += 0.05;
                if (camera.position.x > 9.95) {
                	a = 1;
                }
            } else if ( a == 1 ) {
				camera.position.x += -0.01;
				if (camera.position.x < -0.95) {
					a = 0;
				}
            }
            camera.lookAt( ground.position );
            console.log(cube2.rotation.x);
            */

			renderer.render( scene, camera );
        }


		// Inicializamos el renderer. Con un IF-ELSE y el detector.js determinamos si se correrá con WebGL o el CanvasRenderer (menos avanzado).
		if (Detector.webgl) {
			// init();
			render();
		} else {
			var warning = Detector.getWebGLErrorMessage();
			document.getElementById('container').appendChild(warning);
		}

    </script>

</body>

</html>