/**
 * Loader for CTM encoded models generated by OpenCTM tools:
 *	http://openctm.sourceforge.net/
 *
 * Uses js-openctm library by Juan Mellado
 *	http://code.google.com/p/js-openctm/
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CTMLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

};

THREE.CTMLoader.prototype = Object.create( THREE.Loader.prototype );

// Load multiple CTM parts defined in JSON

THREE.CTMLoader.prototype.loadParts = function( url, callback, parameters ) {

	var scope = this;

	var xhr = new XMLHttpRequest();

	var basePath = parameters.basePath ? parameters.basePath : this.extractUrlBase( url );

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var jsonObject = JSON.parse( xhr.responseText );

				var materials = [], geometries = [], counter = 0;

				function callbackFinal( geometry ) {

					counter += 1;

					geometries.push( geometry );

					if ( counter === jsonObject.offsets.length ) {

						callback( geometries, materials );

					}

				}


				// init materials

				for ( var i = 0; i < jsonObject.materials.length; i ++ ) {

					materials[ i ] = THREE.Loader.prototype.createMaterial( jsonObject.materials[ i ], basePath );

				}

				// load joined CTM file

				var partUrl = basePath + jsonObject.data;
				var parametersPart = { useWorker: parameters.useWorker, useBuffers: parameters.useBuffers, offsets: jsonObject.offsets };
				scope.load( partUrl, callbackFinal, parametersPart );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.setRequestHeader( "Content-Type", "text/plain" );
	xhr.send( null );

};

// Load CTMLoader compressed models
//  - parameters
//		- url (required)
//		- callback (required)

THREE.CTMLoader.prototype.load = function( url, callback, parameters ) {

	var scope = this;

	var offsets = parameters.offsets !== undefined ? parameters.offsets : [ 0 ];
	var useBuffers = parameters.useBuffers !== undefined ? parameters.useBuffers : true;

	var xhr = new XMLHttpRequest(),
		callbackProgress = null;

	var length = 0;

	xhr.onreadystatechange = function() {

		if ( xhr.readyState === 4 ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				var binaryData = new Uint8Array(xhr.response);

				var s = Date.now();

				if ( parameters.useWorker ) {

					// var worker = new Worker( "js/loaders/ctm/CTMWorker.js" );
					var worker = new Worker( window.URL.createObjectURL(new Blob([THREE.CTMLoader.workerString], {type: "text/javascript"})));

					worker.onmessage = function( event ) {

						var files = event.data;

						for ( var i = 0; i < files.length; i ++ ) {

							var ctmFile = files[ i ];

                            				var e1 = Date.now();
                            				// console.log( "CTM data parse time [worker]: " + (e1-s) + " ms" );

							if ( useBuffers ) {

								scope.createModelBuffers( ctmFile, callback );

							} else {

								scope.createModelClassic( ctmFile, callback );

							}

                            				var e = Date.now();
                            				console.log( "model load time [worker]: " + (e-e1) + " ms, total: " + (e-s));

						}


					};

					worker.postMessage( { "data": binaryData, "offsets": offsets } );

				} else {

					for ( var i = 0; i < offsets.length; i ++ ) {

						var stream = new CTM.Stream( binaryData );
						stream.offset = offsets[ i ];

						var ctmFile = new CTM.File( stream );

						if ( useBuffers ) {

							scope.createModelBuffers( ctmFile, callback );

						} else {

							scope.createModelClassic( ctmFile, callback );

						}

					}

					//var e = Date.now();
					//console.log( "CTM data parse time [inline]: " + (e-s) + " ms" );

				}

			} else {

				console.error( "Couldn't load [" + url + "] [" + xhr.status + "]" );

			}

		} else if ( xhr.readyState === 3 ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( "Content-Length" );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === 2 ) {

			length = xhr.getResponseHeader( "Content-Length" );

		}

	};

	xhr.open( "GET", url, true );
	xhr.responseType = "arraybuffer";

	xhr.send( null );

};


THREE.CTMLoader.prototype.createModelBuffers = function ( file, callback ) {

	var Model = function ( ) {

		var scope = this;

		var reorderVertices = true;

		scope.materials = [];

		THREE.BufferGeometry.call( this );

		var s = Date.now();
		// init GL buffers

		var vertexIndexArray = file.body.indices,
		vertexPositionArray = file.body.vertices,
		vertexNormalArray = file.body.normals;

		var vertexUvArray, vertexColorArray;

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 ) {
			vertexUvArray = file.body.uvMaps[ 0 ].uv;
		}

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" ) {
			vertexColorArray = file.body.attrMaps[ 0 ].attr;
		}

		// reorder vertices
		// (needed for buffer splitting, to keep together face vertices)
		if ( reorderVertices ) {

		    	function copyVertexInfo(v, vt) {

				var sx = v * 3,
			    	    sy = v * 3 + 1,
			    	    sz = v * 3 + 2,

			    	dx = vt * 3,
			    	dy = vt * 3 + 1,
			    	dz = vt * 3 + 2;

				newVertices[ dx ] = vertexPositionArray[ sx ];
				newVertices[ dy ] = vertexPositionArray[ sy ];
				newVertices[ dz ] = vertexPositionArray[ sz ];

				if ( vertexNormalArray ) {
				    newNormals[ dx ] = vertexNormalArray[ sx ];
				    newNormals[ dy ] = vertexNormalArray[ sy ];
				    newNormals[ dz ] = vertexNormalArray[ sz ];
				}

				if ( vertexUvArray ) {
				    newUvs[ vt * 2 ] 	 = vertexUvArray[ v * 2 ];
				    newUvs[ vt * 2 + 1 ] = vertexUvArray[ v * 2 + 1 ];
				}

				if ( vertexColorArray ) {
				    newColors[ vt * 4 ] 	= vertexColorArray[ v * 4 ];
				    newColors[ vt * 4 + 1 ] = vertexColorArray[ v * 4 + 1 ];
				    newColors[ vt * 4 + 2 ] = vertexColorArray[ v * 4 + 2 ];
				    newColors[ vt * 4 + 3 ] = vertexColorArray[ v * 4 + 3 ];
				}
		    	}

		    	function handleVertex( v, iMap ) {

				if ( iMap[ v ] === undefined ) {

					iMap[ v ] = vertexCounter;
                    			reverseIndexMap[vertexCounter] = v;
					vertexCounter += 1;
				}
                		return iMap[ v ];
		    	}

			var newFaces = new Uint32Array( vertexIndexArray.length );
			var indexMap = {}, reverseIndexMap = {}, vertexCounter = 0;

            		var spawledFaceCount = 0,
                	    spawledFaceLimit = Math.ceil(vertexIndexArray.length/3000);
            		var sprawledFaces = new Uint32Array( spawledFaceLimit );  // to store sprawled triangle indices

			for ( var i = 0; i < vertexIndexArray.length; i += 3 ) {

				var a = vertexIndexArray[ i ];
				var b = vertexIndexArray[ i + 1 ];
				var c = vertexIndexArray[ i + 2 ];

				handleVertex( a, indexMap );
				handleVertex( b, indexMap );
				handleVertex( c, indexMap );

				// check for sprawled triangles and put them aside to recreate later
				if ( Math.abs( indexMap[a] - indexMap[b] ) > 65535 ||
                     		     Math.abs( indexMap[b] - indexMap[c] ) > 65535 ||
                     		     Math.abs( indexMap[c] - indexMap[a] ) > 65535 ){

			    		// expand storage when neccessary
			    		if (spawledFaceCount >= spawledFaceLimit) {
						console.warn("reached sprawled faces limit: " + spawledFaceCount);
						spawledFaceLimit *= 2;
						var tArr = new Uint32Array( spawledFaceLimit );
						tArr.set(sprawledFaces);
						sprawledFaces = tArr;
			    		}

                    			sprawledFaces[ spawledFaceCount ] = i;  // starting index in newFaces
                    			spawledFaceCount += 1;
                		}
                		else {

				    newFaces[ i ] 	  = indexMap[ a ];
				    newFaces[ i + 1 ] = indexMap[ b ];
				    newFaces[ i + 2 ] = indexMap[ c ];
                		}
			}
            		// console.log("Number of sprawled faces: " + spawledFaceCount + " current limit: " + spawledFaceLimit +
                        //	" total: " + vertexIndexArray.length/3 + " vertices: " + vertexCounter);

			// create dublicate vertices and update sprawled faces
			var indexMap2 = {},
			    noov = vertexCounter;   // # of original vertices

			for (var isf = 0; isf < spawledFaceCount; isf++ ) {
				var i = sprawledFaces[isf];

				for (var j = 0; j < 3; j++) {
				    var v = vertexIndexArray[ i + j ];
				    newFaces[ i + j] = handleVertex(v, indexMap2);   // new vertex
				}
			}

			// console.log("Created duplicated vertices: " + (vertexCounter - noov));

			// copy xyz, uv, normals and colors into new arrays
			var newVertices = new Float32Array( 3*vertexCounter );
			var newNormals, newUvs, newColors;

			if ( vertexNormalArray ) newNormals = new Float32Array( 3*vertexCounter );
			if ( vertexUvArray ) newUvs = new Float32Array( 2*vertexCounter );
			if ( vertexColorArray ) newColors = new Float32Array( 4*vertexCounter );

			for (var iv = 0; iv < vertexCounter; iv++) {
				copyVertexInfo(reverseIndexMap[iv], iv);
			}

			vertexIndexArray = newFaces;
			vertexPositionArray = newVertices;

			if ( vertexNormalArray ) vertexNormalArray = newNormals;
			if ( vertexUvArray ) vertexUvArray = newUvs;
			if ( vertexColorArray ) vertexColorArray = newColors;
		}

		// compute offsets

		scope.offsets = [];

		var indices = vertexIndexArray;

		var start = 0,
			min = vertexPositionArray.length,
			max = 0,
			minPrev = min;

		for ( var i = 0; i < indices.length; ) {

			for ( var j = 0; j < 3; ++ j ) {

				var idx = indices[ i ++ ];

				if ( idx < min ) min = idx;
				if ( idx > max ) max = idx;

			}

			if ( max - min > 65535 ) {

				i -= 3;

                		if ( minPrev > 0 ) {

				    for ( var k = start; k < i; ++ k )
					    indices[ k ] -= minPrev;
				}

				scope.offsets.push( { start: start, count: i - start, index: minPrev } );

				start = i;
				min = vertexPositionArray.length;
				max = 0;

			}

			minPrev = min;

		}

        	if ( minPrev > 0 ) {

		    for ( var k = start; k < i; ++ k )
			    indices[ k ] -= minPrev;
		}
		scope.offsets.push( { start: start, count: i - start, index: minPrev } );

        	// var e = Date.now();
		// console.log( "Vetex reordering time: " + (e-s) + " ms" );

		// recast CTM 32-bit indices as 16-bit WebGL indices
		var vertexIndexArray16 = new Uint16Array( vertexIndexArray );

		// attributes
		var attributes = scope.attributes;

		attributes[ "index" ]    = { itemSize: 1, array: vertexIndexArray16, numItems: vertexIndexArray16.length };
		attributes[ "position" ] = { itemSize: 3, array: vertexPositionArray, numItems: vertexPositionArray.length };

		if ( vertexNormalArray !== undefined ) {

			attributes[ "normal" ] = { itemSize: 3, array: vertexNormalArray, numItems: vertexNormalArray.length };

		}

		if ( vertexUvArray !== undefined ) {

			attributes[ "uv" ] = { itemSize: 2, array: vertexUvArray, numItems: vertexUvArray.length };

		}

		if ( vertexColorArray !== undefined ) {

			attributes[ "color" ]  = { itemSize: 4, array: vertexColorArray, numItems: vertexColorArray.length };

		}

	};

	Model.prototype = Object.create( THREE.BufferGeometry.prototype );

	var geometry = new Model();

	// compute vertex normals if not present in the CTM model

	if ( geometry.attributes[ "normal" ] === undefined ) {

		geometry.computeVertexNormals();

	}

	callback( geometry );

};

THREE.CTMLoader.prototype.createModelClassic = function ( file, callback ) {
console.log(file.body);
	var Model = function ( ) {

		var scope = this;

		scope.materials = [];

		THREE.Geometry.call( this );

		var normals = [],
			uvs = [],
			colors = [];

		init_vertices( file.body.vertices );

		if ( file.body.normals !== undefined )
			init_normals( file.body.normals );

		if ( file.body.uvMaps !== undefined && file.body.uvMaps.length > 0 )
			init_uvs( file.body.uvMaps[ 0 ].uv );

		if ( file.body.attrMaps !== undefined && file.body.attrMaps.length > 0 && file.body.attrMaps[ 0 ].name === "Color" )
			init_colors( file.body.attrMaps[ 0 ].attr );

		var hasNormals = normals.length > 0 ? true : false,
			hasUvs = uvs.length > 0 ? true : false,
			hasColors = colors.length > 0 ? true : false;

		init_faces( file.body.indices );

		this.computeCentroids();
		this.computeFaceNormals();
		//this.computeTangents();

		function init_vertices( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				vertex( scope, x, y, z );

			}

		};

		function init_normals( buffer ) {

			var x, y, z, i, il = buffer.length;

			for( i = 0; i < il; i += 3 ) {

				x = buffer[ i ];
				y = buffer[ i + 1 ];
				z = buffer[ i + 2 ];

				normals.push( x, y, z );

			}

		};

		function init_colors( buffer ) {

			var r, g, b, a, i, il = buffer.length;

			for( i = 0; i < il; i += 4 ) {

				r = buffer[ i ];
				g = buffer[ i + 1 ];
				b = buffer[ i + 2 ];
				a = buffer[ i + 3 ];

				var color = new THREE.Color();
				color.setRGB( r, g, b );

				colors.push( color );

			}

		};


		function init_uvs( buffer ) {

			var u, v, i, il = buffer.length;

			for( i = 0; i < il; i += 2 ) {

				u = buffer[ i ];
				v = buffer[ i + 1 ];

				uvs.push( u, v );

			}

		};

		function init_faces( buffer ) {

			var a, b, c,
				u1, v1, u2, v2, u3, v3,
				m, face,
				i, il = buffer.length;

			m = 0; // all faces defaulting to material 0

			for( i = 0; i < il; i += 3 ) {

				a = buffer[ i ];
				b = buffer[ i + 1 ];
				c = buffer[ i + 2 ];

				if ( hasNormals ){

					face = f3n( scope, normals, a, b, c, m, a, b, c );

				} else {

					face = f3( scope, a, b, c, m );

				}

				if ( hasColors ) {

					face.vertexColors[ 0 ] = colors[ a ];
					face.vertexColors[ 1 ] = colors[ b ];
					face.vertexColors[ 2 ] = colors[ c ];

				}

				if ( hasUvs ) {

					u1 = uvs[ a * 2 ];
					v1 = uvs[ a * 2 + 1 ];

					u2 = uvs[ b * 2 ];
					v2 = uvs[ b * 2 + 1 ];

					u3 = uvs[ c * 2 ];
					v3 = uvs[ c * 2 + 1 ];

					uv3( scope.faceVertexUvs[ 0 ], u1, v1, u2, v2, u3, v3 );

				}

			}

		}

	};

	function vertex ( scope, x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	};

	function f3 ( scope, a, b, c, mi ) {

		var face = new THREE.Face3( a, b, c, null, null, mi );

		scope.faces.push( face );

		return face;

	};

	function f3n ( scope, normals, a, b, c, mi, nai, nbi, nci ) {

		var nax = normals[ nai * 3     ],
			nay = normals[ nai * 3 + 1 ],
			naz = normals[ nai * 3 + 2 ],

			nbx = normals[ nbi * 3     ],
			nby = normals[ nbi * 3 + 1 ],
			nbz = normals[ nbi * 3 + 2 ],

			ncx = normals[ nci * 3     ],
			ncy = normals[ nci * 3 + 1 ],
			ncz = normals[ nci * 3 + 2 ];

		var na = new THREE.Vector3( nax, nay, naz ),
			nb = new THREE.Vector3( nbx, nby, nbz ),
			nc = new THREE.Vector3( ncx, ncy, ncz );

		var face = new THREE.Face3( a, b, c, [ na, nb, nc ], null, mi );

		scope.faces.push( face );

		return face;

	};

	function uv3 ( where, u1, v1, u2, v2, u3, v3 ) {

		var uv = [];
		uv.push( new THREE.Vector2( u1, v1 ) );
		uv.push( new THREE.Vector2( u2, v2 ) );
		uv.push( new THREE.Vector2( u3, v3 ) );
		where.push( uv );

	};

	Model.prototype = Object.create( THREE.Geometry.prototype );

	callback( new Model() );

};

THREE.CTMLoader.workerString = 
	//importScripts( "lzma.js", "ctm.js" );
	
	//lzma.js"
	
	"var LZMA = LZMA || {};\n"+
	
	"LZMA.OutWindow = function(){\n"+
	"  this._windowSize = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.create = function(windowSize){\n"+
	"  if ( (!this._buffer) || (this._windowSize !== windowSize) ){\n"+
	"    this._buffer = [];\n"+
	"  }\n"+
	"  this._windowSize = windowSize;\n"+
	"  this._pos = 0;\n"+
	"  this._streamPos = 0;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.flush = function(){\n"+
	"  var size = this._pos - this._streamPos;\n"+
	"  if (size !== 0){\n"+
	"    while(size --){\n"+
	"      this._stream.writeByte(this._buffer[this._streamPos ++]);\n"+
	"    }\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this._pos = 0;\n"+
	"    }\n"+
	"    this._streamPos = this._pos;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.releaseStream = function(){\n"+
	"  this.flush();\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.setStream = function(stream){\n"+
	"  this.releaseStream();\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.init = function(solid){\n"+
	"  if (!solid){\n"+
	"    this._streamPos = 0;\n"+
	"    this._pos = 0;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.copyBlock = function(distance, len){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  while(len --){\n"+
	"    if (pos >= this._windowSize){\n"+
	"      pos = 0;\n"+
	"    }\n"+
	"    this._buffer[this._pos ++] = this._buffer[pos ++];\n"+
	"    if (this._pos >= this._windowSize){\n"+
	"      this.flush();\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.putByte = function(b){\n"+
	"  this._buffer[this._pos ++] = b;\n"+
	"  if (this._pos >= this._windowSize){\n"+
	"    this.flush();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.OutWindow.prototype.getByte = function(distance){\n"+
	"  var pos = this._pos - distance - 1;\n"+
	"  if (pos < 0){\n"+
	"    pos += this._windowSize;\n"+
	"  }\n"+
	"  return this._buffer[pos];\n"+
	"};\n"+
	
	"LZMA.RangeDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.setStream = function(stream){\n"+
	"  this._stream = stream;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.releaseStream = function(){\n"+
	"  this._stream = null;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.init = function(){\n"+
	"  var i = 5;\n"+
	
	"  this._code = 0;\n"+
	"  this._range = -1;\n"+
	"  \n"+
	"  while(i --){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeDirectBits = function(numTotalBits){\n"+
	"  var result = 0, i = numTotalBits, t;\n"+
	
	"  while(i --){\n"+
	"    this._range >>>= 1;\n"+
	"    t = (this._code - this._range) >>> 31;\n"+
	"    this._code -= this._range & (t - 1);\n"+
	"    result = (result << 1) | (1 - t);\n"+
	
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return result;\n"+
	"};\n"+
	
	"LZMA.RangeDecoder.prototype.decodeBit = function(probs, index){\n"+
	"  var prob = probs[index],\n"+
	"      newBound = (this._range >>> 11) * prob;\n"+
	
	"  if ( (this._code ^ 0x80000000) < (newBound ^ 0x80000000) ){\n"+
	"    this._range = newBound;\n"+
	"    probs[index] += (2048 - prob) >>> 5;\n"+
	"    if ( (this._range & 0xff000000) === 0){\n"+
	"      this._code = (this._code << 8) | this._stream.readByte();\n"+
	"      this._range <<= 8;\n"+
	"    }\n"+
	"    return 0;\n"+
	"  }\n"+
	
	"  this._range -= newBound;\n"+
	"  this._code -= newBound;\n"+
	"  probs[index] -= prob >>> 5;\n"+
	"  if ( (this._range & 0xff000000) === 0){\n"+
	"    this._code = (this._code << 8) | this._stream.readByte();\n"+
	"    this._range <<= 8;\n"+
	"  }\n"+
	"  return 1;\n"+
	"};\n"+
	
	"LZMA.initBitModels = function(probs, len){\n"+
	"  while(len --){\n"+
	"    probs[len] = 1024;\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder = function(numBitLevels){\n"+
	"  this._models = [];\n"+
	"  this._numBitLevels = numBitLevels;\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._models, 1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.decode = function(rangeDecoder){\n"+
	"  var m = 1, i = this._numBitLevels;\n"+
	
	"  while(i --){\n"+
	"    m = (m << 1) | rangeDecoder.decodeBit(this._models, m);\n"+
	"  }\n"+
	"  return m - (1 << this._numBitLevels);\n"+
	"};\n"+
	
	"LZMA.BitTreeDecoder.prototype.reverseDecode = function(rangeDecoder){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < this._numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(this._models, m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.reverseDecode2 = function(models, startIndex, rangeDecoder, numBitLevels){\n"+
	"  var m = 1, symbol = 0, i = 0, bit;\n"+
	
	"  for (; i < numBitLevels; ++ i){\n"+
	"    bit = rangeDecoder.decodeBit(models, startIndex + m);\n"+
	"    m = (m << 1) | bit;\n"+
	"    symbol |= bit << i;\n"+
	"  }\n"+
	"  return symbol;\n"+
	"};\n"+
	
	"LZMA.LenDecoder = function(){\n"+
	"  this._choice = [];\n"+
	"  this._lowCoder = [];\n"+
	"  this._midCoder = [];\n"+
	"  this._highCoder = new LZMA.BitTreeDecoder(8);\n"+
	"  this._numPosStates = 0;\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.create = function(numPosStates){\n"+
	"  for (; this._numPosStates < numPosStates; ++ this._numPosStates){\n"+
	"    this._lowCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"    this._midCoder[this._numPosStates] = new LZMA.BitTreeDecoder(3);\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.init = function(){\n"+
	"  var i = this._numPosStates;\n"+
	"  LZMA.initBitModels(this._choice, 2);\n"+
	"  while(i --){\n"+
	"    this._lowCoder[i].init();\n"+
	"    this._midCoder[i].init();\n"+
	"  }\n"+
	"  this._highCoder.init();\n"+
	"};\n"+
	
	"LZMA.LenDecoder.prototype.decode = function(rangeDecoder, posState){\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 0) === 0){\n"+
	"    return this._lowCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  if (rangeDecoder.decodeBit(this._choice, 1) === 0){\n"+
	"    return 8 + this._midCoder[posState].decode(rangeDecoder);\n"+
	"  }\n"+
	"  return 16 + this._highCoder.decode(rangeDecoder);\n"+
	"};\n"+
	
	"LZMA.Decoder2 = function(){\n"+
	"  this._decoders = [];\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.init = function(){\n"+
	"  LZMA.initBitModels(this._decoders, 0x300);\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeNormal = function(rangeDecoder){\n"+
	"  var symbol = 1;\n"+
	
	"  do{\n"+
	"    symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.Decoder2.prototype.decodeWithMatchByte = function(rangeDecoder, matchByte){\n"+
	"  var symbol = 1, matchBit, bit;\n"+
	
	"  do{\n"+
	"    matchBit = (matchByte >> 7) & 1;\n"+
	"    matchByte <<= 1;\n"+
	"    bit = rangeDecoder.decodeBit(this._decoders, ( (1 + matchBit) << 8) + symbol);\n"+
	"    symbol = (symbol << 1) | bit;\n"+
	"    if (matchBit !== bit){\n"+
	"      while(symbol < 0x100){\n"+
	"        symbol = (symbol << 1) | rangeDecoder.decodeBit(this._decoders, symbol);\n"+
	"      }\n"+
	"      break;\n"+
	"    }\n"+
	"  }while(symbol < 0x100);\n"+
	
	"  return symbol & 0xff;\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder = function(){\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.create = function(numPosBits, numPrevBits){\n"+
	"  var i;\n"+
	
	"  if (this._coders\n"+
	"    && (this._numPrevBits === numPrevBits)\n"+
	"    && (this._numPosBits === numPosBits) ){\n"+
	"    return;\n"+
	"  }\n"+
	"  this._numPosBits = numPosBits;\n"+
	"  this._posMask = (1 << numPosBits) - 1;\n"+
	"  this._numPrevBits = numPrevBits;\n"+
	
	"  this._coders = [];\n"+
	
	"  i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i] = new LZMA.Decoder2();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.init = function(){\n"+
	"  var i = 1 << (this._numPrevBits + this._numPosBits);\n"+
	"  while(i --){\n"+
	"    this._coders[i].init();\n"+
	"  }\n"+
	"};\n"+
	
	"LZMA.LiteralDecoder.prototype.getDecoder = function(pos, prevByte){\n"+
	"  return this._coders[( (pos & this._posMask) << this._numPrevBits)\n"+
	"    + ( (prevByte & 0xff) >>> (8 - this._numPrevBits) )];\n"+
	"};\n"+
	
	"LZMA.Decoder = function(){\n"+
	"  this._outWindow = new LZMA.OutWindow();\n"+
	"  this._rangeDecoder = new LZMA.RangeDecoder();\n"+
	"  this._isMatchDecoders = [];\n"+
	"  this._isRepDecoders = [];\n"+
	"  this._isRepG0Decoders = [];\n"+
	"  this._isRepG1Decoders = [];\n"+
	"  this._isRepG2Decoders = [];\n"+
	"  this._isRep0LongDecoders = [];\n"+
	"  this._posSlotDecoder = [];\n"+
	"  this._posDecoders = [];\n"+
	"  this._posAlignDecoder = new LZMA.BitTreeDecoder(4);\n"+
	"  this._lenDecoder = new LZMA.LenDecoder();\n"+
	"  this._repLenDecoder = new LZMA.LenDecoder();\n"+
	"  this._literalDecoder = new LZMA.LiteralDecoder();\n"+
	"  this._dictionarySize = -1;\n"+
	"  this._dictionarySizeCheck = -1;\n"+
	
	"  this._posSlotDecoder[0] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[1] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[2] = new LZMA.BitTreeDecoder(6);\n"+
	"  this._posSlotDecoder[3] = new LZMA.BitTreeDecoder(6);\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDictionarySize = function(dictionarySize){\n"+
	"  if (dictionarySize < 0){\n"+
	"    return false;\n"+
	"  }\n"+
	"  if (this._dictionarySize !== dictionarySize){\n"+
	"    this._dictionarySize = dictionarySize;\n"+
	"    this._dictionarySizeCheck = Math.max(this._dictionarySize, 1);\n"+
	"    this._outWindow.create( Math.max(this._dictionarySizeCheck, 4096) );\n"+
	"  }\n"+
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setLcLpPb = function(lc, lp, pb){\n"+
	"  var numPosStates = 1 << pb;\n"+
	
	"  if (lc > 8 || lp > 4 || pb > 4){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  this._literalDecoder.create(lp, lc);\n"+
	
	"  this._lenDecoder.create(numPosStates);\n"+
	"  this._repLenDecoder.create(numPosStates);\n"+
	"  this._posStateMask = numPosStates - 1;\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.init = function(){\n"+
	"  var i = 4;\n"+
	
	"  this._outWindow.init(false);\n"+
	
	"  LZMA.initBitModels(this._isMatchDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRep0LongDecoders, 192);\n"+
	"  LZMA.initBitModels(this._isRepDecoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG0Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG1Decoders, 12);\n"+
	"  LZMA.initBitModels(this._isRepG2Decoders, 12);\n"+
	"  LZMA.initBitModels(this._posDecoders, 114);\n"+
	
	"  this._literalDecoder.init();\n"+
	
	"  while(i --){\n"+
	"    this._posSlotDecoder[i].init();\n"+
	"  }\n"+
	
	"  this._lenDecoder.init();\n"+
	"  this._repLenDecoder.init();\n"+
	"  this._posAlignDecoder.init();\n"+
	"  this._rangeDecoder.init();\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.decode = function(inStream, outStream, outSize){\n"+
	"  var state = 0, rep0 = 0, rep1 = 0, rep2 = 0, rep3 = 0, nowPos64 = 0, prevByte = 0,\n"+
	"      posState, decoder2, len, distance, posSlot, numDirectBits;\n"+
	
	"  this._rangeDecoder.setStream(inStream);\n"+
	"  this._outWindow.setStream(outStream);\n"+
	
	"  this.init();\n"+
	
	"  while(outSize < 0 || nowPos64 < outSize){\n"+
	"    posState = nowPos64 & this._posStateMask;\n"+
	
	"    if (this._rangeDecoder.decodeBit(this._isMatchDecoders, (state << 4) + posState) === 0){\n"+
	"      decoder2 = this._literalDecoder.getDecoder(nowPos64 ++, prevByte);\n"+
	
	"      if (state >= 7){\n"+
	"        prevByte = decoder2.decodeWithMatchByte(this._rangeDecoder, this._outWindow.getByte(rep0) );\n"+
	"      }else{\n"+
	"        prevByte = decoder2.decodeNormal(this._rangeDecoder);\n"+
	"      }\n"+
	"      this._outWindow.putByte(prevByte);\n"+
	
	"      state = state < 4? 0: state - (state < 10? 3: 6);\n"+
	
	"    }else{\n"+
	
	"      if (this._rangeDecoder.decodeBit(this._isRepDecoders, state) === 1){\n"+
	"        len = 0;\n"+
	"        if (this._rangeDecoder.decodeBit(this._isRepG0Decoders, state) === 0){\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRep0LongDecoders, (state << 4) + posState) === 0){\n"+
	"            state = state < 7? 9: 11;\n"+
	"            len = 1;\n"+
	"          }\n"+
	"        }else{\n"+
	"          if (this._rangeDecoder.decodeBit(this._isRepG1Decoders, state) === 0){\n"+
	"            distance = rep1;\n"+
	"          }else{\n"+
	"            if (this._rangeDecoder.decodeBit(this._isRepG2Decoders, state) === 0){\n"+
	"              distance = rep2;\n"+
	"            }else{\n"+
	"              distance = rep3;\n"+
	"              rep3 = rep2;\n"+
	"            }\n"+
	"            rep2 = rep1;\n"+
	"          }\n"+
	"          rep1 = rep0;\n"+
	"          rep0 = distance;\n"+
	"        }\n"+
	"        if (len === 0){\n"+
	"          len = 2 + this._repLenDecoder.decode(this._rangeDecoder, posState);\n"+
	"          state = state < 7? 8: 11;\n"+
	"        }\n"+
	"      }else{\n"+
	"        rep3 = rep2;\n"+
	"        rep2 = rep1;\n"+
	"        rep1 = rep0;\n"+
	
	"        len = 2 + this._lenDecoder.decode(this._rangeDecoder, posState);\n"+
	"        state = state < 7? 7: 10;\n"+
	
	"        posSlot = this._posSlotDecoder[len <= 5? len - 2: 3].decode(this._rangeDecoder);\n"+
	"        if (posSlot >= 4){\n"+
	
	"          numDirectBits = (posSlot >> 1) - 1;\n"+
	"          rep0 = (2 | (posSlot & 1) ) << numDirectBits;\n"+
	
	"          if (posSlot < 14){\n"+
	"            rep0 += LZMA.reverseDecode2(this._posDecoders,\n"+
	"                rep0 - posSlot - 1, this._rangeDecoder, numDirectBits);\n"+
	"          }else{\n"+
	"            rep0 += this._rangeDecoder.decodeDirectBits(numDirectBits - 4) << 4;\n"+
	"            rep0 += this._posAlignDecoder.reverseDecode(this._rangeDecoder);\n"+
	"            if (rep0 < 0){\n"+
	"              if (rep0 === -1){\n"+
	"                break;\n"+
	"              }\n"+
	"              return false;\n"+
	"            }\n"+
	"          }\n"+
	"        }else{\n"+
	"          rep0 = posSlot;\n"+
	"        }\n"+
	"      }\n"+
	
	"      if (rep0 >= nowPos64 || rep0 >= this._dictionarySizeCheck){\n"+
	"        return false;\n"+
	"      }\n"+
	
	"      this._outWindow.copyBlock(rep0, len);\n"+
	"      nowPos64 += len;\n"+
	"      prevByte = this._outWindow.getByte(0);\n"+
	"    }\n"+
	"  }\n"+
	
	"  this._outWindow.flush();\n"+
	"  this._outWindow.releaseStream();\n"+
	"  this._rangeDecoder.releaseStream();\n"+
	
	"  return true;\n"+
	"};\n"+
	
	"LZMA.Decoder.prototype.setDecoderProperties = function(properties){\n"+
	"  var value, lc, lp, pb, dictionarySize;\n"+
	
	"  if (properties.size < 5){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  value = properties.readByte();\n"+
	"  lc = value % 9;\n"+
	"  value = ~~(value / 9);\n"+
	"  lp = value % 5;\n"+
	"  pb = ~~(value / 5);\n"+
	
	"  if ( !this.setLcLpPb(lc, lp, pb) ){\n"+
	"    return false;\n"+
	"  }\n"+
	
	"  dictionarySize = properties.readByte();\n"+
	"  dictionarySize |= properties.readByte() << 8;\n"+
	"  dictionarySize |= properties.readByte() << 16;\n"+
	"  dictionarySize += properties.readByte() * 16777216;\n"+
	
	"  return this.setDictionarySize(dictionarySize);\n"+
	"};\n"+
	
	"LZMA.decompress = function(properties, inStream, outStream, outSize){\n"+
	"  var decoder = new LZMA.Decoder();\n"+
	
	"  if ( !decoder.setDecoderProperties(properties) ){\n"+
	"    throw 'Incorrect stream properties';\n"+
	"  }\n"+
	
	"  if ( !decoder.decode(inStream, outStream, outSize) ){\n"+
	"    throw 'Error in data stream';\n"+
	"  }\n"+
	
	"  return true;\n"+
	"};\n"+
	
	//ctm.js
	
	"var CTM = CTM || {};\n"+
	
	"CTM.CompressionMethod = {\n"+
	"  RAW: 0x00574152,\n"+
	"  MG1: 0x0031474d,\n"+
	"  MG2: 0x0032474d\n"+
	"};\n"+
	
	"CTM.Flags = {\n"+
	"  NORMALS: 0x00000001\n"+
	"};\n"+
	
	"CTM.File = function(stream){\n"+
	"  this.load(stream);\n"+
	"};\n"+
	
	"CTM.File.prototype.load = function(stream){\n"+
	"  this.header = new CTM.FileHeader(stream);\n"+
	
	"  this.body = new CTM.FileBody(this.header);\n"+
	"  \n"+
	"  this.getReader().read(stream, this.body);\n"+
	"};\n"+
	
	"CTM.File.prototype.getReader = function(){\n"+
	"  var reader;\n"+
	
	"  switch(this.header.compressionMethod){\n"+
	"    case CTM.CompressionMethod.RAW:\n"+
	"      reader = new CTM.ReaderRAW();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG1:\n"+
	"      reader = new CTM.ReaderMG1();\n"+
	"      break;\n"+
	"    case CTM.CompressionMethod.MG2:\n"+
	"      reader = new CTM.ReaderMG2();\n"+
	"      break;\n"+
	"  }\n"+
	
	"  return reader;\n"+
	"};\n"+
	
	"CTM.FileHeader = function(stream){\n"+
	//magic "OCTM"
	"  stream.readInt32(); \n"+
	"  this.fileFormat = stream.readInt32();\n"+
	"  this.compressionMethod = stream.readInt32();\n"+
	"  this.vertexCount = stream.readInt32();\n"+
	"  this.triangleCount = stream.readInt32();\n"+
	"  this.uvMapCount = stream.readInt32();\n"+
	"  this.attrMapCount = stream.readInt32();\n"+
	"  this.flags = stream.readInt32();\n"+
	"  this.comment = stream.readString();\n"+
	"};\n"+
	
	"CTM.FileHeader.prototype.hasNormals = function(){\n"+
	"  return this.flags & CTM.Flags.NORMALS;\n"+
	"};\n"+
	
	"CTM.FileBody = function(header){\n"+
	"  var i = header.triangleCount * 3,\n"+
	"      v = header.vertexCount * 3,\n"+
	"      n = header.hasNormals()? header.vertexCount * 3: 0,\n"+
	"      u = header.vertexCount * 2,\n"+
	"      a = header.vertexCount * 4,\n"+
	"      j = 0;\n"+
	
	"  var data = new ArrayBuffer(\n"+
	"    (i + v + n + (u * header.uvMapCount) + (a * header.attrMapCount) ) * 4);\n"+
	
	"  this.indices = new Uint32Array(data, 0, i);\n"+
	
	"  this.vertices = new Float32Array(data, i * 4, v);\n"+
	
	"  if ( header.hasNormals() ){\n"+
	"    this.normals = new Float32Array(data, (i + v) * 4, n);\n"+
	"  }\n"+
	"  \n"+
	"  if (header.uvMapCount){\n"+
	"    this.uvMaps = [];\n"+
	"    for (j = 0; j < header.uvMapCount; ++ j){\n"+
	"      this.uvMaps[j] = {uv: new Float32Array(data,\n"+
	"        (i + v + n + (j * u) ) * 4, u) };\n"+
	"    }\n"+
	"  }\n"+
	"  \n"+
	"  if (header.attrMapCount){\n"+
	"    this.attrMaps = [];\n"+
	"    for (j = 0; j < header.attrMapCount; ++ j){\n"+
	"      this.attrMaps[j] = {attr: new Float32Array(data,\n"+
	"        (i + v + n + (u * header.uvMapCount) + (j * a) ) * 4, a),start:(i + v + n + (u * header.uvMapCount) + (j * a) ) * 4 ,end:a };\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.FileMG2Header = function(stream){\n"+
	//magic "MG2H"
	"  stream.readInt32(); \n"+
	"  this.vertexPrecision = stream.readFloat32();\n"+
	"  this.normalPrecision = stream.readFloat32();\n"+
	"  this.lowerBoundx = stream.readFloat32();\n"+
	"  this.lowerBoundy = stream.readFloat32();\n"+
	"  this.lowerBoundz = stream.readFloat32();\n"+
	"  this.higherBoundx = stream.readFloat32();\n"+
	"  this.higherBoundy = stream.readFloat32();\n"+
	"  this.higherBoundz = stream.readFloat32();\n"+
	"  this.divx = stream.readInt32();\n"+
	"  this.divy = stream.readInt32();\n"+
	"  this.divz = stream.readInt32();\n"+
	"  \n"+
	"  this.sizex = (this.higherBoundx - this.lowerBoundx) / this.divx;\n"+
	"  this.sizey = (this.higherBoundy - this.lowerBoundy) / this.divy;\n"+
	"  this.sizez = (this.higherBoundz - this.lowerBoundz) / this.divz;\n"+
	"};\n"+
	
	"CTM.ReaderRAW = function(){\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readArrayInt32(indices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(vertices);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readArrayFloat32(normals);\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    stream.readArrayFloat32(uvMaps[i].uv);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderRAW.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    stream.readArrayFloat32(attrMaps[i].attr);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.read = function(stream, body){\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body.normals);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(vertices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readNormals = function(stream, normals){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	//packed size
	"  stream.readInt32(); \n"+
	
	"  var interleaved = new CTM.InterleavedStream(normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	//packed size
	"    stream.readInt32(); \n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG1.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2 = function(){\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.read = function(stream, body){\n"+
	"  this.MG2Header = new CTM.FileMG2Header(stream);\n"+
	"  \n"+
	"  this.readVertices(stream, body.vertices);\n"+
	"  this.readIndices(stream, body.indices);\n"+
	"  \n"+
	"  if (body.normals){\n"+
	"    this.readNormals(stream, body);\n"+
	"  }\n"+
	"  if (body.uvMaps){\n"+
	"    this.readUVMaps(stream, body.uvMaps);\n"+
	"  }\n"+
	"  if (body.attrMaps){\n"+
	"    this.readAttrMaps(stream, body.attrMaps);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readVertices = function(stream, vertices){\n"+
	//magic "VERT"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(vertices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  var gridIndices = this.readGridIndices(stream, vertices);\n"+
	"  \n"+
	"  CTM.restoreVertices(vertices, this.MG2Header, gridIndices, this.MG2Header.vertexPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readGridIndices = function(stream, vertices){\n"+
	//magic "GIDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	"  \n"+
	"  var gridIndices = new Uint32Array(vertices.length / 3);\n"+
	"  \n"+
	"  var interleaved = new CTM.InterleavedStream(gridIndices, 1);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"  \n"+
	"  CTM.restoreGridIndices(gridIndices, gridIndices.length);\n"+
	"  \n"+
	"  return gridIndices;\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readIndices = function(stream, indices){\n"+
	//magic "INDX"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(indices, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  CTM.restoreIndices(indices, indices.length);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readNormals = function(stream, body){\n"+
	//magic "NORM"
	"  stream.readInt32(); \n"+
	"  stream.readInt32(); //packed size\n"+
	
	"  var interleaved = new CTM.InterleavedStream(body.normals, 3);\n"+
	"  LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	
	"  var smooth = CTM.calcSmoothNormals(body.indices, body.vertices);\n"+
	
	"  CTM.restoreNormals(body.normals, smooth, this.MG2Header.normalPrecision);\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readUVMaps = function(stream, uvMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < uvMaps.length; ++ i){\n"+
	//magic "TEXC"
	"    stream.readInt32(); \n"+
	
	"    uvMaps[i].name = stream.readString();\n"+
	"    uvMaps[i].filename = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(uvMaps[i].uv, 2);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(uvMaps[i].uv, 2, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.ReaderMG2.prototype.readAttrMaps = function(stream, attrMaps){\n"+
	"  var i = 0;\n"+
	"  for (; i < attrMaps.length; ++ i){\n"+
	//magic "ATTR"
	"    stream.readInt32(); \n"+
	
	"    attrMaps[i].name = stream.readString();\n"+
	"    \n"+
	"    var precision = stream.readFloat32();\n"+
	"    \n"+
	"    stream.readInt32(); //packed size\n"+
	
	"    var interleaved = new CTM.InterleavedStream(attrMaps[i].attr, 4);\n"+
	"    LZMA.decompress(stream, stream, interleaved, interleaved.data.length);\n"+
	"    \n"+
	"    CTM.restoreMap(attrMaps[i].attr, 4, precision);\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreIndices = function(indices, len){\n"+
	"  var i = 3;\n"+
	"  if (len > 0){\n"+
	"    indices[2] += indices[0];\n"+
	"    indices[1] += indices[0];\n"+
	"  }\n"+
	"  for (; i < len; i += 3){\n"+
	"    indices[i] += indices[i - 3];\n"+
	"    \n"+
	"    if (indices[i] === indices[i - 3]){\n"+
	"      indices[i + 1] += indices[i - 2];\n"+
	"    }else{\n"+
	"      indices[i + 1] += indices[i];\n"+
	"    }\n"+
	
	"    indices[i + 2] += indices[i];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreGridIndices = function(gridIndices, len){\n"+
	"  var i = 1;\n"+
	"  for (; i < len; ++ i){\n"+
	"    gridIndices[i] += gridIndices[i - 1];\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreVertices = function(vertices, grid, gridIndices, precision){\n"+
	"  var gridIdx, delta, x, y, z,\n"+
	"      intVertices = new Uint32Array(vertices.buffer, vertices.byteOffset, vertices.length),\n"+
	"      ydiv = grid.divx, zdiv = ydiv * grid.divy,\n"+
	"      prevGridIdx = 0x7fffffff, prevDelta = 0,\n"+
	"      i = 0, j = 0, len = gridIndices.length;\n"+
	
	"  for (; i < len; j += 3){\n"+
	"    x = gridIdx = gridIndices[i ++];\n"+
	"    \n"+
	"    z = ~~(x / zdiv);\n"+
	"    x -= ~~(z * zdiv);\n"+
	"    y = ~~(x / ydiv);\n"+
	"    x -= ~~(y * ydiv);\n"+
	
	"    delta = intVertices[j];\n"+
	"    if (gridIdx === prevGridIdx){\n"+
	"      delta += prevDelta;\n"+
	"    }\n"+
	
	"    vertices[j]     = grid.lowerBoundx +\n"+
	"      x * grid.sizex + precision * delta;\n"+
	"    vertices[j + 1] = grid.lowerBoundy +\n"+
	"      y * grid.sizey + precision * intVertices[j + 1];\n"+
	"    vertices[j + 2] = grid.lowerBoundz +\n"+
	"      z * grid.sizez + precision * intVertices[j + 2];\n"+
	
	"    prevGridIdx = gridIdx;\n"+
	"    prevDelta = delta;\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreNormals = function(normals, smooth, precision){\n"+
	"  var ro, phi, theta, sinPhi,\n"+
	"      nx, ny, nz, by, bz, len,\n"+
	"      intNormals = new Uint32Array(normals.buffer, normals.byteOffset, normals.length),\n"+
	"      i = 0, k = normals.length,\n"+
	"      PI_DIV_2 = 3.141592653589793238462643 * 0.5;\n"+
	
	"  for (; i < k; i += 3){\n"+
	"    ro = intNormals[i] * precision;\n"+
	"    phi = intNormals[i + 1];\n"+
	
	"    if (phi === 0){\n"+
	"      normals[i]     = smooth[i]     * ro;\n"+
	"      normals[i + 1] = smooth[i + 1] * ro;\n"+
	"      normals[i + 2] = smooth[i + 2] * ro;\n"+
	"    }else{\n"+
	"      \n"+
	"      if (phi <= 4){\n"+
	"        theta = (intNormals[i + 2] - 2) * PI_DIV_2;\n"+
	"      }else{\n"+
	"        theta = ( (intNormals[i + 2] * 4 / phi) - 2) * PI_DIV_2;\n"+
	"      }\n"+
	"      \n"+
	"      phi *= precision * PI_DIV_2;\n"+
	"      sinPhi = ro * Math.sin(phi);\n"+
	
	"      nx = sinPhi * Math.cos(theta);\n"+
	"      ny = sinPhi * Math.sin(theta);\n"+
	"      nz = ro * Math.cos(phi);\n"+
	
	"      bz = smooth[i + 1];\n"+
	"      by = smooth[i] - smooth[i + 2];\n"+
	
	"      len = Math.sqrt(2 * bz * bz + by * by);\n"+
	"      if (len > 1e-20){\n"+
	"        by /= len;\n"+
	"        bz /= len;\n"+
	"      }\n"+
	
	"      normals[i]     = smooth[i]     * nz +\n"+
	"        (smooth[i + 1] * bz - smooth[i + 2] * by) * ny - bz * nx;\n"+
	"      normals[i + 1] = smooth[i + 1] * nz -\n"+
	"        (smooth[i + 2]      + smooth[i]   ) * bz  * ny + by * nx;\n"+
	"      normals[i + 2] = smooth[i + 2] * nz +\n"+
	"        (smooth[i]     * by + smooth[i + 1] * bz) * ny + bz * nx;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.restoreMap = function(map, count, precision){\n"+
	"  var delta, value,\n"+
	"      intMap = new Uint32Array(map.buffer, map.byteOffset, map.length),\n"+
	"      i = 0, j, len = map.length;\n"+
	
	"  for (; i < count; ++ i){\n"+
	"    delta = 0;\n"+
	
	"    for (j = i; j < len; j += count){\n"+
	"      value = intMap[j];\n"+
	"      \n"+
	"      delta += value & 1? -( (value + 1) >> 1): value >> 1;\n"+
	"      \n"+
	"      map[j] = delta * precision;\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.calcSmoothNormals = function(indices, vertices){\n"+
	"  var smooth = new Float32Array(vertices.length),\n"+
	"      indx, indy, indz, nx, ny, nz,\n"+
	"      v1x, v1y, v1z, v2x, v2y, v2z, len,\n"+
	"      i, k;\n"+
	
	"  for (i = 0, k = indices.length; i < k;){\n"+
	"    indx = indices[i ++] * 3;\n"+
	"    indy = indices[i ++] * 3;\n"+
	"    indz = indices[i ++] * 3;\n"+
	
	"    v1x = vertices[indy]     - vertices[indx];\n"+
	"    v2x = vertices[indz]     - vertices[indx];\n"+
	"    v1y = vertices[indy + 1] - vertices[indx + 1];\n"+
	"    v2y = vertices[indz + 1] - vertices[indx + 1];\n"+
	"    v1z = vertices[indy + 2] - vertices[indx + 2];\n"+
	"    v2z = vertices[indz + 2] - vertices[indx + 2];\n"+
	"    \n"+
	"    nx = v1y * v2z - v1z * v2y;\n"+
	"    ny = v1z * v2x - v1x * v2z;\n"+
	"    nz = v1x * v2y - v1y * v2x;\n"+
	"    \n"+
	"    len = Math.sqrt(nx * nx + ny * ny + nz * nz);\n"+
	"    if (len > 1e-10){\n"+
	"      nx /= len;\n"+
	"      ny /= len;\n"+
	"      nz /= len;\n"+
	"    }\n"+
	"    \n"+
	"    smooth[indx]     += nx;\n"+
	"    smooth[indx + 1] += ny;\n"+
	"    smooth[indx + 2] += nz;\n"+
	"    smooth[indy]     += nx;\n"+
	"    smooth[indy + 1] += ny;\n"+
	"    smooth[indy + 2] += nz;\n"+
	"    smooth[indz]     += nx;\n"+
	"    smooth[indz + 1] += ny;\n"+
	"    smooth[indz + 2] += nz;\n"+
	"  }\n"+
	
	"  for (i = 0, k = smooth.length; i < k; i += 3){\n"+
	"    len = Math.sqrt(smooth[i] * smooth[i] + \n"+
	"      smooth[i + 1] * smooth[i + 1] +\n"+
	"      smooth[i + 2] * smooth[i + 2]);\n"+
	
	"    if(len > 1e-10){\n"+
	"      smooth[i]     /= len;\n"+
	"      smooth[i + 1] /= len;\n"+
	"      smooth[i + 2] /= len;\n"+
	"    }\n"+
	"  }\n"+
	
	"  return smooth;\n"+
	"};\n"+
	
	"CTM.isLittleEndian = (function(){\n"+
	"  var buffer = new ArrayBuffer(2),\n"+
	"      bytes = new Uint8Array(buffer),\n"+
	"      ints = new Uint16Array(buffer);\n"+
	
	"  bytes[0] = 1;\n"+
	
	"  return ints[0] === 1;\n"+
	"}());\n"+
	
	"CTM.InterleavedStream = function(data, count){\n"+
	"  this.data = new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n"+
	"  this.offset = CTM.isLittleEndian? 3: 0;\n"+
	"  this.count = count * 4;\n"+
	"  this.len = this.data.length;\n"+
	"};\n"+
	
	"CTM.InterleavedStream.prototype.writeByte = function(value){\n"+
	"  this.data[this.offset] = value;\n"+
	"  \n"+
	"  this.offset += this.count;\n"+
	"  if (this.offset >= this.len){\n"+
	"  \n"+
	"    this.offset -= this.len - 4;\n"+
	"    if (this.offset >= this.count){\n"+
	"    \n"+
	"      this.offset -= this.count + (CTM.isLittleEndian? 1: -1);\n"+
	"    }\n"+
	"  }\n"+
	"};\n"+
	
	"CTM.Stream = function(data){\n"+
	"  this.data = data;\n"+
	"  this.offset = 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS23 = Math.pow(2, -23);\n"+
	
	"CTM.Stream.prototype.TWO_POW_MINUS126 = Math.pow(2, -126);\n"+
	
	"CTM.Stream.prototype.readByte = function(){\n"+
	"  return this.data[this.offset ++] & 0xff;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readInt32 = function(){\n"+
	"  var i = this.readByte();\n"+
	"  i |= this.readByte() << 8;\n"+
	"  i |= this.readByte() << 16;\n"+
	"  return i | (this.readByte() << 24);\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readFloat32 = function(){\n"+
	"  var m = this.readByte();\n"+
	"  m += this.readByte() << 8;\n"+
	
	"  var b1 = this.readByte();\n"+
	"  var b2 = this.readByte();\n"+
	
	"  m += (b1 & 0x7f) << 16; \n"+
	"  var e = ( (b2 & 0x7f) << 1) | ( (b1 & 0x80) >>> 7);\n"+
	"  var s = b2 & 0x80? -1: 1;\n"+
	
	"  if (e === 255){\n"+
	"    return m !== 0? NaN: s * Infinity;\n"+
	"  }\n"+
	"  if (e > 0){\n"+
	"    return s * (1 + (m * this.TWO_POW_MINUS23) ) * Math.pow(2, e - 127);\n"+
	"  }\n"+
	"  if (m !== 0){\n"+
	"    return s * m * this.TWO_POW_MINUS126;\n"+
	"  }\n"+
	"  return s * 0;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readString = function(){\n"+
	"  var len = this.readInt32();\n"+
	
	"  this.offset += len;\n"+
	
	"  return String.fromCharCode.apply(null,this.data.subarray(this.offset - len, this.offset));\n"+
	//"  return this.offset - len + ' bis ' + len;\n  //String.fromCharCode.apply(null,this.data.subarray(this.offset - len, len));\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayInt32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	"  \n"+
	"  while(i < len){\n"+
	"    array[i ++] = this.readInt32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	"CTM.Stream.prototype.readArrayFloat32 = function(array){\n"+
	"  var i = 0, len = array.length;\n"+
	
	"  while(i < len){\n"+
	"    array[i ++] = this.readFloat32();\n"+
	"  }\n"+
	
	"  return array;\n"+
	"};\n"+
	
	
	"//original CTMWorker.js\n"+
	"self.onmessage = function( event ) {\n"+
	
	"	var files = [];\n"+
	
	"	for ( var i = 0; i < event.data.offsets.length; i ++ ) {\n"+
	
	"		var stream = new CTM.Stream( event.data.data );\n"+
	"		stream.offset = event.data.offsets[ i ];\n"+
	
	"		files[ i ] = new CTM.File( stream );\n"+
	
	"	}\n"+
	
	"	self.postMessage( files );\n"+
	"	self.close();\n"+
	
	"};";
