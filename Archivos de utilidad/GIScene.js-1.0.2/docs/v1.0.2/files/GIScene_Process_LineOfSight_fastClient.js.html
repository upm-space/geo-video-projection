<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>GIScene\Process\LineOfSight_fastClient.js - GIScene 3D WebGIS API.</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="http://giscience.github.io/GIScene.js/images/GIScene.js-logo.png" title="GIScene 3D WebGIS API."></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 1.0.2</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/GIScene.html">GIScene</a></li>
                                <li><a href="../classes/GIScene.AspectMaterial.html">GIScene.AspectMaterial</a></li>
                                <li><a href="../classes/GIScene.Control.html">GIScene.Control</a></li>
                                <li><a href="../classes/GIScene.Control.AxisHelper.html">GIScene.Control.AxisHelper</a></li>
                                <li><a href="../classes/GIScene.Control.CameraLight.html">GIScene.Control.CameraLight</a></li>
                                <li><a href="../classes/GIScene.Control.Compass.html">GIScene.Control.Compass</a></li>
                                <li><a href="../classes/GIScene.Control.EdgeDetectionFreiChen.html">GIScene.Control.EdgeDetectionFreiChen</a></li>
                                <li><a href="../classes/GIScene.Control.Fly.html">GIScene.Control.Fly</a></li>
                                <li><a href="../classes/GIScene.Control.LoadIndicator.html">GIScene.Control.LoadIndicator</a></li>
                                <li><a href="../classes/GIScene.Control.Measure.html">GIScene.Control.Measure</a></li>
                                <li><a href="../classes/GIScene.Control.ObjectPosition.html">GIScene.Control.ObjectPosition</a></li>
                                <li><a href="../classes/GIScene.Control.OrbitZoomPan.html">GIScene.Control.OrbitZoomPan</a></li>
                                <li><a href="../classes/GIScene.Control.Pan.html">GIScene.Control.Pan</a></li>
                                <li><a href="../classes/GIScene.Control.PanOrbitZoomCenter.html">GIScene.Control.PanOrbitZoomCenter</a></li>
                                <li><a href="../classes/GIScene.Control.Pick.html">GIScene.Control.Pick</a></li>
                                <li><a href="../classes/GIScene.Control.Select.html">GIScene.Control.Select</a></li>
                                <li><a href="../classes/GIScene.Control.SSAO.html">GIScene.Control.SSAO</a></li>
                                <li><a href="../classes/GIScene.Control.TextPanel.html">GIScene.Control.TextPanel</a></li>
                                <li><a href="../classes/GIScene.Control.Trackball.html">GIScene.Control.Trackball</a></li>
                                <li><a href="../classes/GIScene.Control.Walk.html">GIScene.Control.Walk</a></li>
                                <li><a href="../classes/GIscene.Coordinate2.html">GIscene.Coordinate2</a></li>
                                <li><a href="../classes/GIscene.Coordinate3.html">GIscene.Coordinate3</a></li>
                                <li><a href="../classes/GIScene.DirectionMaterial.html">GIScene.DirectionMaterial</a></li>
                                <li><a href="../classes/GIScene.DistanceOpacityMaterial.html">GIScene.DistanceOpacityMaterial</a></li>
                                <li><a href="../classes/GIScene.Extent2.html">GIScene.Extent2</a></li>
                                <li><a href="../classes/GIScene.Format.html">GIScene.Format</a></li>
                                <li><a href="../classes/GIScene.GeoJSONLoader.html">GIScene.GeoJSONLoader</a></li>
                                <li><a href="../classes/GIScene.Grid.html">GIScene.Grid</a></li>
                                <li><a href="../classes/GIScene.Grid.Index.html">GIScene.Grid.Index</a></li>
                                <li><a href="../classes/GIScene.Layer.html">GIScene.Layer</a></li>
                                <li><a href="../classes/GIScene.Layer.Fixed.html">GIScene.Layer.Fixed</a></li>
                                <li><a href="../classes/GIScene.Layer.Grid.html">GIScene.Layer.Grid</a></li>
                                <li><a href="../classes/GIScene.Layer.Helper.html">GIScene.Layer.Helper</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_0.html">GIScene.Layer.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Layer.W3DS_0_4_1.html">GIScene.Layer.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Line2.html">GIScene.Line2</a></li>
                                <li><a href="../classes/GIScene.LocalFileLoader.html">GIScene.LocalFileLoader</a></li>
                                <li><a href="../classes/GIScene.ModelLoader.html">GIScene.ModelLoader</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.html">GIScene.OverrideMaterialHandler</a></li>
                                <li><a href="../classes/GIScene.OverrideMaterialHandler.WMS.html">GIScene.OverrideMaterialHandler.WMS</a></li>
                                <li><a href="../classes/GIScene.PointAlignmentMaterial.html">GIScene.PointAlignmentMaterial</a></li>
                                <li><a href="../classes/GIScene.Process.html">GIScene.Process</a></li>
                                <li><a href="../classes/GIScene.Process.Intervisibility.html">GIScene.Process.Intervisibility</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight.html">GIScene.Process.LineOfSight</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_fastClient.html">GIScene.Process.LineOfSight_fastClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_Layer.html">GIScene.Process.LineOfSight_Layer</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSight_simpleClient.html">GIScene.Process.LineOfSight_simpleClient</a></li>
                                <li><a href="../classes/GIScene.Process.LineOfSightNetwork_allToAll.html">GIScene.Process.LineOfSightNetwork_allToAll</a></li>
                                <li><a href="../classes/GIScene.RasterOverlayMaterial.html">GIScene.RasterOverlayMaterial</a></li>
                                <li><a href="../classes/GIScene.Scene.html">GIScene.Scene</a></li>
                                <li><a href="../classes/GIScene.Service.html">GIScene.Service</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_0.html">GIScene.Service.W3DS_0_4_0</a></li>
                                <li><a href="../classes/GIScene.Service.W3DS_0_4_1.html">GIScene.Service.W3DS_0_4_1</a></li>
                                <li><a href="../classes/GIScene.Style.html">GIScene.Style</a></li>
                                <li><a href="../classes/GIScene.Utils.html">GIScene.Utils</a></li>
                                <li><a href="../classes/GIScene.WMSOverlayMaterial.html">GIScene.WMSOverlayMaterial</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/GIScene.html">GIScene</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: GIScene\Process\LineOfSight_fastClient.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The Line of Sight Process calculates the visibility bewtween two points in the scene
 * 
 * @namespace GIScene
 * @class Process.LineOfSight_fastClient
 * @constructor
 * @extends GIScene.Process 
 */
GIScene.Process.LineOfSight_fastClient = function() {
	
	var config = {
		identifier		: &quot;GIScene:lineOfSight&quot;,
		title			: &quot;Line of Sight&quot;,
		abstract		: &quot;Given two loactions and possible obstacle objects this process will compute the visibility between the two loactions and provides a graphical 3D line.&quot;,
		metadata		: null,
		processVersion	: &quot;1.0&quot;,
		description		: {inputs:[
								{
									identifier: &#x27;GIScene:lineOfSight:observerPoint&#x27;,
									title:    &#x27;Observer Point&#x27;, 
									abstract: &#x27;Point of Observer, where the line of sight starts.&#x27;, 
									dataType:   &#x27;THREE.Vector3&#x27;, //??? short graphic coords
									minOccurs: 1,
									maxOccurs: 1,
								},
								{
									identifier: &#x27;GIScene:lineOfSight:observerOffset&#x27;,
									title:	&#x27;Observer Offset&#x27;,
									abstract:	&#x27;Additional height offset to observer point.&#x27;,
									dataType:	&#x27;Number&#x27;,
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{	identifier: &#x27;GIScene:lineOfSight:targetPoint&#x27;,
									title:    &#x27;Tartget Point&#x27;, 
									abstract: &#x27;Point of Target, where the line of sight ends.&#x27;, 
									dataType:   &#x27;THREE.Vector3&#x27;, //???
									minOccurs: 1,
									maxOccurs: 1
								},
								{
									identifier: &#x27;GIScene:lineOfSight:targetOffset&#x27;,
									title:	&#x27;Target Offset&#x27;,
									abstract:	&#x27;Additional height offset to target point.&#x27;,
									dataType:	&#x27;Number&#x27;,
									minOccurs: 0,
									maxOccurs: 1,
									defaultValue:0
								},
								{
									identifier: &#x27;GIScene:lineOfSight:obstacleLayers&#x27;,
									title:    &#x27;Obstacle Layers&#x27;,
									abstract: &#x27;Layers whose objects are possible obstacles to be reflected in the calculation.&#x27;,
									dataType  : &#x27;Array(GIScene.Layer)&#x27;,
									minOccurs: 1,
									maxOccurs: &#x27;unbounded&#x27; //like in xml
								}
							],
							outputs:[
								{
									identifier: &#x27;GIScene:lineOfSight:lineOfSight&#x27;,
									title:	&#x27;Line Of Sight&#x27;,
									abstract:	&#x27;The calculated Line of Sight between observer and target.&#x27;,
									dataType:	&#x27;THREE.Object3D&#x27; //???
									
								},
								{
									identifier: &#x27;GIScene:lineOfSight:isVisible&#x27;,
									title:	&#x27;Target is visible&#x27;,
									abstract:	&#x27;The result of the visibility calculation.&#x27;,
									dataType:	&#x27;boolean&#x27;
								}
							]
						}
	};
	
	//make this a Process
	GIScene.Process.apply(this, [config]);

	
	//setDefaults	
	this.config.description.inputs.forEach( function(e, i, a) {
		if (e.defaultValue != undefined) {
			//console.log(e, e.defaultValue, e.identifier);
			this.setInput(e.identifier, e.defaultValue);
		}
	}.bind(this)); 

	
	this.raycaster	= new THREE.Raycaster();

	//INPUTS
	// this.inputs.observerPoint  = null; //THREE.Vector3
	// this.inputs.targetPoint	= null; //THREE.Vector3
	// this.inputs.observerOffset = 0;
	// this.inputs.targetOffset	= 0;
	// this.inputs.obstacles		= null;
// 	
	// //OUTPUTS
	// this.ouputs.visibility = null;
	// this.ouputs.lineOfSight = null;
	
	// var inputParams = {
		// &#x27;GIScene:lineOfSight:observerPoint&#x27;	: new THREE.Vector3(0,100,0),
		// &#x27;GIScene:lineOfSight:observerOffset&#x27;: 5,
		// &#x27;GIScene:lineOfSight:targetPoint&#x27;	: new THREE.Vector3(0,-100,0),
		// &#x27;GIScene:lineOfSight:targetOffset&#x27;	: 0,
		// &#x27;GIScene:lineOfSight:obstacles&#x27;		: null//this.scene.root		
	// };
// 	
	// this.setInputs(inputParams);
	
	var lineMatVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0x00ff00)});
	var lineMatNotVisible = new THREE.LineBasicMaterial({color: new THREE.Color(0xff0000)});
	
	
	
	/**
	 * run the process with the inputs that have been set before
	 *  @method execute
	 *  @return {object} data an object with all input and output values of the process
	 */
	
	this.execute = function() {
		var observerV3 		= this.data.inputs[&#x27;GIScene:lineOfSight:observerPoint&#x27;];
		var observerOffset 	= this.data.inputs[&#x27;GIScene:lineOfSight:observerOffset&#x27;];	
		var targetV3		= this.data.inputs[&#x27;GIScene:lineOfSight:targetPoint&#x27;];
		var targetOffset	= this.data.inputs[&#x27;GIScene:lineOfSight:targetOffset&#x27;];
		var obstacleLayers	= this.data.inputs[&#x27;GIScene:lineOfSight:obstacleLayers&#x27;];	
		
		//@TODO evaluate inputs (occurences etc.)
		var scene = obstacleLayers[0].scene; // get scene from layers, better set sceen as a process param?
		
		var start 		= observerV3.clone().add(new THREE.Vector3(0,observerOffset,0)); //short graphic coords
		var end			= targetV3.clone().add(new THREE.Vector3(0,targetOffset,0));
		var direction 	= end.clone().sub(start).normalize();
		// var loading = new GIScene.Grid.TileStore(); // need it per layer
		var intersections; 
		var nearestIntersection = null;
		var numCheckedLayers = 0;
		var targetIsVisible;
		
		this.raycaster.set(start, direction); //(origin, direction) direction must be normalized
		
		this.raycaster.far = start.distanceTo(end);//targetV3.clone().sub(observerV3).length();
		
		console.log(&quot;far&quot;, this.raycaster.far);
		
		/**
		 * 
		 * @method getNearestIntersectionObject
		 * @private
		 * @param {THREE.Vector3} referencePoint
		 * @param {Object} intersectionObjectA object returned from Raycaster.intersectObjects() method
		 * @param {Object} intersectionObjectB object returned from Raycaster.intersectObjects() method
		 * @return {Object} nearestIntersectionObject
		 */
		var getNearestIntersectionObject = function(referencePoint, intersectionObjectA, intersectionObjectB) {
			//only valid if both are created by the same ray
			return ( intersectionObjectA.distance &lt; intersectionObjectB.distance )?
					 intersectionObjectA
					:
					 intersectionObjectB
					;
			
			// return ( referencePoint.distanceTo(intersectionObjectA.point) &lt; referencePoint.distanceTo(intersectionObjectB.point) )?
					  // intersectionObjectA
					 // :
					  // intersectionObjectB
					 // ;
			
		};
		
		//returns true if newIntersection is nearest
		var updateNearestIntersection = function(nearestIntersection_, newIntersection) {
			if ( !!(newIntersection) ){ //intersections found
			  	if(!nearestIntersection){ 
			  		nearestIntersection = newIntersection;
			  		return true;
			  	}
			  	else{
			  		nearestIntersection = getNearestIntersectionObject(start,nearestIntersection_,newIntersection);
			  		return (nearestIntersection === newIntersection); 
			  		};
			  	}
			  	else { //no intersections found
			  		return false;
			    }
		};
		
		// //find indexOf first element with true if no undefined is found before, otherwise if 
		// undefined before return -1
		// no undefined is found and all are false return false
		var getIndexOfFirstIntersectionTile = function(ctrl){
		  var first = false;
		  for (var i=0,j=ctrl.length;i&lt;j;i++){
		
		    if(ctrl[i] === undefined)	{first = -1;	break;}
		    if(ctrl[i] === true)		{first = true;	break;}
		  
		  }
		  return first;
		};
		
		//all from here must be wrapped in a returnResults function
		var returnResults = function(layer, loading, computeTileIndicesHandler) {
			
			if(layer &amp;&amp; loading){
				//abort all still loading in a finished layer
				var aborts = 0;
				for ( tile in loading.store ){
					aborts++;
					loading.store[tile].object.abort();
					loading.remove(new GIScene.Grid.Index().fromString(tile));
				}
				console.log(layer.name + &quot;: optimized uncached tiles by abort running requests: &quot; + aborts);
			}
			
			//restore original state
		  	if(computeTileIndicesHandler) layer.computeTileIndicesHandler = computeTileIndicesHandler;
			
			//wait until last layer has finished 
			if( !( numCheckedLayers == obstacleLayers.length ) ){
				console.log(&quot;Number of checked Layers&quot;,numCheckedLayers);	
				return;
				}
			console.log(&quot;Number of checked Layers&quot;,numCheckedLayers, &quot;Ready.&quot;);
			
			
			//return to normal work
			
			gridLayers.forEach(function(layer,i,a){ layer.startUpdate(); });
			
			//evaluate intersections
			console.log(&quot;THE END&quot;);
			
			// var targetIsVisible = true;
			var visibilityLines;
			var group = new THREE.Object3D();
			
			if( nearestIntersection ) { 
				targetIsVisible = false; 
				
				//visLine
				var geomVis = new THREE.Geometry();
				geomVis.vertices = [start,nearestIntersection.point];
				var visLine = new THREE.Line(geomVis, lineMatVisible);
				//notVisLine
				var geomNotVis = new THREE.Geometry();
				geomNotVis.vertices = [nearestIntersection.point,end];
				var notvisLine = new THREE.Line(geomNotVis, lineMatNotVisible);
				
				group.add(visLine);
				group.add(notvisLine);
				}
			else {
				targetIsVisible = true;
				var geom = new THREE.Geometry();
				geom.vertices = [start,end];
				var visLine = new THREE.Line(geom, lineMatVisible);
				
				group.add(visLine);
			}
			
			this.data.outputs[&#x27;GIScene:lineOfSight:lineOfSight&#x27;] = group;
			this.data.outputs[&#x27;GIScene:lineOfSight:isVisible&#x27;]	 = targetIsVisible;
			
			this.dispatchEvent({type:&#x27;execute&#x27;, content : this.data});
			
			return this.data;
			
		}.bind(this);
		
		var checkUncachedTile = function(index, layer, loading, controlArray, uncachedTiles, uncachedTilesIndex, computeTileIndicesHandler, nearestIntersectionTileIndex) {
			
			var gridIndex = uncachedTiles[index];
			
			//TODO immediately skip if tile is completely beyond nearestIntersection
			// if tileCenter is further away from nearestIntersection than the boundingRadius (circle)
			if(nearestIntersection){
				var tileCenter = layer.grid.getCentroidFromIndex(gridIndex); //Vec2 short graphic coords
				var boundingRadius = Math.sqrt( 2 * Math.pow(gridIndex.tileSize, 2) );
				
				if( GIScene.Utils.vector3ToVector2(nearestIntersection.point.clone().sub(start)).length &lt; tileCenter.clone().sub(GIScene.Utils.vector3ToVector2(start)) ){
					console.log(layer.name + &quot;: optimize uncached tiles. Already nearer intersection found. Skip analysisTiles index&quot; + uncachedTilesIndex[index]);
					return false; 
				}
			}
			
			
			var requestUrl = layer.config.service.getGetSceneUrl(gridIndex, layer.grid);
			
			var onSuccess = function(result) { //result is a THREE.Scene Object
				
				console.log(layer.name + &#x27;: LineOfSight:load uncached tiles:onSuccess&#x27;,index);
				
				//remove from loading
				loading.remove(gridIndex);
				
				//rotate model if z is up
				if(layer.verticalAxis.toUpperCase() == &quot;Z&quot;){
					result.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI/2 ) );
				}
				
				//setOverrideMaterial
				layer.setOverrideMaterial(result, layer.config.overrideMaterial);
				
				layer.root.add(result);
		  		result.updateMatrixWorld();
		  		
		  		//TODO may be wait for after render, so that everything is updated correctly?
		  		intersections = this.raycaster.intersectObject(layer.root, true);
		  		
		  		//TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
		  		if(intersections.length &gt; 0){
			  		var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
			  		
			  		if(isNearestTile){nearestIntersectionTileIndex = uncachedTilesIndex[index]; }
			  		console.log(&quot;nearestIntersectionTileIndex&quot;, nearestIntersectionTileIndex);
			  		
			  		controlArray[uncachedTilesIndex[index]] = true;
		  		}
		  		else{
		  			controlArray[uncachedTilesIndex[index]] = false;
		  		}
		  		layer.root.remove(result);
		  		
		  		//add tile to cache to make use of having loaded it for after analysis visualization
		  		layer.cache.add(gridIndex,result);
				
				//TODO if there is no tile before left to be checked and an intersection was found here: continue the loop to the next layer
			//TODO check if all tiles have been tested then execute returnResults()
			var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray);
			if(firstIntersectionTile !== -1){
				numCheckedLayers++;
				console.log(layer.name +&quot; : firstIntersection found! Layer checked by UNCACHED!&quot;);
				returnResults(layer, loading, computeTileIndicesHandler);
			}
			
			
			}.bind(this);
			var onError = function() {};//TODO Sceneloader will never throw it
			
			var loader = new GIScene.ModelLoader(); //need a loader for every parallel request
			loader.load(requestUrl, layer.format, onSuccess, null, onError);
			loading.add(gridIndex,loader);
		}.bind(this);
		
		//get layers to be included in analysis
		//-&gt;obstacleLayers
		
		//find out which are Grid and which not
		var gridLayers = [];
		var staticLayers = [];
		obstacleLayers.forEach(function(e,i,a){
			if (e instanceof GIScene.Layer.Grid){gridLayers.push(e);}
			else {staticLayers.push(e);}
		});
		
		console.log(&quot;obstacle layers&quot;, obstacleLayers.length);
		console.log(&quot;static layers&quot;, staticLayers.length);
		console.log(&quot;grid layers&quot;, gridLayers.length);
		
		//first check the static layers then the more complicated gridLayers
		for(var i=0,j=staticLayers.length; i&lt;j; i++){
		  
		  intersections = this.raycaster.intersectObject(staticLayers[i].root, true);
		  
		  //TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
		  
		  //check which intersection is the first (nearest to start)
		  updateNearestIntersection(nearestIntersection, intersections[0]);
		  
		  numCheckedLayers++;
		  console.log(staticLayers[i].name +&quot; : firstIntersection found! Layer checked STATIC!&quot;);
		  returnResults();
		  
		}; //static layer check end
		
		
		for(var i=0,j=gridLayers.length; i&lt;j; i++){
		  
		  //get AnalysisTiles per layer
		  var layer = gridLayers[i];
		  var grid = layer.grid;
		  var smallestTileSize = grid.tileSizes[grid.tileSizes.length-1]; //tilesizes are sorted from big to small
		  var observerV2 = new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(observerV3.clone().add(grid._sceneOffset)) );
		  var targetV2 =   new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  targetV3.clone().add(grid._sceneOffset)) );
		  
		  var optimizedTarget1 = (nearestIntersection)? new GIScene.Coordinate2().fromVector2( GIScene.Utils.vector3ToVector2(  nearestIntersection.point.clone().add(grid._sceneOffset)) ) : targetV2;
		  var woOptimizedTarget = grid.getTilesFromLineIntersection(observerV2,targetV2,smallestTileSize);
		  var analysisTiles = grid.getTilesFromLineIntersection(observerV2,optimizedTarget1,smallestTileSize);
		  var loading = new GIScene.Grid.TileStore();
		  
		  console.log(&quot;Start Analyzing &quot; + layer.name);
		  console.log(layer.name + &quot;: &quot;+ optimizedTarget1.toArray());
		  console.log(layer.name + &quot;: optimized number of tiles: &quot; + analysisTiles.length +&quot;/&quot;+ woOptimizedTarget.length + &quot; &quot; + ((analysisTiles.length *100) / woOptimizedTarget.length) + &quot;%&quot;);
		  
		  var controlArray = new Array(analysisTiles.length);
		  //check each analysisTile for obstructions asnchronuously
		  //tiles have to be loaded and added to the scene, to be sure that all matrices are applied correctly when tested with Raycaster
		  
		  //store layer function to be restores after the analysis
		  var computeTileIndicesHandler = layer.computeTileIndicesHandler;
		  
		  // remove all tiles
		  //better in future: remove tiles in two steps to be sure that the analysis tile get into the cache at last
		  layer.stopUpdate();
		  layer.computeTileIndicesHandler = function() {return [];};
		  layer.update(); //this removes all tiles from the scene
		  
		  //first check available tiles from cache
		  var cachedTiles	=[]; //Objects
		  var cachedTilesIndex = [];
		  var uncachedTiles	=[]; //TileIndex
		  var uncachedTilesIndex =[];
		  
		  var nearestIntersectionTileIndex;//analysisTiles Index //= (nearestIntersection)? layer.grid.getIndexFromPoint2d(GIScene.Utils.vector3ToVector2(nearestIntersection.point)) : undefined;
		  
		  var nearestIntersectionGridIndex = (nearestIntersection)? layer.grid.getIndexFromPoint2d(GIScene.Utils.vector3ToVector2(nearestIntersection.point),smallestTileSize) : undefined;
		  
		  
		  
		  
		  analysisTiles.forEach(function(e,i,a){
								  		if(nearestIntersectionGridIndex &amp;&amp; e.equals(nearestIntersectionGridIndex)){nearestIntersectionTileIndex = i+1}
								  		var tileFromCache = layer.cache.getTile(e);
								  		if(tileFromCache){
								  			cachedTiles.push(tileFromCache);
								  			cachedTilesIndex.push(i);
								  		} 
								  		else {
								  			uncachedTiles.push(e);
								  			uncachedTilesIndex.push(i);
								  		}
					}.bind(this)
		  );
		  console.log(&quot;nearestIntersectionTileIndex&quot;, nearestIntersectionTileIndex);
		  console.log(layer.name + &quot;: cached / uncached tiles&quot;, cachedTiles.length, uncachedTiles.length);
		  
		  console.log(layer.name + &quot;: Analyzing &quot;+ cachedTiles.length +&quot; CACHED tiles&quot;);
		  
		  var layerChecked=false;
		  for(var iiii=0,jjjj=cachedTiles.length; iiii&lt;jjjj; iiii++){
		  	
		  	var tileFromCache = cachedTiles[iiii];
		  	
		  	layer.root.add(tileFromCache);
		  		
	  		//TODO may be wait for after render, so that everything is updated correctly?
	  		intersections = this.raycaster.intersectObject(layer.root, true);
	  		
	  		//TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
	  		if(intersections.length &gt; 0){
	  			var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
	  		
	  			if(isNearestTile){nearestIntersectionTileIndex = cachedTilesIndex[iiii]; }
	  			console.log(&quot;nearestIntersectionTileIndex&quot;, nearestIntersectionTileIndex);
	  			controlArray[cachedTilesIndex[iiii]] = true;
	  		}
	  		else{
	  			controlArray[cachedTilesIndex[iiii]] = false;
	  		}
	  		
	  		layer.root.remove(tileFromCache);
	  		
	  		var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray); // true, false or -1
	  		console.log(layer.name + &#x27; :firstIntersectionTile&#x27;, firstIntersectionTile, controlArray.length);
	  		if(firstIntersectionTile !== -1){
	  			numCheckedLayers++;
	  			console.log(layer.name +&quot; : firstIntersection found! Layer checked by CACHED!&quot;);
				returnResults(layer, loading, computeTileIndicesHandler);
				
				layerChecked = true;
				break; //no more cached tile testing
			}
		  };
		  if(layerChecked){continue;} //when checked by cached no testing of uncached --&gt; test next layer
		  // cachedTiles.forEach(
		  	// function(tileFromCache,i,a){
		  		// layer.root.add(tileFromCache);
// 		  		
		  		// //TODO may be wait for after render, so that everything is updated correctly?
		  		// intersections = this.raycaster.intersectObject(layer.root, true);
// 		  		
		  		// //TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
		  		// if(intersections.length &gt; 0){
		  			// var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
// 		  		
		  			// if(isNearestTile){nearestIntersectionTileIndex = cachedTilesIndex[i]; }
// 		  			
		  			// controlArray[cachedTilesIndex[i]] = true;
		  		// }
		  		// else{
		  			// controlArray[cachedTilesIndex[i]] = false;
		  		// }
// 		  		
// 		  		
		  		// layer.root.remove(tileFromCache);
// 		  		
		  		// var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray); // true, false or -1
		  		// if(firstIntersectionTile !== -1){
		  			// numCheckedLayers++;
		  			// console.log(layer.name +&quot; : firstIntersection found! Layer checked by CACHED!&quot;);
					// returnResults(layer, loading);
// 					
				// }
		  	// }.bind(this)
		  // );
		  
		  
		  
		  //reduce uncachedTiles according to former found intersections
		  //2nd reduction if uncached are left but found intersection in cached
		  if(nearestIntersection){
		  	var deleteFromIndex = null;
		  	for(var iii=uncachedTilesIndex.length-1, jjj=0; iii&gt;=jjj; iii--){
				if(uncachedTilesIndex[iii] &gt;= nearestIntersectionTileIndex){
					deleteFromIndex = iii;
				}
			  };
			  
			 if(deleteFromIndex != null){
			 	console.log(&#x27;controlArray:before&#x27;, controlArray);
			 	var uncached_orig_length = uncachedTiles.length;
			 	uncachedTiles.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	
			 	for(var v = deleteFromIndex, vi = uncached_orig_length/*uncachedTiles.length*/; v &lt; vi; v++){
			 		controlArray[uncachedTilesIndex[v]] = false;
			 	}
			 	
			 	uncachedTilesIndex.splice(deleteFromIndex,Number.MAX_VALUE); //???
			 	
			 	//TODO update uncachedTileIndex and CONTROLARRAY 
			 	console.log(layer.name + &quot;: optimized number of uncached tiles: &quot; + uncached_orig_length +&quot;--&gt;&quot;+ uncachedTiles.length);
			 	console.log(&#x27;controlArray:after&#x27;, controlArray);
			 }
		  }
		  
		  //load unavailable tiles and check async
		  //check remaining uncached tiles
		  console.log(layer.name + &quot;: Analyzing &quot;+ uncachedTiles.length +&quot; UNCACHED tiles&quot;);
		  for(var ii=0,jj=uncachedTiles.length; ii&lt;jj; ii++){
					
			if (checkUncachedTile(ii, layer, loading, controlArray, uncachedTiles, uncachedTilesIndex,computeTileIndicesHandler, nearestIntersectionTileIndex) === false) { continue; }
			
			// var gridIndex = uncachedTiles[ii]; 
// 			
			// var requestUrl = layer.config.service.getGetSceneUrl(gridIndex, layer.grid);
// 			
			// var onSuccess = function(result) { //result is a THREE.Scene Object
// 				
				// console.log(&#x27;LineOfSight:load uncached tiles:onSuccess&#x27;,ii);
// 				
				// layer.root.add(result);
// 		  		
		  		// //TODO may be wait for after render, so that everything is updated correctly?
		  		// intersections = this.raycaster.intersectObject(layer.root, true);
// 		  		
		  		// //TODO if no obstruction point needed then if intersections.length &gt; 0 indicates visibility false and the whole process can be stopped here
		  		// if(intersections.length &gt; 0){
			  		// var isNearestTile = updateNearestIntersection(nearestIntersection, intersections[0]);
// 			  		
			  		// if(isNearestTile){nearestIntersectionTileIndex = uncachedTilesIndex[ii]; }
// 			  		
			  		// controlArray[uncachedTilesIndex[ii]] = true;
		  		// }
		  		// else{
		  			// controlArray[uncachedTilesIndex[ii]] = false;
		  		// }
		  		// layer.root.remove(result);
// 		  		
		  		// //add tile to cache to make use of having loaded it for after analysis visualization
		  		// layer.cache.add(gridIndex,result);
// 				
				// //TODO if there is no tile before left to be checked and an intersection was found here: continue the loop to the next layer
			// //TODO check if all tiles have been tested then execute returnResults()
			// var firstIntersectionTile = getIndexOfFirstIntersectionTile(controlArray);
			// if(firstIntersectionTile !== -1){
				// return returnResults();
			// }
// 			
// 			
			// }.bind(this);
			// var onError = function() {};//TODO Sceneloader will never throw it
// 			
			// var loader = new GIScene.ModelLoader(); //need a loader for every parallel request
			// loader.load(requestUrl, layer.format, onSuccess, null, onError);
			
		  };
		  
		  // //restore original state
		  // layer.computeTileIndicesHandler = computeTileIndicesHandler;
		  // computeTileIndicesHandler = null;
		  // layer.startUpdate(); start upating all gridLayers later when analysis is finished 
		  
		}; // gridLayer check end
		
		

		
		
		
	};
		
	this.execute_ = function() {
		
		var observerV3 		= this.data.inputs[&#x27;GIScene:lineOfSight:observerPoint&#x27;];
		var observerOffset 	= this.data.inputs[&#x27;GIScene:lineOfSight:observerOffset&#x27;];	
		var targetV3		= this.data.inputs[&#x27;GIScene:lineOfSight:targetPoint&#x27;];
		var targetOffset	= this.data.inputs[&#x27;GIScene:lineOfSight:targetOffset&#x27;];
		var obstacles		= this.data.inputs[&#x27;GIScene:lineOfSight:obstacles&#x27;];	
		
		var start 		= observerV3.clone().add(new THREE.Vector3(0,observerOffset,0));
		var end			= targetV3.clone().add(new THREE.Vector3(0,targetOffset,0));
		var direction 	= end.clone().sub(start).normalize();
		
		this.raycaster.set(start, direction); //(origin, direction) direction must be normalized
		
		this.raycaster.far = start.distanceTo(end);//targetV3.clone().sub(observerV3).length();
		
		console.log(&quot;far&quot;, this.raycaster.far);
		
		var intersections = this.raycaster.intersectObjects(obstacles, true);
		
		console.log(&quot;intersections&quot;,intersections);
		
		var targetIsVisible = true;
		var visibilityLines;
		var group = new THREE.Object3D();
		
		if( intersections.length &gt; 0 ) { 
			targetIsVisible = false; 
			
			//visLine
			var geomVis = new THREE.Geometry();
			geomVis.vertices = [start,intersections[0].point];
			var visLine = new THREE.Line(geomVis, lineMatVisible);
			//notVisLine
			var geomNotVis = new THREE.Geometry();
			geomNotVis.vertices = [intersections[0].point,end];
			var notvisLine = new THREE.Line(geomNotVis, lineMatNotVisible);
			
			group.add(visLine);
			group.add(notvisLine);
			}
		else {
			var geom = new THREE.Geometry();
			geom.vertices = [start,end];
			var visLine = new THREE.Line(geom, lineMatVisible);
			
			group.add(visLine);
		}
		
		this.data.outputs[&#x27;GIScene:lineOfSight:lineOfSight&#x27;] = group;
		this.data.outputs[&#x27;GIScene:lineOfSight:isVisible&#x27;]	 = targetIsVisible;
		
		console.log(this._listeners);
		this.dispatchEvent({type:&#x27;execute&#x27;, content : this.data});
		
		return this.data;
		
	};
};

//Inherit from GIScene.Layer
GIScene.Process.LineOfSight_fastClient.prototype = Object.create( GIScene.Process.prototype );
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
