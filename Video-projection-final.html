<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Video Projection</title>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.6.3/leaflet.css" />
    <script src="js/Three.js"></script>
    <script src="js/Projector.js"></script>
    <script src="js/CanvasRenderer.js"></script>
    <script src="js/numeric-1.2.6.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.6.3/leaflet.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
    <video id="myVideo" autoplay loop style="display:none" src="https://stemkoski.github.io/Three.js/videos/sintel.ogv" type='video/ogg; codecs="theora, vorbis"'></video>
</head>
<body onload = init()>
<div id="both" style="position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px">
    <div id="map" style="position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px"></div>
    <canvas id="myCanvas"></canvas></div>
</div>

<script>
    var map;
    var scene, camera, renderer, container;
    var video, image, imageContext;
    var group, data;
    var coordenadas, p0, p1, p2, p3, corners;
    var j=-1, Lat0, Lng0, LatLng0;
    var a=0, t0, renderStartTime, renderCurrentTime, renderTimeNow, renderTimeNext, reloj;

    video = document.getElementById( 'myVideo' );
    image = document.getElementById( 'myCanvas' );
    video.addEventListener( "loadedmetadata", function (e) {
        image.width = this.videoWidth;
        image.height = this.videoHeight;
    }, false );
    imageContext = image.getContext( '2d' );

    scene = new THREE.Scene();
    container = document.getElementById( 'both' );
    renderer = new THREE.CanvasRenderer({alpha: true});

    function init() {
        //$.get("data/myGeoJsonCut.json", function (data) {
        $.get("data/citi-field.geo5.json", function (data) {
            animate(data.features);
        });
    }

    function adj(m) { // Compute the adjugate of m
        return [
            m[4]*m[8]-m[5]*m[7], m[2]*m[7]-m[1]*m[8], m[1]*m[5]-m[2]*m[4],
            m[5]*m[6]-m[3]*m[8], m[0]*m[8]-m[2]*m[6], m[2]*m[3]-m[0]*m[5],
            m[3]*m[7]-m[4]*m[6], m[1]*m[6]-m[0]*m[7], m[0]*m[4]-m[1]*m[3]
        ];
    }

    function multmm(a, b) { // multiply two matrices
        var c = Array(9);
        for (var i = 0; i != 3; ++i) {
            for (var j = 0; j != 3; ++j) {
                var cij = 0;
                for (var k = 0; k != 3; ++k) {
                    cij += a[3*i + k]*b[3*k + j];
                }
                c[3*i + j] = cij;
            }
        }
        return c;
    }

    function multmv(m, v) { // multiply matrix and vector
        return [
            m[0]*v[0] + m[1]*v[1] + m[2]*v[2],
            m[3]*v[0] + m[4]*v[1] + m[5]*v[2],
            m[6]*v[0] + m[7]*v[1] + m[8]*v[2]
        ];
    }

    function basisToPoints(x1, y1, x2, y2, x3, y3, x4, y4) {
        var m = [
            x1, x2, x3,
            y1, y2, y3,
            1,  1,  1
        ];
        var v = multmv(adj(m), [x4, y4, 1]);
        return multmm(m, [
            v[0], 0, 0,
            0, v[1], 0,
            0, 0, v[2]
        ]);
    }

    function general2DProjection(x1s, y1s, x1d, y1d, x2s, y2s, x2d, y2d, x3s, y3s, x3d, y3d, x4s, y4s, x4d, y4d) {
        var s = basisToPoints(x1s, y1s, x2s, y2s, x3s, y3s, x4s, y4s);
        var d = basisToPoints(x1d, y1d, x2d, y2d, x3d, y3d, x4d, y4d);
        return multmm(d, adj(s));
    }

    function transform2d(elt, x1, y1, x2, y2, x3, y3, x4, y4) {
        var w = elt.offsetWidth, h = elt.offsetHeight;
        var t = general2DProjection
        (0, 0, x1, y1, w, 0, x2, y2, 0, h, x3, y3, w, h, x4, y4);
        for(i = 0; i != 9; ++i) t[i] = t[i]/t[8];
        t = [t[0], t[3], 0, t[6],
            t[1], t[4], 0, t[7],
            0   , 0   , 1, 0   ,
            t[2], t[5], 0, t[8]];
        t = "matrix3d(" + t.join(", ") + ")";
        elt.style["-webkit-transform"] = t;
        elt.style["-moz-transform"] = t;
        elt.style["-o-transform"] = t;
        elt.style.transform = t;
    }

    function update() {
        transform2d(image, corners[0], corners[1], corners[2], corners[3],
            corners[4], corners[5], corners[6], corners[7]);
    }

    function animate(data){
        var coordenadas0 = data[0].geometry.coordinates[0];
        Lng0 = (coordenadas0[0][0]+coordenadas0[1][0]+coordenadas0[2][0]+coordenadas0[3][0])/4;
        Lat0 = (coordenadas0[0][1]+coordenadas0[1][1]+coordenadas0[2][1]+coordenadas0[3][1])/4;
        map = new L.Map('map');
        var osmUrl='http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
        var osmAttrib='Map data © <a href="http://openstreetmap.org">OpenStreetMap</a> contributors';
        var osm = new L.TileLayer(osmUrl, {minZoom: 1, maxZoom: 27, attribution: osmAttrib});
        map.setView(new L.LatLng(Lat0, Lng0),8);
        map.addLayer(osm);

        L.SG3DLayer = L.Class.extend({
            map: null,
            container: null,
            data: null,
            group: null,
            vFOV: 90,
            cameraHeight: 1000,
            threeOrigin: null,
            // At what coordinates was the sceneOrigin when we first layed everything out
            initialSceneOriginLatLng: new L.LatLng(Lat0, Lng0),
            heightScale: null,

            geoJSON: function (x) {
                data = x;
                this._resetScene();
            },

            initialize: function (options) {
                options = L.Util.setOptions(this, options);
                this.data = [];
            },

            _initScene: function () {
                this.container = container;
                this.camera = new THREE.PerspectiveCamera(this.vFOV, this.map._size.x / this.map._size.y, 1, 1000);
                this.camera.position.x = 0;
                this.camera.position.y = 0;
                this.camera.position.z = this.cameraHeight;
                this.scene = scene;
                this.renderer = renderer;
                this.renderer.setPixelRatio( window.devicePixelRatio );
                this.renderer.setSize( this.map._size.x, this.map._size.y );
                this._el = L.DomUtil.create('div', 'sg-3d-layer leaflet-zoom-hide');
                this._el.appendChild(this.renderer.domElement);
                this.map.getPanes().overlayPane.appendChild(this._el);
            },

            _resetScene: function () {
                var that = this;
                this.camera.aspect = this.map._size.x / this.map._size.y;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize( this.map._size.x, this.map._size.y );
                function degToRad (angle) { return angle * Math.PI / 180; }
                // How many vertical scene units can we see? (https://github.com/mrdoob/three.js/issues/1239)
                // Useful diagram: http://techpubs.sgi.com/library/dynaweb_docs/0650/SGI_Developer/books/Perf_PG/sgi_html/figures/04.3.frustum.gif
                var visibleHeight = 2 * Math.tan(degToRad(this.vFOV) / 2) * this.cameraHeight;
                var scale = that.map._size.y / visibleHeight;
                this.threeOrigin = new L.Point(this.map._size.x / 2, this.map._size.y / 2);
                // ScenePoint: x,y coord in the THREE scene
                // LatLng: x,y coord in the reference system
                // containerPoint: x,y coord on the screen
                this.latLngToScenePoint = function latLngToScenePoint (latLng) {
                    var containerPoint = that.map.latLngToContainerPoint(latLng);
                    return new L.LatLng(
                        (containerPoint.x - that.threeOrigin.x) * (1 / scale),
                        // Need to flip the y-axis
                        -1 * (containerPoint.y - that.threeOrigin.y) * (1 / scale)
                    );
                };
                var degreesLatVisible = this.map.containerPointToLatLng([0, this.map._size.y]).lat - this.map.containerPointToLatLng([0, 0]).lat;
                this.heightScale = degreesLatVisible / visibleHeight;
            },

            _startRenderLoop: function () {
                var that = this;
                var lastPos = null;
                function render() {
                    requestAnimationFrame(render);
                    function render2() {
                        if ( video.readyState === video.HAVE_ENOUGH_DATA ) {
                            imageContext.drawImage(video, 0, 0);
                        }
                        that.renderer.render( that.scene, that.camera );
                    }
                    render2();
                    var scenePoint = that.latLngToScenePoint(that.initialSceneOriginLatLng);
                    that.renderer.render(that.scene, that.camera);
                    var curPos = that.map.containerPointToLayerPoint([0, 0]);
                    if (lastPos === null || !(lastPos.x === curPos.x && lastPos.y === curPos.x)) {
                        L.DomUtil.setPosition(that._el, lastPos = curPos);
                    }
                }
                render();
            },

            _move: function () {
            },

            addTo: function (map) {
                map.addLayer(this);
                return this;
            },

            remove: function (map) {
                map.removeLayer(this);
                return this;
            },

            onAdd: function (map) {
                var that = this;
                this.map = map;
                if (this.renderer) {
                    // TODO: re-adding behavior
                } else {
                    this._initScene();
                    this._resetScene();
                    this._startRenderLoop();
                }
                this.map.on({
                    move: this._move,
                    viewreset: this._resetScene
                }, this);
                window.addEventListener('resize', function () { that._resetScene(); }, false);
            },

            onRemove: function (map) {
                map.off({
                    move: this._move,
                    viewreset: this._resetScene
                }, this);
            }
        });

        var sg3DLayer = new L.SG3DLayer().addTo(map);

        function timeFlow() {
            /*
            t0=data[0].TimeUS/1000;
            if (a == 0){
                renderStartTime = new Date().getTime();
                a = 1;
            }
            // primer frame del renderizado, comienza el reloj
            var currTime = new Date();
            var tolpos = 1e-3;
            var tolneg = 1e-6;
            renderCurrentTime = currTime.getTime();
            reloj = renderCurrentTime-renderStartTime ; // (ms)
            // Hacemos un algoritmo para garantizar que el tiempo transcurrido de renderizado coincide con el del log.
            renderTimeNow = data[j].TimeUS/1000-t0;
            renderTimeNext = data[j+1].TimeUS/1000-t0;
            if ( renderTimeNow - reloj < tolpos ) { // Casos A y B
                if ( renderTimeNext - reloj < tolpos ) { // Caso B
                    while ( renderTimeNext - reloj < tolpos) {
                        j++;// Condición para que se reinicie al final del bucleif(j>=data.length-1){j=0;renderStartTime = currTime.getTime();break
                    }
                    renderTimeNext = data[j].TimeUS/1000-t0;
                }
            } else { // Caso C
                while ( renderTimeNow - reloj > tolneg ){
                    j--;
                    renderTimeNow = data[j].TimeUS/1000-t0;
                }
            }
            */
            j++;
            if(j >= data.length - 0){
                j=0;
            }
            console.log(j);

            LatLng0 = map.latLngToContainerPoint(new L.LatLng(Lat0, Lng0));
            coordenadas = data[j].geometry.coordinates[0];

            p0 = sg3DLayer.map.latLngToContainerPoint(new L.LatLng(coordenadas[0][1],coordenadas[0][0]));
            p1 = sg3DLayer.map.latLngToContainerPoint(new L.LatLng(coordenadas[1][1],coordenadas[1][0]));
            p2 = sg3DLayer.map.latLngToContainerPoint(new L.LatLng(coordenadas[2][1],coordenadas[2][0]));
            p3 = sg3DLayer.map.latLngToContainerPoint(new L.LatLng(coordenadas[3][1],coordenadas[3][0]));

            /*
            p0 = map.latLngToContainerPoint(new L.LatLng(coordenadas[0][1],coordenadas[0][0]));
            p1 = map.latLngToContainerPoint(new L.LatLng(coordenadas[1][1],coordenadas[1][0]));
            p2 = map.latLngToContainerPoint(new L.LatLng(coordenadas[2][1],coordenadas[2][0]));
            p3 = map.latLngToContainerPoint(new L.LatLng(coordenadas[3][1],coordenadas[3][0]));
            */
            corners = [p0.x, p0.y, p1.x, p1.y, p3.x, p3.y, p2.x, p2.y];
            update();
        }

        setInterval(timeFlow,10/6);
    }
</script>

</body>
</html>