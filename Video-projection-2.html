<!DOCTYPE html>
<html lang="en">
<head>
    <title>Video Projection</title>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta http-equiv="Content-Language" content="en" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.6.3/leaflet.css" />
</head>
<body>

<div id="map" style="position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px"></div>

<script src="//cdnjs.cloudflare.com/ajax/libs/zepto/1.0/zepto.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/leaflet/0.6.3/leaflet.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/three.js/r58/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/16.6.0/Tween.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/r16/Stats.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="data/myGeoJsonLeaflet.js"></script>
<script>
    var Lng=(data.features[0].geometry.coordinates[0][0][0]+data.features[0].geometry.coordinates[0][2][0])/2;
    var Lat=(data.features[0].geometry.coordinates[0][0][1]+data.features[0].geometry.coordinates[0][2][1])/2;

    /*var map = L.map('map').setView([Lat, Lng], 16);

    var myStyle = {
        "color": "#ffbb00",
        "weight": 4,
        "opacity": 0.65,
        "fillOpacity": 0
    };

    L.tileLayer('https://api.tiles.mapbox.com/v4/{id}/{z}/{x}/{y}.png?access_token=pk.eyJ1IjoibWFwYm94IiwiYSI6ImNpejY4NXVycTA2emYycXBndHRqcmZ3N3gifQ.rJcFIG214AriISLbB6B5aw', {
        maxZoom: 18,
        attribution: 'Map data &copy; <a href="http://openstreetmap.org">OpenStreetMap</a> contributors, ' +
        '<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
        'Imagery Â© <a href="http://mapbox.com">Mapbox</a>',
        id: 'mapbox.satellite'
    }).addTo(map);
*/
    var videoUrls = [
        'https://www.mapbox.com/bites/00188/patricia_nasa.webm',
        'https://www.mapbox.com/bites/00188/patricia_nasa.mp4'
    ];

    var camera, scene, renderer;

    var video, videoImage, videoTexture, videoImageContext, movieScreen,
        imageReflection, imageReflectionContext, imageReflectionGradient,
        texture, textureReflection;

    var geojson;

    var j=0, a=0, renderStartTime=0, renderCurrentTime=0, renderTimeNow=0, renderTimeNext=0, reloj=0;
    var t0=data.features[0].TimeUS/1000;
    function represent(){
        var Lngj=(data.features[j].geometry.coordinates[0][0][0]+data.features[j].geometry.coordinates[0][2][0])/2;
        var Latj=(data.features[j].geometry.coordinates[0][0][1]+data.features[j].geometry.coordinates[0][2][1])/2;
        var rot=Math.atan2(data.features[j].geometry.coordinates[0][0][1]-data.features[j].geometry.coordinates[0][3][1],data.features[j].geometry.coordinates[0][0][0]-data.features[j].geometry.coordinates[0][3][0]);

        renderer = new THREE.CanvasRenderer();
        scene = new THREE.Scene();
        camera = new THREE.Camera();

        // create the video element
        video = document.createElement( 'video' );
        video.src = 'https://stemkoski.github.io/Three.js/videos/sintel.ogv';
        video.load(); // must call after setting/changing source
        video.play();
        videoImage = document.createElement( 'canvas' );
        //videoImage.width = Math.abs(data.features[j].geometry.coordinates[0][0][0]-data.features[j].geometry.coordinates[0][2][0])/Math.cos(rot);
        //videoImage.height = Math.abs(data.features[j].geometry.coordinates[0][0][1]-data.features[j].geometry.coordinates[0][2][1])/Math.sin(rot);
        videoImage.width = 480;
        videoImage.height = 200;

        videoImageContext = videoImage.getContext( '2d' );
        // background color if no video present
        videoImageContext.fillStyle = '#000000';
        videoImageContext.fillRect(0, 0, videoImage.width, videoImage.height);

        videoTexture = new THREE.Texture(videoImage);
        videoTexture.minFilter = THREE.LinearFilter;

        var movieMaterial = new THREE.MeshBasicMaterial( { map: videoTexture, overdraw: true, side:THREE.DoubleSide } );
        // the geometry on which the movie will be displayed;
        // 		movie image will be scaled to fit these dimensions.
        var movieGeometry = new THREE.PlaneGeometry(videoImage.width,videoImage.height);

        movieScreen = new THREE.Mesh( movieGeometry, movieMaterial );
        movieScreen.rotateOnAxis( [0,0,1], rot );
        //movieScreen.position.set(Lngj,Latj,0);
        movieScreen.position.set(200,200,0);
        scene.add(movieScreen);
/*
        if (a == 0){
            var currTime = new Date();
            renderStartTime = currTime.getTime();
            a = 1;
        } // primer frame del renderizado, comienza el reloj
        var currTime = new Date();
        renderCurrentTime = currTime.getTime();
        reloj = renderCurrentTime-renderStartTime ; // (ms)

        // Hacemos un algoritmo para garantizar que el tiempo transcurrido de renderizado coincide con el del log.
        renderTimeNow = data.features[j].TimeUS/1000-t0;
        renderTimeNext = data.features[j+1].TimeUS/1000-t0;
        if ( renderTimeNow - reloj < 0 ) { // Casos A y B
            if ( renderTimeNext - reloj < 0 ) { // Caso B
                while ( renderTimeNext - reloj < 0) {
                    j++;
                    renderTimeNext = data.features[j].TimeUS/1000-t0;
                }
            }
        } else { // Caso C
            while (renderTimeNow - reloj > 0) {
                j--;
                renderTimeNow = data.features[j].TimeUS/1000-t0;
            }
        };

        if (j>0){
            geojson.clearLayers();
        };
        geojson = L.geoJson(data.features[j], {
            style: myStyle
        }).addTo(map);

        if(j>data.features.length){j=0};*/
    };

    setInterval(represent,1);
</script>

</body>
</html>